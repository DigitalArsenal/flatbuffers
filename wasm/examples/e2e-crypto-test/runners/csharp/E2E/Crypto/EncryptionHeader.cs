// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace E2E.Crypto
{

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

/// Encryption header - sent out-of-band with encrypted message
public struct EncryptionHeader : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_24_12_23(); }
  public static EncryptionHeader GetRootAsEncryptionHeader(ByteBuffer _bb) { return GetRootAsEncryptionHeader(_bb, new EncryptionHeader()); }
  public static EncryptionHeader GetRootAsEncryptionHeader(ByteBuffer _bb, EncryptionHeader obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public EncryptionHeader __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /// Protocol version
  public ushort Version { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUshort(o + __p.bb_pos) : (ushort)1; } }
  /// Key exchange algorithm
  public E2E.Crypto.KeyExchangeAlgorithm KeyExchange { get { int o = __p.__offset(6); return o != 0 ? (E2E.Crypto.KeyExchangeAlgorithm)__p.bb.GetSbyte(o + __p.bb_pos) : E2E.Crypto.KeyExchangeAlgorithm.ECDH; } }
  /// Elliptic curve used
  public E2E.Crypto.Curve Curve { get { int o = __p.__offset(8); return o != 0 ? (E2E.Crypto.Curve)__p.bb.GetSbyte(o + __p.bb_pos) : E2E.Crypto.Curve.X25519; } }
  /// Encryption algorithm
  public E2E.Crypto.EncryptionAlgorithm Encryption { get { int o = __p.__offset(10); return o != 0 ? (E2E.Crypto.EncryptionAlgorithm)__p.bb.GetSbyte(o + __p.bb_pos) : E2E.Crypto.EncryptionAlgorithm.AES_256_CTR; } }
  /// Ephemeral public key from sender (for ECDH)
  public E2E.Crypto.PublicKey? EphemeralPublicKey { get { int o = __p.__offset(12); return o != 0 ? (E2E.Crypto.PublicKey?)(new E2E.Crypto.PublicKey()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  /// Sender identifier (optional)
  public string SenderId { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSenderIdBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetSenderIdBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetSenderIdArray() { return __p.__vector_as_array<byte>(14); }
  /// Timestamp (Unix epoch seconds)
  public ulong Timestamp { get { int o = __p.__offset(16); return o != 0 ? __p.bb.GetUlong(o + __p.bb_pos) : (ulong)0; } }

  public static Offset<E2E.Crypto.EncryptionHeader> CreateEncryptionHeader(FlatBufferBuilder builder,
      ushort version = 1,
      E2E.Crypto.KeyExchangeAlgorithm key_exchange = E2E.Crypto.KeyExchangeAlgorithm.ECDH,
      E2E.Crypto.Curve curve = E2E.Crypto.Curve.X25519,
      E2E.Crypto.EncryptionAlgorithm encryption = E2E.Crypto.EncryptionAlgorithm.AES_256_CTR,
      Offset<E2E.Crypto.PublicKey> ephemeral_public_keyOffset = default(Offset<E2E.Crypto.PublicKey>),
      StringOffset sender_idOffset = default(StringOffset),
      ulong timestamp = 0) {
    builder.StartTable(7);
    EncryptionHeader.AddTimestamp(builder, timestamp);
    EncryptionHeader.AddSenderId(builder, sender_idOffset);
    EncryptionHeader.AddEphemeralPublicKey(builder, ephemeral_public_keyOffset);
    EncryptionHeader.AddVersion(builder, version);
    EncryptionHeader.AddEncryption(builder, encryption);
    EncryptionHeader.AddCurve(builder, curve);
    EncryptionHeader.AddKeyExchange(builder, key_exchange);
    return EncryptionHeader.EndEncryptionHeader(builder);
  }

  public static void StartEncryptionHeader(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddVersion(FlatBufferBuilder builder, ushort version) { builder.AddUshort(0, version, 1); }
  public static void AddKeyExchange(FlatBufferBuilder builder, E2E.Crypto.KeyExchangeAlgorithm keyExchange) { builder.AddSbyte(1, (sbyte)keyExchange, 0); }
  public static void AddCurve(FlatBufferBuilder builder, E2E.Crypto.Curve curve) { builder.AddSbyte(2, (sbyte)curve, 0); }
  public static void AddEncryption(FlatBufferBuilder builder, E2E.Crypto.EncryptionAlgorithm encryption) { builder.AddSbyte(3, (sbyte)encryption, 0); }
  public static void AddEphemeralPublicKey(FlatBufferBuilder builder, Offset<E2E.Crypto.PublicKey> ephemeralPublicKeyOffset) { builder.AddOffset(4, ephemeralPublicKeyOffset.Value, 0); }
  public static void AddSenderId(FlatBufferBuilder builder, StringOffset senderIdOffset) { builder.AddOffset(5, senderIdOffset.Value, 0); }
  public static void AddTimestamp(FlatBufferBuilder builder, ulong timestamp) { builder.AddUlong(6, timestamp, 0); }
  public static Offset<E2E.Crypto.EncryptionHeader> EndEncryptionHeader(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<E2E.Crypto.EncryptionHeader>(o);
  }
}


static public class EncryptionHeaderVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Version*/, 2 /*ushort*/, 2, false)
      && verifier.VerifyField(tablePos, 6 /*KeyExchange*/, 1 /*E2E.Crypto.KeyExchangeAlgorithm*/, 1, false)
      && verifier.VerifyField(tablePos, 8 /*Curve*/, 1 /*E2E.Crypto.Curve*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*Encryption*/, 1 /*E2E.Crypto.EncryptionAlgorithm*/, 1, false)
      && verifier.VerifyTable(tablePos, 12 /*EphemeralPublicKey*/, E2E.Crypto.PublicKeyVerify.Verify, false)
      && verifier.VerifyString(tablePos, 14 /*SenderId*/, false)
      && verifier.VerifyField(tablePos, 16 /*Timestamp*/, 8 /*ulong*/, 8, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}
