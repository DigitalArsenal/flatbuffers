<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Rust - DA FlatBuffers</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --black: #000000;
      --white: #F5F5F7;
      --white-90: rgba(255, 255, 255, 0.9);
      --white-80: rgba(255, 255, 255, 0.8);
      --white-60: rgba(255, 255, 255, 0.6);
      --white-40: rgba(255, 255, 255, 0.4);
      --white-20: rgba(255, 255, 255, 0.2);
      --white-10: rgba(255, 255, 255, 0.1);
      --white-05: rgba(255, 255, 255, 0.05);
      --muted: rgba(134, 134, 139, 1.0);
      --glass-bg: rgba(42, 42, 45, 0.72);
      --glass-hover: rgba(66, 66, 69, 0.72);
      --glass-border: rgba(255, 255, 255, 0.1);
      --glass-blur: blur(20px);
      --radius: 28px;
      --radius-sm: 14px;

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;

    html {
      scroll-behavior: smooth;

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--black);
      color: var(--white);
      line-height: 1.6;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;

    /* Video Background */
    .video-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      overflow: hidden;

    .video-background video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.3;

    .video-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        to bottom,
        rgba(0, 0, 0, 0.4) 0%,
        rgba(0, 0, 0, 0.6) 50%,
        rgba(0, 0, 0, 0.85) 100%
      );

    .page-container {
      position: relative;
      z-index: 1;
      max-width: 900px;
      margin: 0 auto;
      padding: 60px 24px 80px;

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      margin-bottom: 40px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      color: var(--white);
      text-decoration: none;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.3s ease;

    .back-link:hover {
      background: var(--glass-hover);
      transform: translateY(-2px);

    .markdown-body {
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      padding: 64px;

    .markdown-body h1 {
      color: var(--white);
      font-size: 56px;
      font-weight: 600;
      line-height: 1.1;
      margin-bottom: 32px;
      letter-spacing: -0.02em;

    .markdown-body h2 {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--white);
      font-size: 28px;
      font-weight: 600;
      line-height: 1.15;
      margin-top: 56px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--glass-border);

    .markdown-body h2::before {
      content: '';
      display: inline-flex;
      width: 24px;
      height: 24px;
      background: var(--white);
      -webkit-mask-size: contain;
      mask-size: contain;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
      flex-shrink: 0;

    /* Icon mappings for h2 headers based on content */
    .markdown-body h2[id*="why"]::before,
    .markdown-body h2:has(+ p:first-of-type)::before {
      -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
      mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");

    .markdown-body h3,
    .markdown-body h4 {
      color: var(--white);
      font-weight: 600;
      margin-top: 32px;
      margin-bottom: 16px;

    .markdown-body h3 {
      font-size: 22px;

    .markdown-body h4 {
      font-size: 18px;
      color: var(--white-90);

    .markdown-body p {
      color: var(--white-80);
      font-size: 18px;
      line-height: 1.7;
      margin-bottom: 20px;

    .markdown-body a {
      color: var(--white);
      text-decoration: underline;
      text-underline-offset: 3px;
      transition: opacity 0.2s;

    .markdown-body a:hover {
      opacity: 0.7;

    .markdown-body strong {
      color: var(--white);
      font-weight: 600;

    .markdown-body code {
      background: var(--glass-hover);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      padding: 3px 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9em;
      color: var(--white);

    .markdown-body pre {
      background: var(--black) !important;
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      padding: 24px;
      overflow-x: auto;
      margin: 24px 0;

    .markdown-body pre code {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 14px;
      line-height: 1.7;
      color: var(--white-90);

    .markdown-body ul, .markdown-body ol {
      padding-left: 24px;
      margin-bottom: 20px;

    .markdown-body li {
      margin: 12px 0;
      color: var(--white-80);
      font-size: 18px;

    .markdown-body li strong {
      color: var(--white);

    .markdown-body table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      border-radius: var(--radius-sm);
      overflow: hidden;

    .markdown-body table th,
    .markdown-body table td {
      border: 1px solid var(--glass-border);
      padding: 14px 18px;
      text-align: left;

    .markdown-body table th {
      background: var(--glass-hover);
      font-weight: 600;
      color: var(--white);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;

    .markdown-body table td {
      background: var(--white-05);
      color: var(--white-80);

    .markdown-body table tr:nth-child(even) td {
      background: var(--white-10);

    .markdown-body blockquote {
      border-left: 4px solid var(--white-40);
      background: var(--white-05);
      padding: 20px 24px;
      margin: 24px 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;

    .markdown-body blockquote p {
      margin: 0;
      color: var(--white-80);

    .markdown-body hr {
      border: none;
      height: 1px;
      background: var(--glass-border);
      margin: 48px 0;

    /* Section header icons */
    .section-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: var(--white-10);
      border-radius: 8px;
      margin-right: 12px;
      flex-shrink: 0;

    .section-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--white);
      fill: none;
      stroke-width: 2;

    @media (max-width: 768px) {
      .page-container {
        padding: 40px 16px 60px;
      .markdown-body {
        padding: 32px 24px;
        border-radius: 20px;
      .markdown-body h1 {
        font-size: 36px;
      .markdown-body h2 {
        font-size: 24px;
      .markdown-body p,
      .markdown-body li {
        font-size: 16px;
  </style>
</head>
<body>
  <!-- Video Background -->
  <div class="video-background">
    <video autoplay loop muted playsinline id="bg-video">
      <source src="" type="application/x-mpegURL">
    </video>
    <div class="video-overlay"></div>
  </div>

  <div class="page-container">
    <a href="../index.html" class="back-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
      Back to DA FlatBuffers
    </a>
    <article class="markdown-body"><h1>Rust Integration Guide</h1>
<p>Integrate the FlatBuffers encryption WASM module into Rust applications using the <a href="https://wasmer.io/">wasmer</a> crate.</p>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg></span>Why wasmer?</h2>
<ul>
<li><strong>High performance</strong> - Native speed with LLVM, Cranelift, or Singlepass</li>
<li><strong>Memory safe</strong> - Rust&#39;s safety guarantees for WASM memory access</li>
<li><strong>Flexible</strong> - Multiple compiler backends</li>
<li><strong>Production ready</strong> - Used in production by many companies</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>Prerequisites</h2>
<ul>
<li>Rust 1.70 or later</li>
<li><code>flatc-encryption.wasm</code> binary</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></span>Installation</h2>
<p>Add to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
wasmer = &quot;4.2&quot;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>Quick Start</h2>
<pre><code class="language-rust">use wasmer::{imports, Instance, Module, Store, Value};
use std::fs;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create store
    let mut store = Store::default();

    // Load WASM
    let wasm_bytes = fs::read(&quot;flatc-encryption.wasm&quot;)?;
    let module = Module::new(&amp;store, &amp;wasm_bytes)?;

    // Create imports (WASI stubs)
    let import_object = imports! {
        &quot;wasi_snapshot_preview1&quot; =&gt; {
            &quot;fd_close&quot; =&gt; wasmer::Function::new_typed(&amp;mut store, |_fd: i32| -&gt; i32 { 0 }),
            &quot;clock_time_get&quot; =&gt; wasmer::Function::new_typed(&amp;mut store, |_: i32, _: i64, _: i32| -&gt; i32 { 0 }),
            // Add other WASI stubs as needed
        },
    };

    // Instantiate
    let instance = Instance::new(&amp;mut store, &amp;module, &amp;import_object)?;

    // Get exports
    let memory = instance.exports.get_memory(&quot;memory&quot;)?;
    let malloc = instance.exports.get_function(&quot;malloc&quot;)?;
    let free = instance.exports.get_function(&quot;free&quot;)?;
    let encrypt = instance.exports.get_function(&quot;wasi_encrypt_bytes&quot;)?;
    let decrypt = instance.exports.get_function(&quot;wasi_decrypt_bytes&quot;)?;

    // Encrypt data
    let key: [u8; 32] = rand::random();
    let iv: [u8; 16] = rand::random();
    let plaintext = b&quot;Hello, FlatBuffers!&quot;;

    // Allocate WASM memory
    let key_ptr = malloc.call(&amp;mut store, &amp;[Value::I32(32)])?[0].unwrap_i32() as u32;
    let iv_ptr = malloc.call(&amp;mut store, &amp;[Value::I32(16)])?[0].unwrap_i32() as u32;
    let data_ptr = malloc.call(&amp;mut store, &amp;[Value::I32(plaintext.len() as i32)])?[0].unwrap_i32() as u32;

    // Write to WASM memory
    let mem_view = memory.view(&amp;store);
    mem_view.write(key_ptr as u64, &amp;key)?;
    mem_view.write(iv_ptr as u64, &amp;iv)?;
    mem_view.write(data_ptr as u64, plaintext)?;

    // Encrypt
    encrypt.call(&amp;mut store, &amp;[
        Value::I32(key_ptr as i32),
        Value::I32(iv_ptr as i32),
        Value::I32(data_ptr as i32),
        Value::I32(plaintext.len() as i32),
    ])?;

    // Read encrypted data
    let mut ciphertext = vec![0u8; plaintext.len()];
    mem_view.read(data_ptr as u64, &amp;mut ciphertext)?;
    println!(&quot;Encrypted: {:?}&quot;, hex::encode(&amp;ciphertext));

    // Clean up
    free.call(&amp;mut store, &amp;[Value::I32(key_ptr as i32)])?;
    free.call(&amp;mut store, &amp;[Value::I32(iv_ptr as i32)])?;
    free.call(&amp;mut store, &amp;[Value::I32(data_ptr as i32)])?;

    Ok(())
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></span>Complete Module Wrapper</h2>
<pre><code class="language-rust">//! FlatBuffers Encryption Module for Rust
//!
//! Provides cryptographic operations via the Crypto++ WASM module.

use wasmer::{imports, Instance, Module, Store, Value, Memory, Function, FunctionEnv, FunctionEnvMut};
use std::sync::Arc;
use thiserror::Error;

/// Key and signature sizes
pub const AES_KEY_SIZE: usize = 32;
pub const AES_IV_SIZE: usize = 16;
pub const SHA256_SIZE: usize = 32;

pub const X25519_PRIVATE_KEY_SIZE: usize = 32;
pub const X25519_PUBLIC_KEY_SIZE: usize = 32;

pub const SECP256K1_PRIVATE_KEY_SIZE: usize = 32;
pub const SECP256K1_PUBLIC_KEY_SIZE: usize = 33;
pub const SECP256K1_SIGNATURE_MAX_SIZE: usize = 72;

pub const ED25519_PRIVATE_KEY_SIZE: usize = 64;
pub const ED25519_PUBLIC_KEY_SIZE: usize = 32;
pub const ED25519_SIGNATURE_SIZE: usize = 64;

#[derive(Error, Debug)]
pub enum EncryptionError {
    #[error(&quot;WASM error: {0}&quot;)]
    Wasm(#[from] wasmer::RuntimeError),
    #[error(&quot;Export error: {0}&quot;)]
    Export(#[from] wasmer::ExportError),
    #[error(&quot;Memory error: {0}&quot;)]
    Memory(#[from] wasmer::MemoryAccessError),
    #[error(&quot;Invalid key size: expected {expected}, got {actual}&quot;)]
    InvalidKeySize { expected: usize, actual: usize },
    #[error(&quot;Operation failed&quot;)]
    OperationFailed,
    #[error(&quot;IO error: {0}&quot;)]
    Io(#[from] std::io::Error),

pub type Result&lt;T&gt; = std::result::Result&lt;T, EncryptionError&gt;;

/// X25519 key pair
#[derive(Clone)]
pub struct X25519KeyPair {
    pub private_key: [u8; X25519_PRIVATE_KEY_SIZE],
    pub public_key: [u8; X25519_PUBLIC_KEY_SIZE],

/// Ed25519 key pair
#[derive(Clone)]
pub struct Ed25519KeyPair {
    pub private_key: [u8; ED25519_PRIVATE_KEY_SIZE],
    pub public_key: [u8; ED25519_PUBLIC_KEY_SIZE],

/// secp256k1 key pair
#[derive(Clone)]
pub struct Secp256k1KeyPair {
    pub private_key: [u8; SECP256K1_PRIVATE_KEY_SIZE],
    pub public_key: [u8; SECP256K1_PUBLIC_KEY_SIZE],

/// Encryption module wrapper
pub struct EncryptionModule {
    store: Store,
    instance: Instance,

impl EncryptionModule {
    /// Create a new encryption module from WASM bytes
    pub fn new(wasm_bytes: &amp;[u8]) -&gt; Result&lt;Self&gt; {
        let mut store = Store::default();
        let module = Module::new(&amp;store, wasm_bytes)?;

        // Create WASI stubs
        let import_object = imports! {
            &quot;wasi_snapshot_preview1&quot; =&gt; {
                &quot;fd_close&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32| -&gt; i32 { 0 }),
                &quot;fd_seek&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i64, _: i32, _: i32| -&gt; i32 { 0 }),
                &quot;fd_write&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i32, _: i32, _: i32| -&gt; i32 { 0 }),
                &quot;fd_read&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i32, _: i32, _: i32| -&gt; i32 { 0 }),
                &quot;environ_sizes_get&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i32| -&gt; i32 { 0 }),
                &quot;environ_get&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i32| -&gt; i32 { 0 }),
                &quot;clock_time_get&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i64, _: i32| -&gt; i32 { 0 }),
                &quot;proc_exit&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32| {}),
                &quot;random_get&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i32| -&gt; i32 { 0 }),
            },
            &quot;env&quot; =&gt; {
                &quot;invoke_v&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32| {}),
                &quot;invoke_vi&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i32| {}),
                &quot;invoke_vii&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i32, _: i32| {}),
                &quot;invoke_viii&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i32, _: i32, _: i32| {}),
                &quot;invoke_i&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32| -&gt; i32 { 0 }),
                &quot;invoke_ii&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i32| -&gt; i32 { 0 }),
                &quot;invoke_iii&quot; =&gt; Function::new_typed(&amp;mut store, |_: i32, _: i32, _: i32| -&gt; i32 { 0 }),
            },
        };

        let instance = Instance::new(&amp;mut store, &amp;module, &amp;import_object)?;

        Ok(Self { store, instance })

    /// Load from file
    pub fn from_file(path: &amp;str) -&gt; Result&lt;Self&gt; {
        let wasm_bytes = std::fs::read(path)?;
        Self::new(&amp;wasm_bytes)

    fn memory(&amp;self) -&gt; Result&lt;&amp;Memory&gt; {
        Ok(self.instance.exports.get_memory(&quot;memory&quot;)?)

    fn malloc(&amp;mut self, size: usize) -&gt; Result&lt;u32&gt; {
        let malloc = self.instance.exports.get_function(&quot;malloc&quot;)?;
        let result = malloc.call(&amp;mut self.store, &amp;[Value::I32(size as i32)])?;
        Ok(result[0].unwrap_i32() as u32)

    fn free(&amp;mut self, ptr: u32) -&gt; Result&lt;()&gt; {
        let free = self.instance.exports.get_function(&quot;free&quot;)?;
        free.call(&amp;mut self.store, &amp;[Value::I32(ptr as i32)])?;
        Ok(())

    fn write_bytes(&amp;self, ptr: u32, data: &amp;[u8]) -&gt; Result&lt;()&gt; {
        let memory = self.memory()?;
        let view = memory.view(&amp;self.store);
        view.write(ptr as u64, data)?;
        Ok(())

    fn read_bytes(&amp;self, ptr: u32, len: usize) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        let memory = self.memory()?;
        let view = memory.view(&amp;self.store);
        let mut buf = vec![0u8; len];
        view.read(ptr as u64, &amp;mut buf)?;
        Ok(buf)

    /// Encrypt data using AES-256-CTR
    pub fn encrypt(&amp;mut self, key: &amp;[u8], iv: &amp;[u8], data: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        if key.len() != AES_KEY_SIZE {
            return Err(EncryptionError::InvalidKeySize {
                expected: AES_KEY_SIZE,
                actual: key.len(),
            });
        if iv.len() != AES_IV_SIZE {
            return Err(EncryptionError::InvalidKeySize {
                expected: AES_IV_SIZE,
                actual: iv.len(),
            });

        let key_ptr = self.malloc(key.len())?;
        let iv_ptr = self.malloc(iv.len())?;
        let data_ptr = self.malloc(data.len())?;

        self.write_bytes(key_ptr, key)?;
        self.write_bytes(iv_ptr, iv)?;
        self.write_bytes(data_ptr, data)?;

        let encrypt = self.instance.exports.get_function(&quot;wasi_encrypt_bytes&quot;)?;
        let result = encrypt.call(&amp;mut self.store, &amp;[
            Value::I32(key_ptr as i32),
            Value::I32(iv_ptr as i32),
            Value::I32(data_ptr as i32),
            Value::I32(data.len() as i32),
        ])?;

        if result[0].unwrap_i32() != 0 {
            self.free(key_ptr)?;
            self.free(iv_ptr)?;
            self.free(data_ptr)?;
            return Err(EncryptionError::OperationFailed);

        let encrypted = self.read_bytes(data_ptr, data.len())?;

        self.free(key_ptr)?;
        self.free(iv_ptr)?;
        self.free(data_ptr)?;

        Ok(encrypted)

    /// Decrypt data using AES-256-CTR
    pub fn decrypt(&amp;mut self, key: &amp;[u8], iv: &amp;[u8], data: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        // CTR mode is symmetric
        self.encrypt(key, iv, data)

    /// Compute SHA-256 hash
    pub fn sha256(&amp;mut self, data: &amp;[u8]) -&gt; Result&lt;[u8; SHA256_SIZE]&gt; {
        let data_ptr = self.malloc(data.len())?;
        let out_ptr = self.malloc(SHA256_SIZE)?;

        self.write_bytes(data_ptr, data)?;

        let sha256 = self.instance.exports.get_function(&quot;wasi_sha256&quot;)?;
        sha256.call(&amp;mut self.store, &amp;[
            Value::I32(data_ptr as i32),
            Value::I32(data.len() as i32),
            Value::I32(out_ptr as i32),
        ])?;

        let hash = self.read_bytes(out_ptr, SHA256_SIZE)?;

        self.free(data_ptr)?;
        self.free(out_ptr)?;

        let mut result = [0u8; SHA256_SIZE];
        result.copy_from_slice(&amp;hash);
        Ok(result)

    /// Derive key using HKDF-SHA256
    pub fn hkdf(&amp;mut self, ikm: &amp;[u8], salt: Option&lt;&amp;[u8]&gt;, info: &amp;[u8], length: usize) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        let ikm_ptr = self.malloc(ikm.len())?;
        self.write_bytes(ikm_ptr, ikm)?;

        let (salt_ptr, salt_len) = if let Some(s) = salt {
            let ptr = self.malloc(s.len())?;
            self.write_bytes(ptr, s)?;
            (ptr, s.len())
        } else {
            (0, 0)
        };

        let info_ptr = self.malloc(info.len())?;
        self.write_bytes(info_ptr, info)?;

        let out_ptr = self.malloc(length)?;

        let hkdf = self.instance.exports.get_function(&quot;wasi_hkdf&quot;)?;
        hkdf.call(&amp;mut self.store, &amp;[
            Value::I32(ikm_ptr as i32),
            Value::I32(ikm.len() as i32),
            Value::I32(salt_ptr as i32),
            Value::I32(salt_len as i32),
            Value::I32(info_ptr as i32),
            Value::I32(info.len() as i32),
            Value::I32(out_ptr as i32),
            Value::I32(length as i32),
        ])?;

        let result = self.read_bytes(out_ptr, length)?;

        self.free(ikm_ptr)?;
        if salt_ptr != 0 {
            self.free(salt_ptr)?;
        self.free(info_ptr)?;
        self.free(out_ptr)?;

        Ok(result)

    /// Generate X25519 key pair
    pub fn x25519_generate_keypair(&amp;mut self) -&gt; Result&lt;X25519KeyPair&gt; {
        let priv_ptr = self.malloc(X25519_PRIVATE_KEY_SIZE)?;
        let pub_ptr = self.malloc(X25519_PUBLIC_KEY_SIZE)?;

        let generate = self.instance.exports.get_function(&quot;wasi_x25519_generate_keypair&quot;)?;
        let result = generate.call(&amp;mut self.store, &amp;[
            Value::I32(priv_ptr as i32),
            Value::I32(pub_ptr as i32),
        ])?;

        if result[0].unwrap_i32() != 0 {
            self.free(priv_ptr)?;
            self.free(pub_ptr)?;
            return Err(EncryptionError::OperationFailed);

        let priv_bytes = self.read_bytes(priv_ptr, X25519_PRIVATE_KEY_SIZE)?;
        let pub_bytes = self.read_bytes(pub_ptr, X25519_PUBLIC_KEY_SIZE)?;

        self.free(priv_ptr)?;
        self.free(pub_ptr)?;

        let mut private_key = [0u8; X25519_PRIVATE_KEY_SIZE];
        let mut public_key = [0u8; X25519_PUBLIC_KEY_SIZE];
        private_key.copy_from_slice(&amp;priv_bytes);
        public_key.copy_from_slice(&amp;pub_bytes);

        Ok(X25519KeyPair { private_key, public_key })

    /// Compute X25519 shared secret
    pub fn x25519_shared_secret(&amp;mut self, private_key: &amp;[u8], public_key: &amp;[u8]) -&gt; Result&lt;[u8; 32]&gt; {
        let priv_ptr = self.malloc(private_key.len())?;
        let pub_ptr = self.malloc(public_key.len())?;
        let out_ptr = self.malloc(32)?;

        self.write_bytes(priv_ptr, private_key)?;
        self.write_bytes(pub_ptr, public_key)?;

        let shared = self.instance.exports.get_function(&quot;wasi_x25519_shared_secret&quot;)?;
        let result = shared.call(&amp;mut self.store, &amp;[
            Value::I32(priv_ptr as i32),
            Value::I32(pub_ptr as i32),
            Value::I32(out_ptr as i32),
        ])?;

        if result[0].unwrap_i32() != 0 {
            self.free(priv_ptr)?;
            self.free(pub_ptr)?;
            self.free(out_ptr)?;
            return Err(EncryptionError::OperationFailed);

        let secret_bytes = self.read_bytes(out_ptr, 32)?;

        self.free(priv_ptr)?;
        self.free(pub_ptr)?;
        self.free(out_ptr)?;

        let mut secret = [0u8; 32];
        secret.copy_from_slice(&amp;secret_bytes);
        Ok(secret)

    /// Generate Ed25519 key pair
    pub fn ed25519_generate_keypair(&amp;mut self) -&gt; Result&lt;Ed25519KeyPair&gt; {
        let priv_ptr = self.malloc(ED25519_PRIVATE_KEY_SIZE)?;
        let pub_ptr = self.malloc(ED25519_PUBLIC_KEY_SIZE)?;

        let generate = self.instance.exports.get_function(&quot;wasi_ed25519_generate_keypair&quot;)?;
        let result = generate.call(&amp;mut self.store, &amp;[
            Value::I32(priv_ptr as i32),
            Value::I32(pub_ptr as i32),
        ])?;

        if result[0].unwrap_i32() != 0 {
            self.free(priv_ptr)?;
            self.free(pub_ptr)?;
            return Err(EncryptionError::OperationFailed);

        let priv_bytes = self.read_bytes(priv_ptr, ED25519_PRIVATE_KEY_SIZE)?;
        let pub_bytes = self.read_bytes(pub_ptr, ED25519_PUBLIC_KEY_SIZE)?;

        self.free(priv_ptr)?;
        self.free(pub_ptr)?;

        let mut private_key = [0u8; ED25519_PRIVATE_KEY_SIZE];
        let mut public_key = [0u8; ED25519_PUBLIC_KEY_SIZE];
        private_key.copy_from_slice(&amp;priv_bytes);
        public_key.copy_from_slice(&amp;pub_bytes);

        Ok(Ed25519KeyPair { private_key, public_key })

    /// Sign with Ed25519
    pub fn ed25519_sign(&amp;mut self, private_key: &amp;[u8], message: &amp;[u8]) -&gt; Result&lt;[u8; ED25519_SIGNATURE_SIZE]&gt; {
        let priv_ptr = self.malloc(private_key.len())?;
        let msg_ptr = self.malloc(message.len())?;
        let sig_ptr = self.malloc(ED25519_SIGNATURE_SIZE)?;

        self.write_bytes(priv_ptr, private_key)?;
        self.write_bytes(msg_ptr, message)?;

        let sign = self.instance.exports.get_function(&quot;wasi_ed25519_sign&quot;)?;
        let result = sign.call(&amp;mut self.store, &amp;[
            Value::I32(priv_ptr as i32),
            Value::I32(msg_ptr as i32),
            Value::I32(message.len() as i32),
            Value::I32(sig_ptr as i32),
        ])?;

        if result[0].unwrap_i32() != 0 {
            self.free(priv_ptr)?;
            self.free(msg_ptr)?;
            self.free(sig_ptr)?;
            return Err(EncryptionError::OperationFailed);

        let sig_bytes = self.read_bytes(sig_ptr, ED25519_SIGNATURE_SIZE)?;

        self.free(priv_ptr)?;
        self.free(msg_ptr)?;
        self.free(sig_ptr)?;

        let mut signature = [0u8; ED25519_SIGNATURE_SIZE];
        signature.copy_from_slice(&amp;sig_bytes);
        Ok(signature)

    /// Verify Ed25519 signature
    pub fn ed25519_verify(&amp;mut self, public_key: &amp;[u8], message: &amp;[u8], signature: &amp;[u8]) -&gt; Result&lt;bool&gt; {
        let pub_ptr = self.malloc(public_key.len())?;
        let msg_ptr = self.malloc(message.len())?;
        let sig_ptr = self.malloc(signature.len())?;

        self.write_bytes(pub_ptr, public_key)?;
        self.write_bytes(msg_ptr, message)?;
        self.write_bytes(sig_ptr, signature)?;

        let verify = self.instance.exports.get_function(&quot;wasi_ed25519_verify&quot;)?;
        let result = verify.call(&amp;mut self.store, &amp;[
            Value::I32(pub_ptr as i32),
            Value::I32(msg_ptr as i32),
            Value::I32(message.len() as i32),
            Value::I32(sig_ptr as i32),
        ])?;

        self.free(pub_ptr)?;
        self.free(msg_ptr)?;
        self.free(sig_ptr)?;

        Ok(result[0].unwrap_i32() == 0)
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>Template Project Structure</h2>
<pre><code>myproject/
├── Cargo.toml
├── src/
│   ├── main.rs
│   └── encryption.rs
├── wasm/
│   └── flatc-encryption.wasm
└── tests/
    └── integration_tests.rs
</code></pre>
<p><strong>Cargo.toml:</strong></p>
<pre><code class="language-toml">[package]
name = &quot;myproject&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
wasmer = &quot;4.2&quot;
thiserror = &quot;1.0&quot;
rand = &quot;0.8&quot;
hex = &quot;0.4&quot;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Usage Examples</h2>
<h3>Basic Encryption</h3>
<pre><code class="language-rust">use crate::encryption::EncryptionModule;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut module = EncryptionModule::from_file(&quot;flatc-encryption.wasm&quot;)?;

    let key: [u8; 32] = rand::random();
    let iv: [u8; 16] = rand::random();
    let plaintext = b&quot;Secret message&quot;;

    let ciphertext = module.encrypt(&amp;key, &amp;iv, plaintext)?;
    let decrypted = module.decrypt(&amp;key, &amp;iv, &amp;ciphertext)?;

    assert_eq!(plaintext.to_vec(), decrypted);
    Ok(())
</code></pre>
<h3>End-to-End Encryption</h3>
<pre><code class="language-rust">use crate::encryption::EncryptionModule;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let mut module = EncryptionModule::from_file(&quot;flatc-encryption.wasm&quot;)?;

    // Generate key pairs
    let alice = module.x25519_generate_keypair()?;
    let bob = module.x25519_generate_keypair()?;

    // Compute shared secret
    let alice_shared = module.x25519_shared_secret(&amp;alice.private_key, &amp;bob.public_key)?;
    let bob_shared = module.x25519_shared_secret(&amp;bob.private_key, &amp;alice.public_key)?;

    assert_eq!(alice_shared, bob_shared);

    // Derive encryption key
    let key = module.hkdf(&amp;alice_shared, None, b&quot;encryption-v1&quot;, 32)?;

    // Encrypt
    let iv: [u8; 16] = rand::random();
    let message = b&quot;Hello Bob!&quot;;
    let ciphertext = module.encrypt(&amp;key, &amp;iv, message)?;

    // Decrypt
    let decrypted = module.decrypt(&amp;key, &amp;iv, &amp;ciphertext)?;
    println!(&quot;Decrypted: {}&quot;, String::from_utf8_lossy(&amp;decrypted));

    Ok(())
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg></span>Performance Tips</h2>
<ol>
<li><strong>Reuse module instances</strong> - Module compilation is expensive</li>
<li><strong>Use TypedFunction</strong> - For hot paths, use typed function calls</li>
<li><strong>Batch allocations</strong> - Minimize malloc/free calls</li>
</ol>
<pre><code class="language-rust">// Good: Reuse instance
let mut module = EncryptionModule::from_file(&quot;wasm&quot;)?;
for item in items {
    module.encrypt(&amp;key, &amp;iv, item)?;

// Bad: Create new instance each time
for item in items {
    let mut module = EncryptionModule::from_file(&quot;wasm&quot;)?; // Slow!
    module.encrypt(&amp;key, &amp;iv, item)?;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg></span>Troubleshooting</h2>
<h3>"Import not found"</h3>
<p>Ensure all WASI and env imports are provided. See the complete wrapper above.</p>
<h3>"Memory access out of bounds"</h3>
<p>Check pointer validity:</p>
<pre><code class="language-rust">let ptr = self.malloc(size)?;
if ptr == 0 {
    return Err(EncryptionError::OperationFailed);
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg></span>See Also</h2>
<ul>
<li><a href="https://docs.wasmer.io/">wasmer Documentation</a></li>
<li><a href="README.html">API Reference</a></li>
<li><a href="README.html#security-considerations">Security Considerations</a></li>
</ul>
</article>
  </div>

  <script>
    // Initialize video with random selection
    const videoUrls = [
      "../videos/bg-1.mp4",
      "../videos/bg-2.mp4",
      "../videos/bg-3.mp4",
      "../videos/bg-4.mp4",
      "../videos/bg-5.mp4",
      "../videos/bg-6.mp4",
      "../videos/bg-7.mp4",
      "../videos/bg-8.mp4",
      "../videos/bg-9.mp4",
      "../videos/bg-10.mp4",
      "../videos/bg-11.mp4"
    ];

    const video = document.getElementById('bg-video');
    video.src = videoUrls[Math.floor(Math.random() * videoUrls.length)];
  </script>
</body>
</html>