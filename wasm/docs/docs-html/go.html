<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Go - DA FlatBuffers</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --black: #000000;
      --white: #F5F5F7;
      --white-90: rgba(255, 255, 255, 0.9);
      --white-80: rgba(255, 255, 255, 0.8);
      --white-60: rgba(255, 255, 255, 0.6);
      --white-40: rgba(255, 255, 255, 0.4);
      --white-20: rgba(255, 255, 255, 0.2);
      --white-10: rgba(255, 255, 255, 0.1);
      --white-05: rgba(255, 255, 255, 0.05);
      --muted: rgba(134, 134, 139, 1.0);
      --glass-bg: rgba(42, 42, 45, 0.72);
      --glass-hover: rgba(66, 66, 69, 0.72);
      --glass-border: rgba(255, 255, 255, 0.1);
      --glass-blur: blur(20px);
      --radius: 28px;
      --radius-sm: 14px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--black);
      color: var(--white);
      line-height: 1.6;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Video Background */
    .video-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      overflow: hidden;
    }

    .video-background video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.3;
    }

    .video-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        to bottom,
        rgba(0, 0, 0, 0.4) 0%,
        rgba(0, 0, 0, 0.6) 50%,
        rgba(0, 0, 0, 0.85) 100%
      );
    }

    .page-container {
      position: relative;
      z-index: 1;
      max-width: 900px;
      margin: 0 auto;
      padding: 60px 24px 80px;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      margin-bottom: 40px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      color: var(--white);
      text-decoration: none;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .back-link:hover {
      background: var(--glass-hover);
      transform: translateY(-2px);
    }

    .markdown-body {
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      padding: 64px;
    }

    .markdown-body h1 {
      color: var(--white);
      font-size: 56px;
      font-weight: 600;
      line-height: 1.1;
      margin-bottom: 32px;
      letter-spacing: -0.02em;
    }

    .markdown-body h2 {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--white);
      font-size: 28px;
      font-weight: 600;
      line-height: 1.15;
      margin-top: 56px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--glass-border);
    }

    .markdown-body h2::before {
      content: '';
      display: inline-flex;
      width: 24px;
      height: 24px;
      background: var(--white);
      -webkit-mask-size: contain;
      mask-size: contain;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
      flex-shrink: 0;
    }

    /* Icon mappings for h2 headers based on content */
    .markdown-body h2[id*="why"]::before,
    .markdown-body h2:has(+ p:first-of-type)::before {
      -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
      mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
    }

    .markdown-body h3,
    .markdown-body h4 {
      color: var(--white);
      font-weight: 600;
      margin-top: 32px;
      margin-bottom: 16px;
    }

    .markdown-body h3 {
      font-size: 22px;
    }

    .markdown-body h4 {
      font-size: 18px;
      color: var(--white-90);
    }

    .markdown-body p {
      color: var(--white-80);
      font-size: 18px;
      line-height: 1.7;
      margin-bottom: 20px;
    }

    .markdown-body a {
      color: var(--white);
      text-decoration: underline;
      text-underline-offset: 3px;
      transition: opacity 0.2s;
    }

    .markdown-body a:hover {
      opacity: 0.7;
    }

    .markdown-body strong {
      color: var(--white);
      font-weight: 600;
    }

    .markdown-body code {
      background: var(--glass-hover);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      padding: 3px 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9em;
      color: var(--white);
    }

    .markdown-body pre {
      background: var(--black) !important;
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      padding: 24px;
      overflow-x: auto;
      margin: 24px 0;
    }

    .markdown-body pre code {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 14px;
      line-height: 1.7;
      color: var(--white-90);
    }

    .markdown-body ul, .markdown-body ol {
      padding-left: 24px;
      margin-bottom: 20px;
    }

    .markdown-body li {
      margin: 12px 0;
      color: var(--white-80);
      font-size: 18px;
    }

    .markdown-body li strong {
      color: var(--white);
    }

    .markdown-body table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      border-radius: var(--radius-sm);
      overflow: hidden;
    }

    .markdown-body table th,
    .markdown-body table td {
      border: 1px solid var(--glass-border);
      padding: 14px 18px;
      text-align: left;
    }

    .markdown-body table th {
      background: var(--glass-hover);
      font-weight: 600;
      color: var(--white);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .markdown-body table td {
      background: var(--white-05);
      color: var(--white-80);
    }

    .markdown-body table tr:nth-child(even) td {
      background: var(--white-10);
    }

    .markdown-body blockquote {
      border-left: 4px solid var(--white-40);
      background: var(--white-05);
      padding: 20px 24px;
      margin: 24px 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    }

    .markdown-body blockquote p {
      margin: 0;
      color: var(--white-80);
    }

    .markdown-body hr {
      border: none;
      height: 1px;
      background: var(--glass-border);
      margin: 48px 0;
    }

    /* Section header icons */
    .section-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: var(--white-10);
      border-radius: 8px;
      margin-right: 12px;
      flex-shrink: 0;
    }

    .section-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--white);
      fill: none;
      stroke-width: 2;
    }

    @media (max-width: 768px) {
      .page-container {
        padding: 40px 16px 60px;
      }
      .markdown-body {
        padding: 32px 24px;
        border-radius: 20px;
      }
      .markdown-body h1 {
        font-size: 36px;
      }
      .markdown-body h2 {
        font-size: 24px;
      }
      .markdown-body p,
      .markdown-body li {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <!-- Video Background -->
  <div class="video-background">
    <video autoplay loop muted playsinline id="bg-video">
      <source src="" type="application/x-mpegURL">
    </video>
    <div class="video-overlay"></div>
  </div>

  <div class="page-container">
    <a href="../index.html" class="back-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
      Back to DA FlatBuffers
    </a>
    <article class="markdown-body"><h1>Go Integration Guide</h1>
<p>Integrate the FlatBuffers encryption WASM module into Go applications using <a href="https://wazero.io/">wazero</a>, a pure Go WebAssembly runtime with zero dependencies.</p>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg></span>Why wazero?</h2>
<ul>
<li><strong>Pure Go</strong> - No CGo, no native dependencies</li>
<li><strong>Zero dependencies</strong> - Just Go standard library</li>
<li><strong>Fast startup</strong> - Optimized for CLI tools and serverless</li>
<li><strong>Full WASI support</strong> - Complete WASI snapshot preview1 implementation</li>
<li><strong>Production ready</strong> - Used by Envoy, Dapr, and many others</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>Prerequisites</h2>
<ul>
<li>Go 1.20 or later</li>
<li><code>flatc-encryption.wasm</code> binary</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></span>Installation</h2>
<pre><code class="language-bash">go get github.com/tetratelabs/wazero
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>Quick Start</h2>
<pre><code class="language-go">package main

import (
    &quot;context&quot;
    &quot;crypto/rand&quot;
    &quot;fmt&quot;
    &quot;os&quot;

    &quot;github.com/tetratelabs/wazero&quot;
    &quot;github.com/tetratelabs/wazero/api&quot;
    &quot;github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1&quot;
)

func main() {
    ctx := context.Background()

    // Create runtime
    r := wazero.NewRuntime(ctx)
    defer r.Close(ctx)

    // Instantiate WASI
    wasi_snapshot_preview1.MustInstantiate(ctx, r)

    // Load WASM module
    wasmBytes, err := os.ReadFile(&quot;flatc-encryption.wasm&quot;)
    if err != nil {
        panic(err)
    }

    // Instantiate module
    module, err := r.Instantiate(ctx, wasmBytes)
    if err != nil {
        panic(err)
    }

    // Get exported functions
    malloc := module.ExportedFunction(&quot;malloc&quot;)
    free := module.ExportedFunction(&quot;free&quot;)
    encrypt := module.ExportedFunction(&quot;wasi_encrypt_bytes&quot;)
    decrypt := module.ExportedFunction(&quot;wasi_decrypt_bytes&quot;)

    // Encrypt some data
    key := make([]byte, 32)
    iv := make([]byte, 16)
    rand.Read(key)
    rand.Read(iv)

    plaintext := []byte(&quot;Hello, FlatBuffers!&quot;)

    // Allocate WASM memory
    keyPtr, _ := malloc.Call(ctx, 32)
    ivPtr, _ := malloc.Call(ctx, 16)
    dataPtr, _ := malloc.Call(ctx, uint64(len(plaintext)))
    defer func() {
        free.Call(ctx, keyPtr[0])
        free.Call(ctx, ivPtr[0])
        free.Call(ctx, dataPtr[0])
    }()

    // Write data to WASM memory
    mem := module.Memory()
    mem.Write(uint32(keyPtr[0]), key)
    mem.Write(uint32(ivPtr[0]), iv)
    mem.Write(uint32(dataPtr[0]), plaintext)

    // Encrypt in-place
    encrypt.Call(ctx, keyPtr[0], ivPtr[0], dataPtr[0], uint64(len(plaintext)))

    // Read encrypted data
    ciphertext, _ := mem.Read(uint32(dataPtr[0]), uint32(len(plaintext)))
    fmt.Printf(&quot;Encrypted: %x\n&quot;, ciphertext)

    // Decrypt in-place (CTR mode is symmetric)
    decrypt.Call(ctx, keyPtr[0], ivPtr[0], dataPtr[0], uint64(len(plaintext)))

    // Read decrypted data
    decrypted, _ := mem.Read(uint32(dataPtr[0]), uint32(len(plaintext)))
    fmt.Printf(&quot;Decrypted: %s\n&quot;, decrypted)
}
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></span>Complete Module Wrapper</h2>
<p>For production use, wrap the WASM module in a Go struct:</p>
<pre><code class="language-go">package encryption

import (
    &quot;context&quot;
    &quot;crypto/rand&quot;
    &quot;errors&quot;
    &quot;os&quot;

    &quot;github.com/tetratelabs/wazero&quot;
    &quot;github.com/tetratelabs/wazero/api&quot;
    &quot;github.com/tetratelabs/wazero/experimental/table&quot;
    &quot;github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1&quot;
)

// Key and signature sizes
const (
    AESKeySize   = 32
    AESIVSize    = 16
    SHA256Size   = 32

    X25519PrivateKeySize = 32
    X25519PublicKeySize  = 32

    Secp256k1PrivateKeySize = 32
    Secp256k1PublicKeySize  = 33
    Secp256k1SignatureSize  = 72

    Ed25519PrivateKeySize = 64
    Ed25519PublicKeySize  = 32
    Ed25519SignatureSize  = 64
)

// Module wraps the WASM encryption module
type Module struct {
    ctx     context.Context
    runtime wazero.Runtime
    module  api.Module
    memory  api.Memory

    malloc api.Function
    free   api.Function

    // Symmetric
    encrypt api.Function
    decrypt api.Function

    // Hash
    sha256 api.Function
    hkdf   api.Function

    // X25519
    x25519Generate api.Function
    x25519Shared   api.Function

    // secp256k1
    secp256k1Generate api.Function
    secp256k1Shared   api.Function
    secp256k1Sign     api.Function
    secp256k1Verify   api.Function

    // Ed25519
    ed25519Generate api.Function
    ed25519Sign     api.Function
    ed25519Verify   api.Function
}

// New creates a new encryption module
func New(ctx context.Context, wasmPath string) (*Module, error) {
    wasmBytes, err := os.ReadFile(wasmPath)
    if err != nil {
        return nil, err
    }

    r := wazero.NewRuntime(ctx)

    // Instantiate WASI
    wasi_snapshot_preview1.MustInstantiate(ctx, r)

    // Create env module with Emscripten trampolines
    if err := defineEnvModule(ctx, r); err != nil {
        r.Close(ctx)
        return nil, err
    }

    // Instantiate the encryption module
    module, err := r.Instantiate(ctx, wasmBytes)
    if err != nil {
        r.Close(ctx)
        return nil, err
    }

    m := &amp;Module{
        ctx:     ctx,
        runtime: r,
        module:  module,
        memory:  module.Memory(),

        malloc:  module.ExportedFunction(&quot;malloc&quot;),
        free:    module.ExportedFunction(&quot;free&quot;),
        encrypt: module.ExportedFunction(&quot;wasi_encrypt_bytes&quot;),
        decrypt: module.ExportedFunction(&quot;wasi_decrypt_bytes&quot;),
        sha256:  module.ExportedFunction(&quot;wasi_sha256&quot;),
        hkdf:    module.ExportedFunction(&quot;wasi_hkdf&quot;),

        x25519Generate: module.ExportedFunction(&quot;wasi_x25519_generate_keypair&quot;),
        x25519Shared:   module.ExportedFunction(&quot;wasi_x25519_shared_secret&quot;),

        secp256k1Generate: module.ExportedFunction(&quot;wasi_secp256k1_generate_keypair&quot;),
        secp256k1Shared:   module.ExportedFunction(&quot;wasi_secp256k1_shared_secret&quot;),
        secp256k1Sign:     module.ExportedFunction(&quot;wasi_secp256k1_sign&quot;),
        secp256k1Verify:   module.ExportedFunction(&quot;wasi_secp256k1_verify&quot;),

        ed25519Generate: module.ExportedFunction(&quot;wasi_ed25519_generate_keypair&quot;),
        ed25519Sign:     module.ExportedFunction(&quot;wasi_ed25519_sign&quot;),
        ed25519Verify:   module.ExportedFunction(&quot;wasi_ed25519_verify&quot;),
    }

    return m, nil
}

// Close releases all resources
func (m *Module) Close() error {
    return m.runtime.Close(m.ctx)
}

// Encrypt encrypts data in-place using AES-256-CTR
func (m *Module) Encrypt(key, iv, data []byte) error {
    if len(key) != AESKeySize {
        return errors.New(&quot;key must be 32 bytes&quot;)
    }
    if len(iv) != AESIVSize {
        return errors.New(&quot;iv must be 16 bytes&quot;)
    }

    keyPtr, ivPtr, dataPtr, err := m.allocateAndWrite(key, iv, data)
    if err != nil {
        return err
    }
    defer m.freeAll(keyPtr, ivPtr, dataPtr)

    result, err := m.encrypt.Call(m.ctx, keyPtr, ivPtr, dataPtr, uint64(len(data)))
    if err != nil {
        return err
    }
    if result[0] != 0 {
        return errors.New(&quot;encryption failed&quot;)
    }

    // Read encrypted data back
    encrypted, _ := m.memory.Read(uint32(dataPtr), uint32(len(data)))
    copy(data, encrypted)
    return nil
}

// Decrypt decrypts data in-place using AES-256-CTR
func (m *Module) Decrypt(key, iv, data []byte) error {
    return m.Encrypt(key, iv, data) // CTR mode is symmetric
}

// SHA256 computes SHA-256 hash
func (m *Module) SHA256(data []byte) ([]byte, error) {
    dataPtr, err := m.allocate(uint64(len(data)))
    if err != nil {
        return nil, err
    }
    outPtr, err := m.allocate(SHA256Size)
    if err != nil {
        m.free.Call(m.ctx, dataPtr)
        return nil, err
    }
    defer m.freeAll(dataPtr, outPtr)

    m.memory.Write(uint32(dataPtr), data)

    _, err = m.sha256.Call(m.ctx, dataPtr, uint64(len(data)), outPtr)
    if err != nil {
        return nil, err
    }

    hash, _ := m.memory.Read(uint32(outPtr), SHA256Size)
    return hash, nil
}

// HKDF derives a key using HKDF-SHA256
func (m *Module) HKDF(ikm, salt, info []byte, length int) ([]byte, error) {
    ikmPtr, err := m.allocate(uint64(len(ikm)))
    if err != nil {
        return nil, err
    }
    m.memory.Write(uint32(ikmPtr), ikm)
    defer m.free.Call(m.ctx, ikmPtr)

    var saltPtr uint64 = 0
    saltLen := 0
    if len(salt) &gt; 0 {
        saltPtr, _ = m.allocate(uint64(len(salt)))
        m.memory.Write(uint32(saltPtr), salt)
        saltLen = len(salt)
        defer m.free.Call(m.ctx, saltPtr)
    }

    var infoPtr uint64 = 0
    infoLen := 0
    if len(info) &gt; 0 {
        infoPtr, _ = m.allocate(uint64(len(info)))
        m.memory.Write(uint32(infoPtr), info)
        infoLen = len(info)
        defer m.free.Call(m.ctx, infoPtr)
    }

    outPtr, _ := m.allocate(uint64(length))
    defer m.free.Call(m.ctx, outPtr)

    _, err = m.hkdf.Call(m.ctx,
        ikmPtr, uint64(len(ikm)),
        saltPtr, uint64(saltLen),
        infoPtr, uint64(infoLen),
        outPtr, uint64(length))
    if err != nil {
        return nil, err
    }

    result, _ := m.memory.Read(uint32(outPtr), uint32(length))
    return result, nil
}

// X25519KeyPair represents an X25519 key pair
type X25519KeyPair struct {
    PrivateKey []byte // 32 bytes
    PublicKey  []byte // 32 bytes
}

// X25519GenerateKeyPair generates a new X25519 key pair
func (m *Module) X25519GenerateKeyPair() (*X25519KeyPair, error) {
    privPtr, _ := m.allocate(X25519PrivateKeySize)
    pubPtr, _ := m.allocate(X25519PublicKeySize)
    defer m.freeAll(privPtr, pubPtr)

    result, err := m.x25519Generate.Call(m.ctx, privPtr, pubPtr)
    if err != nil {
        return nil, err
    }
    if result[0] != 0 {
        return nil, errors.New(&quot;key generation failed&quot;)
    }

    priv, _ := m.memory.Read(uint32(privPtr), X25519PrivateKeySize)
    pub, _ := m.memory.Read(uint32(pubPtr), X25519PublicKeySize)

    return &amp;X25519KeyPair{
        PrivateKey: priv,
        PublicKey:  pub,
    }, nil
}

// X25519SharedSecret computes shared secret
func (m *Module) X25519SharedSecret(privateKey, publicKey []byte) ([]byte, error) {
    privPtr, _ := m.allocate(uint64(len(privateKey)))
    pubPtr, _ := m.allocate(uint64(len(publicKey)))
    outPtr, _ := m.allocate(32)
    defer m.freeAll(privPtr, pubPtr, outPtr)

    m.memory.Write(uint32(privPtr), privateKey)
    m.memory.Write(uint32(pubPtr), publicKey)

    result, err := m.x25519Shared.Call(m.ctx, privPtr, pubPtr, outPtr)
    if err != nil {
        return nil, err
    }
    if result[0] != 0 {
        return nil, errors.New(&quot;shared secret computation failed&quot;)
    }

    secret, _ := m.memory.Read(uint32(outPtr), 32)
    return secret, nil
}

// Ed25519KeyPair represents an Ed25519 key pair
type Ed25519KeyPair struct {
    PrivateKey []byte // 64 bytes (seed + public key)
    PublicKey  []byte // 32 bytes
}

// Ed25519GenerateKeyPair generates a new Ed25519 key pair
func (m *Module) Ed25519GenerateKeyPair() (*Ed25519KeyPair, error) {
    privPtr, _ := m.allocate(Ed25519PrivateKeySize)
    pubPtr, _ := m.allocate(Ed25519PublicKeySize)
    defer m.freeAll(privPtr, pubPtr)

    result, err := m.ed25519Generate.Call(m.ctx, privPtr, pubPtr)
    if err != nil {
        return nil, err
    }
    if result[0] != 0 {
        return nil, errors.New(&quot;key generation failed&quot;)
    }

    priv, _ := m.memory.Read(uint32(privPtr), Ed25519PrivateKeySize)
    pub, _ := m.memory.Read(uint32(pubPtr), Ed25519PublicKeySize)

    return &amp;Ed25519KeyPair{
        PrivateKey: priv,
        PublicKey:  pub,
    }, nil
}

// Ed25519Sign signs a message
func (m *Module) Ed25519Sign(privateKey, message []byte) ([]byte, error) {
    privPtr, _ := m.allocate(uint64(len(privateKey)))
    msgPtr, _ := m.allocate(uint64(len(message)))
    sigPtr, _ := m.allocate(Ed25519SignatureSize)
    defer m.freeAll(privPtr, msgPtr, sigPtr)

    m.memory.Write(uint32(privPtr), privateKey)
    m.memory.Write(uint32(msgPtr), message)

    result, err := m.ed25519Sign.Call(m.ctx, privPtr, msgPtr, uint64(len(message)), sigPtr)
    if err != nil {
        return nil, err
    }
    if result[0] != 0 {
        return nil, errors.New(&quot;signing failed&quot;)
    }

    sig, _ := m.memory.Read(uint32(sigPtr), Ed25519SignatureSize)
    return sig, nil
}

// Ed25519Verify verifies a signature
func (m *Module) Ed25519Verify(publicKey, message, signature []byte) (bool, error) {
    pubPtr, _ := m.allocate(uint64(len(publicKey)))
    msgPtr, _ := m.allocate(uint64(len(message)))
    sigPtr, _ := m.allocate(uint64(len(signature)))
    defer m.freeAll(pubPtr, msgPtr, sigPtr)

    m.memory.Write(uint32(pubPtr), publicKey)
    m.memory.Write(uint32(msgPtr), message)
    m.memory.Write(uint32(sigPtr), signature)

    result, err := m.ed25519Verify.Call(m.ctx, pubPtr, msgPtr, uint64(len(message)), sigPtr)
    if err != nil {
        return false, err
    }

    return result[0] == 0, nil
}

// Helper functions

func (m *Module) allocate(size uint64) (uint64, error) {
    result, err := m.malloc.Call(m.ctx, size)
    if err != nil {
        return 0, err
    }
    return result[0], nil
}

func (m *Module) allocateAndWrite(buffers ...[]byte) ([]uint64, error) {
    ptrs := make([]uint64, len(buffers))
    for i, buf := range buffers {
        ptr, err := m.allocate(uint64(len(buf)))
        if err != nil {
            // Free already allocated
            for j := 0; j &lt; i; j++ {
                m.free.Call(m.ctx, ptrs[j])
            }
            return nil, err
        }
        ptrs[i] = ptr
        m.memory.Write(uint32(ptr), buf)
    }
    return ptrs, nil
}

func (m *Module) freeAll(ptrs ...uint64) {
    for _, ptr := range ptrs {
        m.free.Call(m.ctx, ptr)
    }
}
</code></pre>
<h3>Emscripten Trampolines</h3>
<p>The WASM module requires Emscripten&#39;s exception handling trampolines:</p>
<pre><code class="language-go">func defineEnvModule(ctx context.Context, r wazero.Runtime) error {
    var wasmModule api.Module
    i32 := api.ValueTypeI32

    setException := func(ctx context.Context) {
        if wasmModule != nil {
            if f := wasmModule.ExportedFunction(&quot;setThrew&quot;); f != nil {
                f.Call(ctx, 1, 0)
            }
        }
    }

    _, err := r.NewHostModuleBuilder(&quot;env&quot;).
        NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx uint32) {
            defer func() { recover(); setException(ctx) }()
            f := table.LookupFunction(wasmModule, 0, idx, nil, nil)
            f.Call(ctx)
        }).Export(&quot;invoke_v&quot;).
        NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a uint32) {
            defer func() { recover(); setException(ctx) }()
            f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32}, nil)
            f.Call(ctx, uint64(a))
        }).Export(&quot;invoke_vi&quot;).
        NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b uint32) {
            defer func() { recover(); setException(ctx) }()
            f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32}, nil)
            f.Call(ctx, uint64(a), uint64(b))
        }).Export(&quot;invoke_vii&quot;).
        // Add more invoke_* variants as needed...
        Instantiate(ctx)

    return err
}
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>Template Project Structure</h2>
<pre><code>myproject/
├── go.mod
├── go.sum
├── main.go
├── encryption/
│   └── module.go      # WASM wrapper
├── wasm/
│   └── flatc-encryption.wasm
└── README.html
</code></pre>
<p><strong>go.mod:</strong></p>
<pre><code class="language-go">module myproject

go 1.21

require github.com/tetratelabs/wazero v1.7.0
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Advanced Usage</h2>
<h3>Context Cancellation</h3>
<p>Use context for timeout and cancellation:</p>
<pre><code class="language-go">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()

module, err := New(ctx, &quot;flatc-encryption.wasm&quot;)
if err != nil {
    if errors.Is(err, context.DeadlineExceeded) {
        log.Fatal(&quot;WASM loading timed out&quot;)
    }
    log.Fatal(err)
}
</code></pre>
<h3>Module Caching</h3>
<p>Cache compiled modules for faster subsequent instantiation:</p>
<pre><code class="language-go">// Compile once
compiled, err := r.CompileModule(ctx, wasmBytes)
if err != nil {
    return nil, err
}

// Instantiate multiple times (fast)
instance1, _ := r.InstantiateModule(ctx, compiled, config)
instance2, _ := r.InstantiateModule(ctx, compiled, config)
</code></pre>
<h3>Concurrent Usage</h3>
<p>Each module instance has its own memory and can be used concurrently:</p>
<pre><code class="language-go">// Create pool of modules
pool := make(chan *Module, 10)
for i := 0; i &lt; 10; i++ {
    m, _ := New(ctx, &quot;flatc-encryption.wasm&quot;)
    pool &lt;- m
}

// Use from pool
func encryptConcurrent(data []byte) []byte {
    m := &lt;-pool
    defer func() { pool &lt;- m }()

    m.Encrypt(key, iv, data)
    return data
}
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg></span>Performance Tips</h2>
<ol>
<li><strong>Reuse module instances</strong> - Module initialization is expensive</li>
<li><strong>Use compilation cache</strong> - wazero supports filesystem caching</li>
<li><strong>Batch operations</strong> - Minimize Go-WASM boundary crossings</li>
<li><strong>Pre-allocate memory</strong> - Reuse allocated buffers for repeated operations</li>
</ol>
<h3>Compilation Cache</h3>
<pre><code class="language-go">// Enable filesystem cache
cache, err := wazero.NewCompilationCacheWithDir(&quot;/tmp/wazero-cache&quot;)
if err != nil {
    log.Fatal(err)
}

config := wazero.NewRuntimeConfig().WithCompilationCache(cache)
r := wazero.NewRuntimeWithConfig(ctx, config)
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg></span>Troubleshooting</h2>
<h3>"function not exported"</h3>
<p>The function name may differ. Check exports:</p>
<pre><code class="language-go">for name := range module.ExportedFunctionDefinitions() {
    fmt.Println(&quot;Exported:&quot;, name)
}
</code></pre>
<h3>"memory access out of bounds"</h3>
<p>Check that pointers from <code>malloc</code> are valid:</p>
<pre><code class="language-go">result, err := malloc.Call(ctx, size)
if err != nil {
    return err
}
if result[0] == 0 {
    return errors.New(&quot;malloc returned null&quot;)
}
</code></pre>
<h3>"import not found: env.invoke_*"</h3>
<p>Add Emscripten trampolines (see above). The exact <code>invoke_*</code> variants needed depend on the WASM module.</p>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg></span>See Also</h2>
<ul>
<li><a href="https://wazero.io/">wazero Documentation</a></li>
<li><a href="README.html">API Reference</a></li>
<li><a href="README.html#security-considerations">Security Considerations</a></li>
</ul>
</article>
  </div>

  <script>
    // Initialize HLS video with random selection
    const videoUrls = [
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/90bb1b34646b81b3b63e5a854ea00da3/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/df176a2fb2ea2b64bd21ae1c10d3af6a/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/12a9780eeb1ea015801a5f55cf2e9d3d/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/964cb3eddff1a67e3772aac9a7aceea2/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/dd17599dfa77f41517133fa7a4967535/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/408ad52e3f15bc8f01ae69d194a8cf3a/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/e923e67d71fed3e0853ec57f0348451e/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/136a8a211c6c3b1cc1fd7b1c7d836c58/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/c9ddd33ac3d964e5d33b31ce849e8f95/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/257c7359efd4b4aaebcc03aa8fc78a36/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/697945ca6b876878dba3b23fbd2f1561/manifest/video.m3u8"
    ];

    const video = document.getElementById('bg-video');
    const randomUrl = videoUrls[Math.floor(Math.random() * videoUrls.length)];

    if (Hls.isSupported()) {
      const hls = new Hls();
      hls.loadSource(randomUrl);
      hls.attachMedia(video);
    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
      video.src = randomUrl;
    }
  </script>
</body>
</html>
