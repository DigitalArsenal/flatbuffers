// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;


/// FlatBuffers field-level encryption support using AES-256-CTR.
pub mod flatbuffers_encryption {
  const SBOX: [u8; 256] = [
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16,
  ];
  const RCON: [u8; 10] = [0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36];

  fn xtime(x: u8) -> u8 { ((x << 1) ^ (if x & 0x80 != 0 { 0x1b } else { 0 })) }

  fn expand_key(key: &[u8]) -> [u8; 240] {
    let mut expanded = [0u8; 240];
    expanded[..32].copy_from_slice(&key[..32]);
    let mut rcon_idx = 0usize;
    let mut i = 32;
    while i < 240 {
      let mut t = [expanded[i-4], expanded[i-3], expanded[i-2], expanded[i-1]];
      if i % 32 == 0 {
        t = [SBOX[t[1] as usize] ^ RCON[rcon_idx], SBOX[t[2] as usize], SBOX[t[3] as usize], SBOX[t[0] as usize]];
        rcon_idx += 1;
      } else if i % 32 == 16 {
        t = [SBOX[t[0] as usize], SBOX[t[1] as usize], SBOX[t[2] as usize], SBOX[t[3] as usize]];
      }
      for j in 0..4 { expanded[i + j] = expanded[i - 32 + j] ^ t[j]; }
      i += 4;
    }
    expanded
  }

  fn aes_encrypt_block(block: &[u8; 16], expanded_key: &[u8; 240]) -> [u8; 16] {
    let mut state = *block;
    for i in 0..16 { state[i] ^= expanded_key[i]; }
    for round in 1..=14 {
      for i in 0..16 { state[i] = SBOX[state[i] as usize]; }
      let t1 = state[1]; state[1] = state[5]; state[5] = state[9]; state[9] = state[13]; state[13] = t1;
      let t2 = state[2]; state[2] = state[10]; state[10] = t2;
      let t6 = state[6]; state[6] = state[14]; state[14] = t6;
      let t3 = state[15]; state[15] = state[11]; state[11] = state[7]; state[7] = state[3]; state[3] = t3;
      if round < 14 {
        for c in 0..4 {
          let i = c * 4;
          let (s0, s1, s2, s3) = (state[i], state[i+1], state[i+2], state[i+3]);
          let x = s0 ^ s1 ^ s2 ^ s3;
          state[i] ^= x ^ xtime(s0 ^ s1);
          state[i+1] ^= x ^ xtime(s1 ^ s2);
          state[i+2] ^= x ^ xtime(s2 ^ s3);
          state[i+3] ^= x ^ xtime(s3 ^ s0);
        }
      }
      let offset = round * 16;
      for i in 0..16 { state[i] ^= expanded_key[offset + i]; }
    }
    state
  }

  fn increment_counter(counter: &mut [u8; 16]) {
    for i in (0..16).rev() {
      counter[i] = counter[i].wrapping_add(1);
      if counter[i] != 0 { break; }
    }
  }

  fn derive_nonce(ctx: &[u8], field_offset: u16) -> [u8; 16] {
    let mut nonce = [0u8; 16];
    nonce[..12].copy_from_slice(&ctx[..12]);
    nonce[12..16].copy_from_slice(&(field_offset as u32).to_le_bytes());
    nonce
  }

  fn decrypt_bytes(data: &[u8], ctx: &[u8], field_offset: u16) -> Vec<u8> {
    let key: [u8; 32] = ctx[..32].try_into().unwrap();
    let mut counter = derive_nonce(ctx, field_offset);
    let expanded_key = expand_key(&key);
    let mut result = vec![0u8; data.len()];
    let mut i = 0;
    while i < data.len() {
      let keystream = aes_encrypt_block(&counter, &expanded_key);
      let block_len = core::cmp::min(16, data.len() - i);
      for j in 0..block_len { result[i + j] = data[i + j] ^ keystream[j]; }
      increment_counter(&mut counter);
      i += 16;
    }
    result
  }

  pub fn decrypt_scalar<T: Copy + Sized>(value: T, ctx: &Option<Vec<u8>>, field_offset: u16) -> T {
    match ctx {
      None => value,
      Some(c) => {
        if c.len() < 32 { return value; }
        let size = core::mem::size_of::<T>();
        let bytes: &[u8] = unsafe { core::slice::from_raw_parts(&value as *const T as *const u8, size) };
        let decrypted = decrypt_bytes(bytes, c, field_offset);
        let mut result = core::mem::MaybeUninit::<T>::uninit();
        unsafe {
          core::ptr::copy_nonoverlapping(decrypted.as_ptr(), result.as_mut_ptr() as *mut u8, size);
          result.assume_init()
        }
      }
    }
  }

  pub fn decrypt_string(value: Option<&str>, ctx: &Option<Vec<u8>>, field_offset: u16) -> Option<String> {
    match (value, ctx) {
      (None, _) => None,
      (Some(s), None) => Some(s.to_string()),
      (Some(s), Some(c)) => {
        if c.len() < 32 { return Some(s.to_string()); }
        let decrypted = decrypt_bytes(s.as_bytes(), c, field_offset);
        String::from_utf8(decrypted).ok()
      }
    }
  }
}

#[allow(unused_imports, dead_code)]
pub mod encryption_test {


// struct Coordinates, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Coordinates(pub [u8; 16]);
impl Default for Coordinates { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl ::core::fmt::Debug for Coordinates {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    f.debug_struct("Coordinates")
      .field("lat", &self.lat())
      .field("lon", &self.lon())
      .finish()
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for Coordinates {}
impl<'a> ::flatbuffers::Follow<'a> for Coordinates {
  type Inner = &'a Coordinates;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a Coordinates>::follow(buf, loc) }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for &'a Coordinates {
  type Inner = &'a Coordinates;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { ::flatbuffers::follow_cast_ref::<Coordinates>(buf, loc) }
  }
}
impl<'b> ::flatbuffers::Push for Coordinates {
    type Output = Coordinates;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const Coordinates as *const u8, <Self as ::flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> ::flatbuffers::PushAlignment {
        ::flatbuffers::PushAlignment::new(8)
    }
}

impl<'a> ::flatbuffers::Verifiable for Coordinates {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Coordinates {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    lat: f64,
    lon: f64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_lat(lat);
    s.set_lon(lon);
    s
  }

  pub fn lat(&self) -> f64 {
    let mut mem = ::core::mem::MaybeUninit::<<f64 as ::flatbuffers::EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    ::flatbuffers::EndianScalar::from_little_endian(unsafe {
      ::core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        ::core::mem::size_of::<<f64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_lat(&mut self, x: f64) {
    let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      ::core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        ::core::mem::size_of::<<f64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn lon(&self) -> f64 {
    let mut mem = ::core::mem::MaybeUninit::<<f64 as ::flatbuffers::EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    ::flatbuffers::EndianScalar::from_little_endian(unsafe {
      ::core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        ::core::mem::size_of::<<f64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_lon(&mut self, x: f64) {
    let x_le = ::flatbuffers::EndianScalar::to_little_endian(x);
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      ::core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        ::core::mem::size_of::<<f64 as ::flatbuffers::EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum PublicDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PublicData<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for PublicData<'a> {
  type Inner = PublicData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> PublicData<'a> {
  pub const VT_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_LABEL: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    PublicData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PublicDataArgs<'args>
  ) -> ::flatbuffers::WIPOffset<PublicData<'bldr>> {
    let mut builder = PublicDataBuilder::new(_fbb);
    builder.add_id(args.id);
    if let Some(x) = args.label { builder.add_label(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(PublicData::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(PublicData::VT_LABEL, None)}
  }
}

impl ::flatbuffers::Verifiable for PublicData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .finish();
    Ok(())
  }
}
pub struct PublicDataArgs<'a> {
    pub id: u64,
    pub label: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PublicDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    PublicDataArgs {
      id: 0,
      label: None,
    }
  }
}

pub struct PublicDataBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> PublicDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(PublicData::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_label(&mut self, label: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(PublicData::VT_LABEL, label);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> PublicDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PublicDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<PublicData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for PublicData<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("PublicData");
      ds.field("id", &self.id());
      ds.field("label", &self.label());
      ds.finish()
  }
}
pub enum SensorReadingOffset {}
#[derive(Clone, PartialEq)]

pub struct SensorReading<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
  pub encryption_ctx: Option<Vec<u8>>,
}

impl<'a> ::flatbuffers::Follow<'a> for SensorReading<'a> {
  type Inner = SensorReading<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) }, encryption_ctx: None }
  }
}

impl<'a> SensorReading<'a> {
  pub const VT_DEVICE_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_TIMESTAMP: ::flatbuffers::VOffsetT = 6;
  pub const VT_PUBLIC_DATA: ::flatbuffers::VOffsetT = 8;
  pub const VT_LOCATION: ::flatbuffers::VOffsetT = 10;
  pub const VT_TEMPERATURE: ::flatbuffers::VOffsetT = 12;
  pub const VT_RAW_DATA: ::flatbuffers::VOffsetT = 14;
  pub const VT_SECRET_MESSAGE: ::flatbuffers::VOffsetT = 16;
  pub const VT_READINGS: ::flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    SensorReading { _tab: table, encryption_ctx: None }
  }
  #[inline]
  pub unsafe fn init_from_table_with_ctx(table: ::flatbuffers::Table<'a>, ctx: Option<Vec<u8>>) -> Self {
    SensorReading { _tab: table, encryption_ctx: ctx }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SensorReadingArgs<'args>
  ) -> ::flatbuffers::WIPOffset<SensorReading<'bldr>> {
    let mut builder = SensorReadingBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.readings { builder.add_readings(x); }
    if let Some(x) = args.secret_message { builder.add_secret_message(x); }
    if let Some(x) = args.raw_data { builder.add_raw_data(x); }
    builder.add_temperature(args.temperature);
    if let Some(x) = args.location { builder.add_location(x); }
    if let Some(x) = args.public_data { builder.add_public_data(x); }
    if let Some(x) = args.device_id { builder.add_device_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn device_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(SensorReading::VT_DEVICE_ID, None)}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SensorReading::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn public_data(&self) -> Option<PublicData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<PublicData>>(SensorReading::VT_PUBLIC_DATA, None)}
  }
  #[inline]
  pub fn location(&self) -> Option<&'a Coordinates> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Coordinates>(SensorReading::VT_LOCATION, None)}
  }
  #[inline]
  pub fn temperature(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<f32>(SensorReading::VT_TEMPERATURE, Some(0.0)).unwrap()}, &self.encryption_ctx, SensorReading::VT_TEMPERATURE)
  }
  #[inline]
  pub fn raw_data(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(SensorReading::VT_RAW_DATA, None)}
  }
  #[inline]
  pub fn secret_message(&self) -> Option<String> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_string(unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(SensorReading::VT_SECRET_MESSAGE, None)}, &self.encryption_ctx, SensorReading::VT_SECRET_MESSAGE)
  }
  #[inline]
  pub fn readings(&self) -> Option<::flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, f32>>>(SensorReading::VT_READINGS, None)}
  }
}

impl ::flatbuffers::Verifiable for SensorReading<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("device_id", Self::VT_DEVICE_ID, false)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<PublicData>>("public_data", Self::VT_PUBLIC_DATA, false)?
     .visit_field::<Coordinates>("location", Self::VT_LOCATION, false)?
     .visit_field::<f32>("temperature", Self::VT_TEMPERATURE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("raw_data", Self::VT_RAW_DATA, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("secret_message", Self::VT_SECRET_MESSAGE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, f32>>>("readings", Self::VT_READINGS, false)?
     .finish();
    Ok(())
  }
}
pub struct SensorReadingArgs<'a> {
    pub device_id: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: u64,
    pub public_data: Option<::flatbuffers::WIPOffset<PublicData<'a>>>,
    pub location: Option<&'a Coordinates>,
    pub temperature: f32,
    pub raw_data: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
    pub secret_message: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub readings: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for SensorReadingArgs<'a> {
  #[inline]
  fn default() -> Self {
    SensorReadingArgs {
      device_id: None,
      timestamp: 0,
      public_data: None,
      location: None,
      temperature: 0.0,
      raw_data: None,
      secret_message: None,
      readings: None,
    }
  }
}

pub struct SensorReadingBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SensorReadingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_device_id(&mut self, device_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(SensorReading::VT_DEVICE_ID, device_id);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(SensorReading::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_public_data(&mut self, public_data: ::flatbuffers::WIPOffset<PublicData<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<PublicData>>(SensorReading::VT_PUBLIC_DATA, public_data);
  }
  #[inline]
  pub fn add_location(&mut self, location: &Coordinates) {
    self.fbb_.push_slot_always::<&Coordinates>(SensorReading::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_temperature(&mut self, temperature: f32) {
    self.fbb_.push_slot::<f32>(SensorReading::VT_TEMPERATURE, temperature, 0.0);
  }
  #[inline]
  pub fn add_raw_data(&mut self, raw_data: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(SensorReading::VT_RAW_DATA, raw_data);
  }
  #[inline]
  pub fn add_secret_message(&mut self, secret_message: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(SensorReading::VT_SECRET_MESSAGE, secret_message);
  }
  #[inline]
  pub fn add_readings(&mut self, readings: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(SensorReading::VT_READINGS, readings);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> SensorReadingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SensorReadingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<SensorReading<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for SensorReading<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("SensorReading");
      ds.field("device_id", &self.device_id());
      ds.field("timestamp", &self.timestamp());
      ds.field("public_data", &self.public_data());
      ds.field("location", &self.location());
      ds.field("temperature", &self.temperature());
      ds.field("raw_data", &self.raw_data());
      ds.field("secret_message", &self.secret_message());
      ds.field("readings", &self.readings());
      ds.finish()
  }
}
pub enum UserRecordOffset {}
#[derive(Clone, PartialEq)]

pub struct UserRecord<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
  pub encryption_ctx: Option<Vec<u8>>,
}

impl<'a> ::flatbuffers::Follow<'a> for UserRecord<'a> {
  type Inner = UserRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) }, encryption_ctx: None }
  }
}

impl<'a> UserRecord<'a> {
  pub const VT_USER_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_USERNAME: ::flatbuffers::VOffsetT = 6;
  pub const VT_PASSWORD_HASH: ::flatbuffers::VOffsetT = 8;
  pub const VT_PRIVATE_KEY: ::flatbuffers::VOffsetT = 10;
  pub const VT_SSN: ::flatbuffers::VOffsetT = 12;
  pub const VT_BALANCE: ::flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    UserRecord { _tab: table, encryption_ctx: None }
  }
  #[inline]
  pub unsafe fn init_from_table_with_ctx(table: ::flatbuffers::Table<'a>, ctx: Option<Vec<u8>>) -> Self {
    UserRecord { _tab: table, encryption_ctx: ctx }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UserRecordArgs<'args>
  ) -> ::flatbuffers::WIPOffset<UserRecord<'bldr>> {
    let mut builder = UserRecordBuilder::new(_fbb);
    builder.add_balance(args.balance);
    builder.add_user_id(args.user_id);
    if let Some(x) = args.ssn { builder.add_ssn(x); }
    if let Some(x) = args.private_key { builder.add_private_key(x); }
    if let Some(x) = args.password_hash { builder.add_password_hash(x); }
    if let Some(x) = args.username { builder.add_username(x); }
    builder.finish()
  }


  #[inline]
  pub fn user_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(UserRecord::VT_USER_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn username(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(UserRecord::VT_USERNAME, None)}
  }
  #[inline]
  pub fn password_hash(&self) -> Option<String> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_string(unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(UserRecord::VT_PASSWORD_HASH, None)}, &self.encryption_ctx, UserRecord::VT_PASSWORD_HASH)
  }
  #[inline]
  pub fn private_key(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(UserRecord::VT_PRIVATE_KEY, None)}
  }
  #[inline]
  pub fn ssn(&self) -> Option<String> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_string(unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(UserRecord::VT_SSN, None)}, &self.encryption_ctx, UserRecord::VT_SSN)
  }
  #[inline]
  pub fn balance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<f64>(UserRecord::VT_BALANCE, Some(0.0)).unwrap()}, &self.encryption_ctx, UserRecord::VT_BALANCE)
  }
}

impl ::flatbuffers::Verifiable for UserRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<u64>("user_id", Self::VT_USER_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("username", Self::VT_USERNAME, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("password_hash", Self::VT_PASSWORD_HASH, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("private_key", Self::VT_PRIVATE_KEY, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("ssn", Self::VT_SSN, false)?
     .visit_field::<f64>("balance", Self::VT_BALANCE, false)?
     .finish();
    Ok(())
  }
}
pub struct UserRecordArgs<'a> {
    pub user_id: u64,
    pub username: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub password_hash: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub private_key: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
    pub ssn: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub balance: f64,
}
impl<'a> Default for UserRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    UserRecordArgs {
      user_id: 0,
      username: None,
      password_hash: None,
      private_key: None,
      ssn: None,
      balance: 0.0,
    }
  }
}

pub struct UserRecordBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> UserRecordBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user_id(&mut self, user_id: u64) {
    self.fbb_.push_slot::<u64>(UserRecord::VT_USER_ID, user_id, 0);
  }
  #[inline]
  pub fn add_username(&mut self, username: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(UserRecord::VT_USERNAME, username);
  }
  #[inline]
  pub fn add_password_hash(&mut self, password_hash: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(UserRecord::VT_PASSWORD_HASH, password_hash);
  }
  #[inline]
  pub fn add_private_key(&mut self, private_key: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(UserRecord::VT_PRIVATE_KEY, private_key);
  }
  #[inline]
  pub fn add_ssn(&mut self, ssn: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(UserRecord::VT_SSN, ssn);
  }
  #[inline]
  pub fn add_balance(&mut self, balance: f64) {
    self.fbb_.push_slot::<f64>(UserRecord::VT_BALANCE, balance, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> UserRecordBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UserRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<UserRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for UserRecord<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("UserRecord");
      ds.field("user_id", &self.user_id());
      ds.field("username", &self.username());
      ds.field("password_hash", &self.password_hash());
      ds.field("private_key", &self.private_key());
      ds.field("ssn", &self.ssn());
      ds.field("balance", &self.balance());
      ds.finish()
  }
}
pub enum ScalarTestOffset {}
#[derive(Clone, PartialEq)]

pub struct ScalarTest<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
  pub encryption_ctx: Option<Vec<u8>>,
}

impl<'a> ::flatbuffers::Follow<'a> for ScalarTest<'a> {
  type Inner = ScalarTest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) }, encryption_ctx: None }
  }
}

impl<'a> ScalarTest<'a> {
  pub const VT_ENCRYPTED_BOOL: ::flatbuffers::VOffsetT = 4;
  pub const VT_ENCRYPTED_BYTE: ::flatbuffers::VOffsetT = 6;
  pub const VT_ENCRYPTED_UBYTE: ::flatbuffers::VOffsetT = 8;
  pub const VT_ENCRYPTED_SHORT: ::flatbuffers::VOffsetT = 10;
  pub const VT_ENCRYPTED_USHORT: ::flatbuffers::VOffsetT = 12;
  pub const VT_ENCRYPTED_INT: ::flatbuffers::VOffsetT = 14;
  pub const VT_ENCRYPTED_UINT: ::flatbuffers::VOffsetT = 16;
  pub const VT_ENCRYPTED_LONG: ::flatbuffers::VOffsetT = 18;
  pub const VT_ENCRYPTED_ULONG: ::flatbuffers::VOffsetT = 20;
  pub const VT_ENCRYPTED_FLOAT: ::flatbuffers::VOffsetT = 22;
  pub const VT_ENCRYPTED_DOUBLE: ::flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    ScalarTest { _tab: table, encryption_ctx: None }
  }
  #[inline]
  pub unsafe fn init_from_table_with_ctx(table: ::flatbuffers::Table<'a>, ctx: Option<Vec<u8>>) -> Self {
    ScalarTest { _tab: table, encryption_ctx: ctx }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ScalarTestArgs
  ) -> ::flatbuffers::WIPOffset<ScalarTest<'bldr>> {
    let mut builder = ScalarTestBuilder::new(_fbb);
    builder.add_encrypted_double(args.encrypted_double);
    builder.add_encrypted_ulong(args.encrypted_ulong);
    builder.add_encrypted_long(args.encrypted_long);
    builder.add_encrypted_float(args.encrypted_float);
    builder.add_encrypted_uint(args.encrypted_uint);
    builder.add_encrypted_int(args.encrypted_int);
    builder.add_encrypted_ushort(args.encrypted_ushort);
    builder.add_encrypted_short(args.encrypted_short);
    builder.add_encrypted_ubyte(args.encrypted_ubyte);
    builder.add_encrypted_byte(args.encrypted_byte);
    builder.add_encrypted_bool(args.encrypted_bool);
    builder.finish()
  }


  #[inline]
  pub fn encrypted_bool(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<bool>(ScalarTest::VT_ENCRYPTED_BOOL, Some(false)).unwrap()}, &self.encryption_ctx, ScalarTest::VT_ENCRYPTED_BOOL)
  }
  #[inline]
  pub fn encrypted_byte(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<i8>(ScalarTest::VT_ENCRYPTED_BYTE, Some(0)).unwrap()}, &self.encryption_ctx, ScalarTest::VT_ENCRYPTED_BYTE)
  }
  #[inline]
  pub fn encrypted_ubyte(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<u8>(ScalarTest::VT_ENCRYPTED_UBYTE, Some(0)).unwrap()}, &self.encryption_ctx, ScalarTest::VT_ENCRYPTED_UBYTE)
  }
  #[inline]
  pub fn encrypted_short(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<i16>(ScalarTest::VT_ENCRYPTED_SHORT, Some(0)).unwrap()}, &self.encryption_ctx, ScalarTest::VT_ENCRYPTED_SHORT)
  }
  #[inline]
  pub fn encrypted_ushort(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<u16>(ScalarTest::VT_ENCRYPTED_USHORT, Some(0)).unwrap()}, &self.encryption_ctx, ScalarTest::VT_ENCRYPTED_USHORT)
  }
  #[inline]
  pub fn encrypted_int(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<i32>(ScalarTest::VT_ENCRYPTED_INT, Some(0)).unwrap()}, &self.encryption_ctx, ScalarTest::VT_ENCRYPTED_INT)
  }
  #[inline]
  pub fn encrypted_uint(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<u32>(ScalarTest::VT_ENCRYPTED_UINT, Some(0)).unwrap()}, &self.encryption_ctx, ScalarTest::VT_ENCRYPTED_UINT)
  }
  #[inline]
  pub fn encrypted_long(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<i64>(ScalarTest::VT_ENCRYPTED_LONG, Some(0)).unwrap()}, &self.encryption_ctx, ScalarTest::VT_ENCRYPTED_LONG)
  }
  #[inline]
  pub fn encrypted_ulong(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<u64>(ScalarTest::VT_ENCRYPTED_ULONG, Some(0)).unwrap()}, &self.encryption_ctx, ScalarTest::VT_ENCRYPTED_ULONG)
  }
  #[inline]
  pub fn encrypted_float(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<f32>(ScalarTest::VT_ENCRYPTED_FLOAT, Some(0.0)).unwrap()}, &self.encryption_ctx, ScalarTest::VT_ENCRYPTED_FLOAT)
  }
  #[inline]
  pub fn encrypted_double(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    crate::flatbuffers_encryption::decrypt_scalar(unsafe { self._tab.get::<f64>(ScalarTest::VT_ENCRYPTED_DOUBLE, Some(0.0)).unwrap()}, &self.encryption_ctx, ScalarTest::VT_ENCRYPTED_DOUBLE)
  }
}

impl ::flatbuffers::Verifiable for ScalarTest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<bool>("encrypted_bool", Self::VT_ENCRYPTED_BOOL, false)?
     .visit_field::<i8>("encrypted_byte", Self::VT_ENCRYPTED_BYTE, false)?
     .visit_field::<u8>("encrypted_ubyte", Self::VT_ENCRYPTED_UBYTE, false)?
     .visit_field::<i16>("encrypted_short", Self::VT_ENCRYPTED_SHORT, false)?
     .visit_field::<u16>("encrypted_ushort", Self::VT_ENCRYPTED_USHORT, false)?
     .visit_field::<i32>("encrypted_int", Self::VT_ENCRYPTED_INT, false)?
     .visit_field::<u32>("encrypted_uint", Self::VT_ENCRYPTED_UINT, false)?
     .visit_field::<i64>("encrypted_long", Self::VT_ENCRYPTED_LONG, false)?
     .visit_field::<u64>("encrypted_ulong", Self::VT_ENCRYPTED_ULONG, false)?
     .visit_field::<f32>("encrypted_float", Self::VT_ENCRYPTED_FLOAT, false)?
     .visit_field::<f64>("encrypted_double", Self::VT_ENCRYPTED_DOUBLE, false)?
     .finish();
    Ok(())
  }
}
pub struct ScalarTestArgs {
    pub encrypted_bool: bool,
    pub encrypted_byte: i8,
    pub encrypted_ubyte: u8,
    pub encrypted_short: i16,
    pub encrypted_ushort: u16,
    pub encrypted_int: i32,
    pub encrypted_uint: u32,
    pub encrypted_long: i64,
    pub encrypted_ulong: u64,
    pub encrypted_float: f32,
    pub encrypted_double: f64,
}
impl<'a> Default for ScalarTestArgs {
  #[inline]
  fn default() -> Self {
    ScalarTestArgs {
      encrypted_bool: false,
      encrypted_byte: 0,
      encrypted_ubyte: 0,
      encrypted_short: 0,
      encrypted_ushort: 0,
      encrypted_int: 0,
      encrypted_uint: 0,
      encrypted_long: 0,
      encrypted_ulong: 0,
      encrypted_float: 0.0,
      encrypted_double: 0.0,
    }
  }
}

pub struct ScalarTestBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ScalarTestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_encrypted_bool(&mut self, encrypted_bool: bool) {
    self.fbb_.push_slot::<bool>(ScalarTest::VT_ENCRYPTED_BOOL, encrypted_bool, false);
  }
  #[inline]
  pub fn add_encrypted_byte(&mut self, encrypted_byte: i8) {
    self.fbb_.push_slot::<i8>(ScalarTest::VT_ENCRYPTED_BYTE, encrypted_byte, 0);
  }
  #[inline]
  pub fn add_encrypted_ubyte(&mut self, encrypted_ubyte: u8) {
    self.fbb_.push_slot::<u8>(ScalarTest::VT_ENCRYPTED_UBYTE, encrypted_ubyte, 0);
  }
  #[inline]
  pub fn add_encrypted_short(&mut self, encrypted_short: i16) {
    self.fbb_.push_slot::<i16>(ScalarTest::VT_ENCRYPTED_SHORT, encrypted_short, 0);
  }
  #[inline]
  pub fn add_encrypted_ushort(&mut self, encrypted_ushort: u16) {
    self.fbb_.push_slot::<u16>(ScalarTest::VT_ENCRYPTED_USHORT, encrypted_ushort, 0);
  }
  #[inline]
  pub fn add_encrypted_int(&mut self, encrypted_int: i32) {
    self.fbb_.push_slot::<i32>(ScalarTest::VT_ENCRYPTED_INT, encrypted_int, 0);
  }
  #[inline]
  pub fn add_encrypted_uint(&mut self, encrypted_uint: u32) {
    self.fbb_.push_slot::<u32>(ScalarTest::VT_ENCRYPTED_UINT, encrypted_uint, 0);
  }
  #[inline]
  pub fn add_encrypted_long(&mut self, encrypted_long: i64) {
    self.fbb_.push_slot::<i64>(ScalarTest::VT_ENCRYPTED_LONG, encrypted_long, 0);
  }
  #[inline]
  pub fn add_encrypted_ulong(&mut self, encrypted_ulong: u64) {
    self.fbb_.push_slot::<u64>(ScalarTest::VT_ENCRYPTED_ULONG, encrypted_ulong, 0);
  }
  #[inline]
  pub fn add_encrypted_float(&mut self, encrypted_float: f32) {
    self.fbb_.push_slot::<f32>(ScalarTest::VT_ENCRYPTED_FLOAT, encrypted_float, 0.0);
  }
  #[inline]
  pub fn add_encrypted_double(&mut self, encrypted_double: f64) {
    self.fbb_.push_slot::<f64>(ScalarTest::VT_ENCRYPTED_DOUBLE, encrypted_double, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ScalarTestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ScalarTestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<ScalarTest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for ScalarTest<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("ScalarTest");
      ds.field("encrypted_bool", &self.encrypted_bool());
      ds.field("encrypted_byte", &self.encrypted_byte());
      ds.field("encrypted_ubyte", &self.encrypted_ubyte());
      ds.field("encrypted_short", &self.encrypted_short());
      ds.field("encrypted_ushort", &self.encrypted_ushort());
      ds.field("encrypted_int", &self.encrypted_int());
      ds.field("encrypted_uint", &self.encrypted_uint());
      ds.field("encrypted_long", &self.encrypted_long());
      ds.field("encrypted_ulong", &self.encrypted_ulong());
      ds.field("encrypted_float", &self.encrypted_float());
      ds.field("encrypted_double", &self.encrypted_double());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `SensorReading`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sensor_reading_unchecked`.
pub fn root_as_sensor_reading(buf: &[u8]) -> Result<SensorReading<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root::<SensorReading>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `SensorReading` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_sensor_reading_unchecked`.
pub fn size_prefixed_root_as_sensor_reading(buf: &[u8]) -> Result<SensorReading<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root::<SensorReading>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `SensorReading` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sensor_reading_unchecked`.
pub fn root_as_sensor_reading_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SensorReading<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root_with_opts::<SensorReading<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `SensorReading` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_sensor_reading_unchecked`.
pub fn size_prefixed_root_as_sensor_reading_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<SensorReading<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root_with_opts::<SensorReading<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a SensorReading and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `SensorReading`.
pub unsafe fn root_as_sensor_reading_unchecked(buf: &[u8]) -> SensorReading<'_> {
  unsafe { ::flatbuffers::root_unchecked::<SensorReading>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed SensorReading and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `SensorReading`.
pub unsafe fn size_prefixed_root_as_sensor_reading_unchecked(buf: &[u8]) -> SensorReading<'_> {
  unsafe { ::flatbuffers::size_prefixed_root_unchecked::<SensorReading>(buf) }
}
#[inline]
pub fn finish_sensor_reading_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
    fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
    root: ::flatbuffers::WIPOffset<SensorReading<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_sensor_reading_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>, root: ::flatbuffers::WIPOffset<SensorReading<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod EncryptionTest

