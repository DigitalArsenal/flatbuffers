<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Browser - DA FlatBuffers</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --black: #000000;
      --white: #F5F5F7;
      --white-90: rgba(255, 255, 255, 0.9);
      --white-80: rgba(255, 255, 255, 0.8);
      --white-60: rgba(255, 255, 255, 0.6);
      --white-40: rgba(255, 255, 255, 0.4);
      --white-20: rgba(255, 255, 255, 0.2);
      --white-10: rgba(255, 255, 255, 0.1);
      --white-05: rgba(255, 255, 255, 0.05);
      --muted: rgba(134, 134, 139, 1.0);
      --glass-bg: rgba(42, 42, 45, 0.72);
      --glass-hover: rgba(66, 66, 69, 0.72);
      --glass-border: rgba(255, 255, 255, 0.1);
      --glass-blur: blur(20px);
      --radius: 28px;
      --radius-sm: 14px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--black);
      color: var(--white);
      line-height: 1.6;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Video Background */
    .video-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      overflow: hidden;
    }

    .video-background video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.3;
    }

    .video-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        to bottom,
        rgba(0, 0, 0, 0.4) 0%,
        rgba(0, 0, 0, 0.6) 50%,
        rgba(0, 0, 0, 0.85) 100%
      );
    }

    .page-container {
      position: relative;
      z-index: 1;
      max-width: 900px;
      margin: 0 auto;
      padding: 60px 24px 80px;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      margin-bottom: 40px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      color: var(--white);
      text-decoration: none;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .back-link:hover {
      background: var(--glass-hover);
      transform: translateY(-2px);
    }

    .markdown-body {
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      padding: 64px;
    }

    .markdown-body h1 {
      color: var(--white);
      font-size: 56px;
      font-weight: 600;
      line-height: 1.1;
      margin-bottom: 32px;
      letter-spacing: -0.02em;
    }

    .markdown-body h2 {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--white);
      font-size: 28px;
      font-weight: 600;
      line-height: 1.15;
      margin-top: 56px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--glass-border);
    }

    .markdown-body h2::before {
      content: '';
      display: inline-flex;
      width: 24px;
      height: 24px;
      background: var(--white);
      -webkit-mask-size: contain;
      mask-size: contain;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
      flex-shrink: 0;
    }

    /* Icon mappings for h2 headers based on content */
    .markdown-body h2[id*="why"]::before,
    .markdown-body h2:has(+ p:first-of-type)::before {
      -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
      mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
    }

    .markdown-body h3,
    .markdown-body h4 {
      color: var(--white);
      font-weight: 600;
      margin-top: 32px;
      margin-bottom: 16px;
    }

    .markdown-body h3 {
      font-size: 22px;
    }

    .markdown-body h4 {
      font-size: 18px;
      color: var(--white-90);
    }

    .markdown-body p {
      color: var(--white-80);
      font-size: 18px;
      line-height: 1.7;
      margin-bottom: 20px;
    }

    .markdown-body a {
      color: var(--white);
      text-decoration: underline;
      text-underline-offset: 3px;
      transition: opacity 0.2s;
    }

    .markdown-body a:hover {
      opacity: 0.7;
    }

    .markdown-body strong {
      color: var(--white);
      font-weight: 600;
    }

    .markdown-body code {
      background: var(--glass-hover);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      padding: 3px 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9em;
      color: var(--white);
    }

    .markdown-body pre {
      background: var(--black) !important;
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      padding: 24px;
      overflow-x: auto;
      margin: 24px 0;
    }

    .markdown-body pre code {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 14px;
      line-height: 1.7;
      color: var(--white-90);
    }

    .markdown-body ul, .markdown-body ol {
      padding-left: 24px;
      margin-bottom: 20px;
    }

    .markdown-body li {
      margin: 12px 0;
      color: var(--white-80);
      font-size: 18px;
    }

    .markdown-body li strong {
      color: var(--white);
    }

    .markdown-body table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      border-radius: var(--radius-sm);
      overflow: hidden;
    }

    .markdown-body table th,
    .markdown-body table td {
      border: 1px solid var(--glass-border);
      padding: 14px 18px;
      text-align: left;
    }

    .markdown-body table th {
      background: var(--glass-hover);
      font-weight: 600;
      color: var(--white);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .markdown-body table td {
      background: var(--white-05);
      color: var(--white-80);
    }

    .markdown-body table tr:nth-child(even) td {
      background: var(--white-10);
    }

    .markdown-body blockquote {
      border-left: 4px solid var(--white-40);
      background: var(--white-05);
      padding: 20px 24px;
      margin: 24px 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    }

    .markdown-body blockquote p {
      margin: 0;
      color: var(--white-80);
    }

    .markdown-body hr {
      border: none;
      height: 1px;
      background: var(--glass-border);
      margin: 48px 0;
    }

    /* Section header icons */
    .section-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: var(--white-10);
      border-radius: 8px;
      margin-right: 12px;
      flex-shrink: 0;
    }

    .section-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--white);
      fill: none;
      stroke-width: 2;
    }

    @media (max-width: 768px) {
      .page-container {
        padding: 40px 16px 60px;
      }
      .markdown-body {
        padding: 32px 24px;
        border-radius: 20px;
      }
      .markdown-body h1 {
        font-size: 36px;
      }
      .markdown-body h2 {
        font-size: 24px;
      }
      .markdown-body p,
      .markdown-body li {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <!-- Video Background -->
  <div class="video-background">
    <video autoplay loop muted playsinline id="bg-video">
      <source src="" type="application/x-mpegURL">
    </video>
    <div class="video-overlay"></div>
  </div>

  <div class="page-container">
    <a href="../index.html" class="back-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
      Back to DA FlatBuffers
    </a>
    <article class="markdown-body"><h1>Browser Integration Guide</h1>
<p>Run the FlatBuffers encryption module directly in web browsers using the native WebAssembly API.</p>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg></span>Browser Support</h2>
<p>All modern browsers support WebAssembly:</p>
<table>
<thead>
<tr>
<th>Browser</th>
<th>Version</th>
<th>Engine</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>57+</td>
<td>V8</td>
</tr>
<tr>
<td>Firefox</td>
<td>52+</td>
<td>SpiderMonkey</td>
</tr>
<tr>
<td>Safari</td>
<td>11+</td>
<td>JavaScriptCore</td>
</tr>
<tr>
<td>Edge</td>
<td>79+</td>
<td>V8</td>
</tr>
</tbody></table>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></span>Installation</h2>
<h3>Option 1: npm + Bundler (Recommended)</h3>
<pre><code class="language-bash">npm install flatc-wasm
</code></pre>
<p>Works with Vite, Webpack, Rollup, Parcel, and other bundlers.</p>
<h3>Option 2: CDN</h3>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
  import { initEncryption, encryptBytes } from &#39;https://esm.sh/flatc-wasm/encryption&#39;;
&lt;/script&gt;
</code></pre>
<h3>Option 3: Direct WASM Loading</h3>
<pre><code class="language-html">&lt;script type=&quot;module&quot;&gt;
  const wasmResponse = await fetch(&#39;/flatc-encryption.wasm&#39;);
  const wasmBytes = await wasmResponse.arrayBuffer();
  const { instance } = await WebAssembly.instantiate(wasmBytes, imports);
&lt;/script&gt;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>Quick Start</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;FlatBuffers Encryption Demo&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script type=&quot;module&quot;&gt;
    import {
      initEncryption,
      encryptBytes,
      decryptBytes,
      x25519GenerateKeyPair,
      x25519SharedSecret,
      hkdf,
      KEY_SIZE,
      IV_SIZE
    } from &#39;https://esm.sh/flatc-wasm/encryption&#39;;

    // Initialize the WASM module
    await initEncryption();

    // Generate key pair
    const keypair = x25519GenerateKeyPair();
    console.log(&#39;Public key:&#39;, toHex(keypair.publicKey));

    // Encrypt some data
    const key = crypto.getRandomValues(new Uint8Array(KEY_SIZE));
    const iv = crypto.getRandomValues(new Uint8Array(IV_SIZE));
    const plaintext = new TextEncoder().encode(&#39;Hello from the browser!&#39;);

    const data = new Uint8Array(plaintext);
    encryptBytes(data, key, iv);
    console.log(&#39;Encrypted:&#39;, toHex(data));

    // Decrypt
    decryptBytes(data, key, iv);
    console.log(&#39;Decrypted:&#39;, new TextDecoder().decode(data));

    function toHex(bytes) {
      return Array.from(bytes).map(b =&gt; b.toString(16).padStart(2, &#39;0&#39;)).join(&#39;&#39;);
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Vite Configuration</h2>
<p>For Vite projects, the WASM file is handled automatically:</p>
<pre><code class="language-javascript">// vite.config.js
export default {
  optimizeDeps: {
    exclude: [&#39;flatc-wasm&#39;]
  }
};
</code></pre>
<pre><code class="language-javascript">// main.js
import { initEncryption, encryptBytes } from &#39;flatc-wasm/encryption&#39;;

await initEncryption();
// Use encryption functions...
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Webpack Configuration</h2>
<pre><code class="language-javascript">// webpack.config.js
module.exports = {
  experiments: {
    asyncWebAssembly: true
  }
};
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>API Reference</h2>
<p>The browser API is identical to Node.js:</p>
<h3>Initialization</h3>
<pre><code class="language-javascript">import { initEncryption } from &#39;flatc-wasm/encryption&#39;;

// Must call before using any other functions
await initEncryption();
</code></pre>
<h3>Symmetric Encryption</h3>
<pre><code class="language-javascript">import { encryptBytes, decryptBytes, KEY_SIZE, IV_SIZE } from &#39;flatc-wasm/encryption&#39;;

const key = crypto.getRandomValues(new Uint8Array(KEY_SIZE));  // 32 bytes
const iv = crypto.getRandomValues(new Uint8Array(IV_SIZE));    // 16 bytes

// Encrypt in-place
const data = new Uint8Array([1, 2, 3, 4, 5]);
encryptBytes(data, key, iv);

// Decrypt in-place
decryptBytes(data, key, iv);
</code></pre>
<h3>Key Exchange</h3>
<pre><code class="language-javascript">import {
  x25519GenerateKeyPair,
  x25519SharedSecret,
  hkdf
} from &#39;flatc-wasm/encryption&#39;;

// Generate key pair
const alice = x25519GenerateKeyPair();
const bob = x25519GenerateKeyPair();

// Compute shared secret
const sharedSecret = x25519SharedSecret(alice.privateKey, bob.publicKey);

// Derive encryption key
const encryptionKey = hkdf(
  sharedSecret,
  null,
  new TextEncoder().encode(&#39;my-app-v1&#39;),
  32
);
</code></pre>
<h3>Digital Signatures</h3>
<pre><code class="language-javascript">import {
  ed25519GenerateKeyPair,
  ed25519Sign,
  ed25519Verify
} from &#39;flatc-wasm/encryption&#39;;

const keypair = ed25519GenerateKeyPair();
const message = new TextEncoder().encode(&#39;Sign this&#39;);

const signature = ed25519Sign(keypair.privateKey, message);
const isValid = ed25519Verify(keypair.publicKey, message, signature);
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Complete Example: Secure Messaging App</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Secure Messenger&lt;/title&gt;
  &lt;style&gt;
    body { font-family: system-ui; max-width: 600px; margin: 50px auto; }
    textarea, input { width: 100%; margin: 10px 0; padding: 10px; }
    button { padding: 10px 20px; cursor: pointer; }
    .key { font-family: monospace; font-size: 12px; word-break: break-all; }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Secure Messenger&lt;/h1&gt;

  &lt;div id=&quot;setup&quot;&gt;
    &lt;h2&gt;Your Keys&lt;/h2&gt;
    &lt;p&gt;Public Key:&lt;/p&gt;
    &lt;div class=&quot;key&quot; id=&quot;myPublicKey&quot;&gt;&lt;/div&gt;
    &lt;p&gt;Share this with others so they can send you encrypted messages.&lt;/p&gt;
  &lt;/div&gt;

  &lt;div id=&quot;encrypt&quot;&gt;
    &lt;h2&gt;Send Encrypted Message&lt;/h2&gt;
    &lt;label&gt;Recipient&#39;s Public Key:&lt;/label&gt;
    &lt;input type=&quot;text&quot; id=&quot;recipientKey&quot; placeholder=&quot;Paste recipient&#39;s public key&quot;&gt;

    &lt;label&gt;Message:&lt;/label&gt;
    &lt;textarea id=&quot;plaintext&quot; rows=&quot;4&quot; placeholder=&quot;Enter your message&quot;&gt;&lt;/textarea&gt;

    &lt;button onclick=&quot;encryptMessage()&quot;&gt;Encrypt&lt;/button&gt;

    &lt;label&gt;Encrypted Package (send this):&lt;/label&gt;
    &lt;textarea id=&quot;encrypted&quot; rows=&quot;4&quot; readonly&gt;&lt;/textarea&gt;
  &lt;/div&gt;

  &lt;div id=&quot;decrypt&quot;&gt;
    &lt;h2&gt;Receive Encrypted Message&lt;/h2&gt;
    &lt;label&gt;Paste encrypted package:&lt;/label&gt;
    &lt;textarea id=&quot;received&quot; rows=&quot;4&quot; placeholder=&quot;Paste encrypted message&quot;&gt;&lt;/textarea&gt;

    &lt;button onclick=&quot;decryptMessage()&quot;&gt;Decrypt&lt;/button&gt;

    &lt;label&gt;Decrypted Message:&lt;/label&gt;
    &lt;textarea id=&quot;decrypted&quot; rows=&quot;4&quot; readonly&gt;&lt;/textarea&gt;
  &lt;/div&gt;

  &lt;script type=&quot;module&quot;&gt;
    import {
      initEncryption,
      encryptBytes,
      decryptBytes,
      x25519GenerateKeyPair,
      x25519SharedSecret,
      hkdf,
      KEY_SIZE,
      IV_SIZE
    } from &#39;https://esm.sh/flatc-wasm/encryption&#39;;

    // Store keypair globally
    let myKeypair;

    // Initialize
    async function init() {
      await initEncryption();

      // Generate our keypair
      myKeypair = x25519GenerateKeyPair();
      document.getElementById(&#39;myPublicKey&#39;).textContent = toHex(myKeypair.publicKey);

      // Store private key in sessionStorage (demo only - use better storage in production!)
      sessionStorage.setItem(&#39;privateKey&#39;, toHex(myKeypair.privateKey));
    }

    init();

    // Make functions available to onclick handlers
    window.encryptMessage = async function() {
      const recipientKeyHex = document.getElementById(&#39;recipientKey&#39;).value.trim();
      const plaintext = document.getElementById(&#39;plaintext&#39;).value;

      if (!recipientKeyHex || !plaintext) {
        alert(&#39;Please enter recipient key and message&#39;);
        return;
      }

      try {
        const recipientKey = fromHex(recipientKeyHex);

        // Compute shared secret
        const sharedSecret = x25519SharedSecret(myKeypair.privateKey, recipientKey);

        // Derive encryption key
        const encryptionKey = hkdf(
          sharedSecret,
          null,
          new TextEncoder().encode(&#39;secure-messenger-v1&#39;),
          KEY_SIZE
        );

        // Generate IV
        const iv = crypto.getRandomValues(new Uint8Array(IV_SIZE));

        // Encrypt
        const data = new TextEncoder().encode(plaintext);
        const buffer = new Uint8Array(data);
        encryptBytes(buffer, encryptionKey, iv);

        // Package: sender public key + IV + ciphertext
        const package = {
          sender: toHex(myKeypair.publicKey),
          iv: toHex(iv),
          ciphertext: toHex(buffer)
        };

        document.getElementById(&#39;encrypted&#39;).value = JSON.stringify(package);
      } catch (e) {
        alert(&#39;Encryption failed: &#39; + e.message);
      }
    };

    window.decryptMessage = async function() {
      const receivedJson = document.getElementById(&#39;received&#39;).value.trim();

      if (!receivedJson) {
        alert(&#39;Please paste encrypted message&#39;);
        return;
      }

      try {
        const package = JSON.parse(receivedJson);
        const senderKey = fromHex(package.sender);
        const iv = fromHex(package.iv);
        const ciphertext = fromHex(package.ciphertext);

        // Get our private key
        const privateKeyHex = sessionStorage.getItem(&#39;privateKey&#39;);
        const privateKey = fromHex(privateKeyHex);

        // Compute shared secret
        const sharedSecret = x25519SharedSecret(privateKey, senderKey);

        // Derive decryption key
        const decryptionKey = hkdf(
          sharedSecret,
          null,
          new TextEncoder().encode(&#39;secure-messenger-v1&#39;),
          KEY_SIZE
        );

        // Decrypt
        const buffer = new Uint8Array(ciphertext);
        decryptBytes(buffer, decryptionKey, iv);

        const plaintext = new TextDecoder().decode(buffer);
        document.getElementById(&#39;decrypted&#39;).value = plaintext;
      } catch (e) {
        alert(&#39;Decryption failed: &#39; + e.message);
      }
    };

    function toHex(bytes) {
      return Array.from(bytes).map(b =&gt; b.toString(16).padStart(2, &#39;0&#39;)).join(&#39;&#39;);
    }

    function fromHex(hex) {
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i &lt; bytes.length; i++) {
        bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
      }
      return bytes;
    }
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Web Workers</h2>
<p>For heavy encryption workloads, use Web Workers to avoid blocking the main thread:</p>
<p><strong>worker.js:</strong></p>
<pre><code class="language-javascript">import { initEncryption, encryptBytes } from &#39;flatc-wasm/encryption&#39;;

let initialized = false;

self.onmessage = async (e) =&gt; {
  if (!initialized) {
    await initEncryption();
    initialized = true;
  }

  const { data, key, iv } = e.data;
  const buffer = new Uint8Array(data);
  encryptBytes(buffer, new Uint8Array(key), new Uint8Array(iv));

  self.postMessage({ encrypted: buffer }, [buffer.buffer]);
};
</code></pre>
<p><strong>main.js:</strong></p>
<pre><code class="language-javascript">const worker = new Worker(&#39;worker.js&#39;, { type: &#39;module&#39; });

worker.onmessage = (e) =&gt; {
  console.log(&#39;Encrypted:&#39;, e.data.encrypted);
};

worker.postMessage({
  data: plaintext,
  key: key,
  iv: iv
}, [plaintext.buffer]);  // Transfer ownership for zero-copy
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Streaming Large Files</h2>
<p>For large files, process in chunks to avoid memory issues:</p>
<pre><code class="language-javascript">async function encryptFile(file, key) {
  const CHUNK_SIZE = 64 * 1024;  // 64KB
  const iv = crypto.getRandomValues(new Uint8Array(16));
  const chunks = [];

  chunks.push(iv);  // First chunk is the IV

  const reader = file.stream().getReader();
  let counter = 0;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    // Create IV for this chunk (increment counter)
    const chunkIv = new Uint8Array(iv);
    const view = new DataView(chunkIv.buffer);
    view.setBigUint64(8, BigInt(counter), false);

    // Encrypt chunk
    const encrypted = new Uint8Array(value);
    encryptBytes(encrypted, key, chunkIv);
    chunks.push(encrypted);

    counter++;
  }

  return new Blob(chunks);
}
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg></span>Security Considerations</h2>
<h3>1. Use crypto.getRandomValues()</h3>
<pre><code class="language-javascript">// Good: Cryptographically secure
const key = crypto.getRandomValues(new Uint8Array(32));

// Bad: Predictable!
const badKey = new Uint8Array(32);
for (let i = 0; i &lt; 32; i++) {
  badKey[i] = Math.floor(Math.random() * 256);
}
</code></pre>
<h3>2. Clear Sensitive Data</h3>
<pre><code class="language-javascript">function clearKey(key) {
  key.fill(0);
}

// Use key...
encryptBytes(data, key, iv);

// Then clear it
clearKey(key);
</code></pre>
<h3>3. Use HTTPS</h3>
<p>Always serve your app over HTTPS. WebAssembly may be restricted on HTTP.</p>
<h3>4. Consider SubtleCrypto for Some Operations</h3>
<p>For operations that don&#39;t require cross-language compatibility, consider using the native Web Crypto API:</p>
<pre><code class="language-javascript">// Native Web Crypto (fast, but different format)
const key = await crypto.subtle.generateKey(
  { name: &#39;AES-GCM&#39;, length: 256 },
  true,
  [&#39;encrypt&#39;, &#39;decrypt&#39;]
);

// FlatBuffers WASM (cross-language compatible)
const fbKey = x25519GenerateKeyPair();
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>Performance Tips</h2>
<h3>1. Initialize Once</h3>
<pre><code class="language-javascript">// At app startup
let encryptionReady = initEncryption();

// In your encryption function
async function encrypt(data, key, iv) {
  await encryptionReady;  // Wait if not ready
  // ...
}
</code></pre>
<h3>2. Use Transferable Objects</h3>
<pre><code class="language-javascript">// Transfer buffer ownership (zero-copy)
worker.postMessage({ data: buffer }, [buffer.buffer]);
</code></pre>
<h3>3. Batch Operations</h3>
<pre><code class="language-javascript">// Good: Single WASM call for batch
const results = items.map(item =&gt; {
  const buf = new Uint8Array(item);
  encryptBytes(buf, key, iv);
  return buf;
});
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg></span>Troubleshooting</h2>
<h3>"CompileError: WebAssembly.instantiate"</h3>
<p>The WASM file may be corrupted or incompatible. Ensure you&#39;re using the correct version.</p>
<h3>"ReferenceError: crypto is not defined"</h3>
<p>Use <code>window.crypto</code> or ensure you&#39;re in a secure context (HTTPS).</p>
<h3>"Out of memory"</h3>
<p>Processing very large files? Use streaming or Web Workers.</p>
<h3>CORS Errors</h3>
<p>When loading WASM from a different origin, ensure CORS headers are set:</p>
<pre><code>Access-Control-Allow-Origin: *
Content-Type: application/wasm
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg></span>See Also</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API">Web Crypto API</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/WebAssembly">WebAssembly on MDN</a></li>
<li><a href="nodejs.html">Node.js Integration</a> - Same API for server-side</li>
<li><a href="README.html#api-reference">API Reference</a></li>
</ul>
</article>
  </div>

  <script>
    // Initialize HLS video with random selection
    const videoUrls = [
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/90bb1b34646b81b3b63e5a854ea00da3/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/df176a2fb2ea2b64bd21ae1c10d3af6a/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/12a9780eeb1ea015801a5f55cf2e9d3d/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/964cb3eddff1a67e3772aac9a7aceea2/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/dd17599dfa77f41517133fa7a4967535/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/408ad52e3f15bc8f01ae69d194a8cf3a/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/e923e67d71fed3e0853ec57f0348451e/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/136a8a211c6c3b1cc1fd7b1c7d836c58/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/c9ddd33ac3d964e5d33b31ce849e8f95/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/257c7359efd4b4aaebcc03aa8fc78a36/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/697945ca6b876878dba3b23fbd2f1561/manifest/video.m3u8"
    ];

    const video = document.getElementById('bg-video');
    const randomUrl = videoUrls[Math.floor(Math.random() * videoUrls.length)];

    if (Hls.isSupported()) {
      const hls = new Hls();
      hls.loadSource(randomUrl);
      hls.attachMedia(video);
    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
      video.src = randomUrl;
    }
  </script>
</body>
</html>
