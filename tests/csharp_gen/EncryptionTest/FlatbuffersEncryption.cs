// automatically generated by the FlatBuffers compiler, do not modify

namespace EncryptionTest
{

using System;
using System.Security.Cryptography;
using System.Text;

/// <summary>
/// FlatBuffers field-level encryption support using AES-256-CTR.
/// </summary>
public static class FlatbuffersEncryption
{
  private static byte[] DeriveNonce(byte[] ctx, int fieldOffset)
  {
    if (ctx == null || ctx.Length < 12)
      throw new ArgumentException("Encryption context must be at least 12 bytes");
    var nonce = new byte[16];
    Array.Copy(ctx, 0, nonce, 0, 12);
    nonce[12] = (byte)(fieldOffset & 0xFF);
    nonce[13] = (byte)((fieldOffset >> 8) & 0xFF);
    nonce[14] = (byte)((fieldOffset >> 16) & 0xFF);
    nonce[15] = (byte)((fieldOffset >> 24) & 0xFF);
    return nonce;
  }

  private static byte[] DecryptBytes(byte[] data, byte[] ctx, int fieldOffset)
  {
    if (ctx == null || ctx.Length < 32)
      throw new ArgumentException("Encryption context must be at least 32 bytes");
    var key = new byte[32];
    Array.Copy(ctx, 0, key, 0, 32);
    var nonce = DeriveNonce(ctx, fieldOffset);
    using (var aes = Aes.Create())
    {
      aes.Key = key;
      aes.Mode = CipherMode.ECB;
      aes.Padding = PaddingMode.None;
      var result = new byte[data.Length];
      var counter = (byte[])nonce.Clone();
      var encryptor = aes.CreateEncryptor();
      for (int i = 0; i < data.Length; i += 16)
      {
        var keystream = new byte[16];
        encryptor.TransformBlock(counter, 0, 16, keystream, 0);
        int blockLen = Math.Min(16, data.Length - i);
        for (int j = 0; j < blockLen; j++)
          result[i + j] = (byte)(data[i + j] ^ keystream[j]);
        // Increment counter
        for (int k = 15; k >= 0; k--)
          if (++counter[k] != 0) break;
      }
      return result;
    }
  }

  public static bool DecryptScalar(bool value, byte[] ctx, int fieldOffset)
  {
    if (ctx == null) return value;
    var data = new byte[] { (byte)(value ? 1 : 0) };
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return decrypted[0] != 0;
  }

  public static sbyte DecryptScalar(sbyte value, byte[] ctx, int fieldOffset)
  {
    if (ctx == null) return value;
    var data = new byte[] { (byte)value };
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return (sbyte)decrypted[0];
  }

  public static byte DecryptScalar(byte value, byte[] ctx, int fieldOffset)
  {
    if (ctx == null) return value;
    var data = new byte[] { value };
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return decrypted[0];
  }

  public static short DecryptScalar(short value, byte[] ctx, int fieldOffset)
  {
    if (ctx == null) return value;
    var data = BitConverter.GetBytes(value);
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return BitConverter.ToInt16(decrypted, 0);
  }

  public static ushort DecryptScalar(ushort value, byte[] ctx, int fieldOffset)
  {
    if (ctx == null) return value;
    var data = BitConverter.GetBytes(value);
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return BitConverter.ToUInt16(decrypted, 0);
  }

  public static int DecryptScalar(int value, byte[] ctx, int fieldOffset)
  {
    if (ctx == null) return value;
    var data = BitConverter.GetBytes(value);
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return BitConverter.ToInt32(decrypted, 0);
  }

  public static uint DecryptScalar(uint value, byte[] ctx, int fieldOffset)
  {
    if (ctx == null) return value;
    var data = BitConverter.GetBytes(value);
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return BitConverter.ToUInt32(decrypted, 0);
  }

  public static long DecryptScalar(long value, byte[] ctx, int fieldOffset)
  {
    if (ctx == null) return value;
    var data = BitConverter.GetBytes(value);
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return BitConverter.ToInt64(decrypted, 0);
  }

  public static ulong DecryptScalar(ulong value, byte[] ctx, int fieldOffset)
  {
    if (ctx == null) return value;
    var data = BitConverter.GetBytes(value);
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return BitConverter.ToUInt64(decrypted, 0);
  }

  public static float DecryptScalar(float value, byte[] ctx, int fieldOffset)
  {
    if (ctx == null) return value;
    var data = BitConverter.GetBytes(value);
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return BitConverter.ToSingle(decrypted, 0);
  }

  public static double DecryptScalar(double value, byte[] ctx, int fieldOffset)
  {
    if (ctx == null) return value;
    var data = BitConverter.GetBytes(value);
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return BitConverter.ToDouble(decrypted, 0);
  }

  public static string DecryptString(Google.FlatBuffers.ByteBuffer bb, int offset, byte[] ctx, int fieldOffset)
  {
    int pos = offset + bb.GetInt(offset);
    int len = bb.GetInt(pos);
    var data = new byte[len];
    for (int i = 0; i < len; i++)
      data[i] = bb.Get(pos + 4 + i);
    if (ctx == null)
      return Encoding.UTF8.GetString(data);
    var decrypted = DecryptBytes(data, ctx, fieldOffset);
    return Encoding.UTF8.GetString(decrypted);
  }
}

}
