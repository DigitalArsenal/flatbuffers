// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

#if canImport(Common)
import Common
#endif

import FlatBuffers

///  Supported elliptic curves for key exchange
public enum E2E_Crypto_Curve: Int8, FlatbuffersVectorInitializable, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case x25519 = 0
  case secp256k1 = 1
  case p256 = 2

  public static var max: E2E_Crypto_Curve { return .p256 }
  public static var min: E2E_Crypto_Curve { return .x25519 }
}


///  Key exchange algorithm
public enum E2E_Crypto_KeyExchangeAlgorithm: Int8, FlatbuffersVectorInitializable, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case ecdh = 0

  public static var max: E2E_Crypto_KeyExchangeAlgorithm { return .ecdh }
  public static var min: E2E_Crypto_KeyExchangeAlgorithm { return .ecdh }
}


///  Symmetric encryption algorithm
public enum E2E_Crypto_EncryptionAlgorithm: Int8, FlatbuffersVectorInitializable, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case aes256Ctr = 0

  public static var max: E2E_Crypto_EncryptionAlgorithm { return .aes256Ctr }
  public static var min: E2E_Crypto_EncryptionAlgorithm { return .aes256Ctr }
}


///  Public key for key exchange (as a table to support all languages)
public struct E2E_Crypto_PublicKey: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "SECM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: E2E_Crypto_PublicKey.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case data = 4
    case length = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Key bytes (32 or 33 bytes depending on curve)
  public var data: FlatbufferVector<UInt8> { return _accessor.vector(at: VTOFFSET.data.v, byteSize: 1) }
  public func withUnsafePointerToData<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.data.v, body: body) }
  ///  Length of valid key data (32 for X25519/P-256, 33 for secp256k1 compressed)
  public var length: UInt8 { let o = _accessor.offset(VTOFFSET.length.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public static func startPublicKey(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func addVectorOf(data: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: data, at: VTOFFSET.data.p) }
  public static func add(length: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: length, def: 0, at: VTOFFSET.length.p) }
  public static func endPublicKey(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPublicKey(
    _ fbb: inout FlatBufferBuilder,
    dataVectorOffset data: Offset = Offset(),
    length: UInt8 = 0
  ) -> Offset {
    let __start = E2E_Crypto_PublicKey.startPublicKey(&fbb)
    E2E_Crypto_PublicKey.addVectorOf(data: data, &fbb)
    E2E_Crypto_PublicKey.add(length: length, &fbb)
    return E2E_Crypto_PublicKey.endPublicKey(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.data.p, fieldName: "data", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.length.p, fieldName: "length", required: false, type: UInt8.self)
    _v.finish()
  }
}

///  Encryption header - sent out-of-band with encrypted message
public struct E2E_Crypto_EncryptionHeader: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "SECM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: E2E_Crypto_EncryptionHeader.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case version = 4
    case keyExchange = 6
    case curve = 8
    case encryption = 10
    case ephemeralPublicKey = 12
    case senderId = 14
    case timestamp = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Protocol version
  public var version: UInt16 { let o = _accessor.offset(VTOFFSET.version.v); return o == 0 ? 1 : _accessor.readBuffer(of: UInt16.self, at: o) }
  ///  Key exchange algorithm
  public var keyExchange: E2E_Crypto_KeyExchangeAlgorithm { let o = _accessor.offset(VTOFFSET.keyExchange.v); return o == 0 ? .ecdh : E2E_Crypto_KeyExchangeAlgorithm(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .ecdh }
  ///  Elliptic curve used
  public var curve: E2E_Crypto_Curve { let o = _accessor.offset(VTOFFSET.curve.v); return o == 0 ? .x25519 : E2E_Crypto_Curve(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .x25519 }
  ///  Encryption algorithm
  public var encryption: E2E_Crypto_EncryptionAlgorithm { let o = _accessor.offset(VTOFFSET.encryption.v); return o == 0 ? .aes256Ctr : E2E_Crypto_EncryptionAlgorithm(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .aes256Ctr }
  ///  Ephemeral public key from sender (for ECDH)
  public var ephemeralPublicKey: E2E_Crypto_PublicKey? { let o = _accessor.offset(VTOFFSET.ephemeralPublicKey.v); return o == 0 ? nil : E2E_Crypto_PublicKey(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  ///  Sender identifier (optional)
  public var senderId: String? { let o = _accessor.offset(VTOFFSET.senderId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var senderIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.senderId.v) }
  ///  Timestamp (Unix epoch seconds)
  public var timestamp: UInt64 { let o = _accessor.offset(VTOFFSET.timestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public static func startEncryptionHeader(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(version: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: version, def: 1, at: VTOFFSET.version.p) }
  public static func add(keyExchange: E2E_Crypto_KeyExchangeAlgorithm, _ fbb: inout FlatBufferBuilder) { fbb.add(element: keyExchange.rawValue, def: 0, at: VTOFFSET.keyExchange.p) }
  public static func add(curve: E2E_Crypto_Curve, _ fbb: inout FlatBufferBuilder) { fbb.add(element: curve.rawValue, def: 0, at: VTOFFSET.curve.p) }
  public static func add(encryption: E2E_Crypto_EncryptionAlgorithm, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryption.rawValue, def: 0, at: VTOFFSET.encryption.p) }
  public static func add(ephemeralPublicKey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ephemeralPublicKey, at: VTOFFSET.ephemeralPublicKey.p) }
  public static func add(senderId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: senderId, at: VTOFFSET.senderId.p) }
  public static func add(timestamp: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timestamp, def: 0, at: VTOFFSET.timestamp.p) }
  public static func endEncryptionHeader(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEncryptionHeader(
    _ fbb: inout FlatBufferBuilder,
    version: UInt16 = 1,
    keyExchange: E2E_Crypto_KeyExchangeAlgorithm = .ecdh,
    curve: E2E_Crypto_Curve = .x25519,
    encryption: E2E_Crypto_EncryptionAlgorithm = .aes256Ctr,
    ephemeralPublicKeyOffset ephemeralPublicKey: Offset = Offset(),
    senderIdOffset senderId: Offset = Offset(),
    timestamp: UInt64 = 0
  ) -> Offset {
    let __start = E2E_Crypto_EncryptionHeader.startEncryptionHeader(&fbb)
    E2E_Crypto_EncryptionHeader.add(version: version, &fbb)
    E2E_Crypto_EncryptionHeader.add(keyExchange: keyExchange, &fbb)
    E2E_Crypto_EncryptionHeader.add(curve: curve, &fbb)
    E2E_Crypto_EncryptionHeader.add(encryption: encryption, &fbb)
    E2E_Crypto_EncryptionHeader.add(ephemeralPublicKey: ephemeralPublicKey, &fbb)
    E2E_Crypto_EncryptionHeader.add(senderId: senderId, &fbb)
    E2E_Crypto_EncryptionHeader.add(timestamp: timestamp, &fbb)
    return E2E_Crypto_EncryptionHeader.endEncryptionHeader(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.version.p, fieldName: "version", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.keyExchange.p, fieldName: "keyExchange", required: false, type: E2E_Crypto_KeyExchangeAlgorithm.self)
    try _v.visit(field: VTOFFSET.curve.p, fieldName: "curve", required: false, type: E2E_Crypto_Curve.self)
    try _v.visit(field: VTOFFSET.encryption.p, fieldName: "encryption", required: false, type: E2E_Crypto_EncryptionAlgorithm.self)
    try _v.visit(field: VTOFFSET.ephemeralPublicKey.p, fieldName: "ephemeralPublicKey", required: false, type: ForwardOffset<E2E_Crypto_PublicKey>.self)
    try _v.visit(field: VTOFFSET.senderId.p, fieldName: "senderId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.timestamp.p, fieldName: "timestamp", required: false, type: UInt64.self)
    _v.finish()
  }
}

///  A simple payload for testing
public struct E2E_Crypto_Payload: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "SECM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: E2E_Crypto_Payload.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case message = 4
    case value = 6
    case data = 8
    case nested = 10
    case isEncrypted = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Message content
  public var message: String? { let o = _accessor.offset(VTOFFSET.message.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var messageSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.message.v) }
  ///  Numeric value
  public var value: Int32 { let o = _accessor.offset(VTOFFSET.value.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  ///  Binary data
  public var data: FlatbufferVector<UInt8> { return _accessor.vector(at: VTOFFSET.data.v, byteSize: 1) }
  public func withUnsafePointerToData<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.data.v, body: body) }
  ///  Nested messages
  public var nested: FlatbufferVector<E2E_Crypto_Payload> { return _accessor.vector(at: VTOFFSET.nested.v, byteSize: 4) }
  ///  Boolean flag
  public var isEncrypted: Bool { let o = _accessor.offset(VTOFFSET.isEncrypted.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startPayload(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(message: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: message, at: VTOFFSET.message.p) }
  public static func add(value: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: value, def: 0, at: VTOFFSET.value.p) }
  public static func addVectorOf(data: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: data, at: VTOFFSET.data.p) }
  public static func addVectorOf(nested: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: nested, at: VTOFFSET.nested.p) }
  public static func add(isEncrypted: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: isEncrypted, def: false,
   at: VTOFFSET.isEncrypted.p) }
  public static func endPayload(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPayload(
    _ fbb: inout FlatBufferBuilder,
    messageOffset message: Offset = Offset(),
    value: Int32 = 0,
    dataVectorOffset data: Offset = Offset(),
    nestedVectorOffset nested: Offset = Offset(),
    isEncrypted: Bool = false
  ) -> Offset {
    let __start = E2E_Crypto_Payload.startPayload(&fbb)
    E2E_Crypto_Payload.add(message: message, &fbb)
    E2E_Crypto_Payload.add(value: value, &fbb)
    E2E_Crypto_Payload.addVectorOf(data: data, &fbb)
    E2E_Crypto_Payload.addVectorOf(nested: nested, &fbb)
    E2E_Crypto_Payload.add(isEncrypted: isEncrypted, &fbb)
    return E2E_Crypto_Payload.endPayload(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.message.p, fieldName: "message", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.value.p, fieldName: "value", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.data.p, fieldName: "data", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.nested.p, fieldName: "nested", required: false, type: ForwardOffset<Vector<ForwardOffset<E2E_Crypto_Payload>, E2E_Crypto_Payload>>.self)
    try _v.visit(field: VTOFFSET.isEncrypted.p, fieldName: "isEncrypted", required: false, type: Bool.self)
    _v.finish()
  }
}

///  Wrapper for encrypted/unencrypted messages
public struct E2E_Crypto_SecureMessage: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static var id: String { "SECM" } 
  public static func finish(_ fbb: inout FlatBufferBuilder, end: Offset, prefix: Bool = false) { fbb.finish(offset: end, fileId: E2E_Crypto_SecureMessage.id, addPrefix: prefix) }
  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case sender = 6
    case recipient = 8
    case payload = 10
    case timestamp = 12
    case signature = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  ///  Unique message identifier
  public var id: String? { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.id.v) }
  ///  Sender identifier
  public var sender: String? { let o = _accessor.offset(VTOFFSET.sender.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var senderSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.sender.v) }
  ///  Recipient identifier
  public var recipient: String? { let o = _accessor.offset(VTOFFSET.recipient.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var recipientSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.recipient.v) }
  ///  Message payload (can be encrypted)
  public var payload: E2E_Crypto_Payload? { let o = _accessor.offset(VTOFFSET.payload.v); return o == 0 ? nil : E2E_Crypto_Payload(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  ///  Timestamp
  public var timestamp: UInt64 { let o = _accessor.offset(VTOFFSET.timestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  ///  Signature (optional, for signed messages)
  public var signature: FlatbufferVector<UInt8> { return _accessor.vector(at: VTOFFSET.signature.v, byteSize: 1) }
  public func withUnsafePointerToSignature<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.signature.v, body: body) }
  public static func startSecureMessage(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func add(sender: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sender, at: VTOFFSET.sender.p) }
  public static func add(recipient: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: recipient, at: VTOFFSET.recipient.p) }
  public static func add(payload: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: payload, at: VTOFFSET.payload.p) }
  public static func add(timestamp: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timestamp, def: 0, at: VTOFFSET.timestamp.p) }
  public static func addVectorOf(signature: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: signature, at: VTOFFSET.signature.p) }
  public static func endSecureMessage(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSecureMessage(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    senderOffset sender: Offset = Offset(),
    recipientOffset recipient: Offset = Offset(),
    payloadOffset payload: Offset = Offset(),
    timestamp: UInt64 = 0,
    signatureVectorOffset signature: Offset = Offset()
  ) -> Offset {
    let __start = E2E_Crypto_SecureMessage.startSecureMessage(&fbb)
    E2E_Crypto_SecureMessage.add(id: id, &fbb)
    E2E_Crypto_SecureMessage.add(sender: sender, &fbb)
    E2E_Crypto_SecureMessage.add(recipient: recipient, &fbb)
    E2E_Crypto_SecureMessage.add(payload: payload, &fbb)
    E2E_Crypto_SecureMessage.add(timestamp: timestamp, &fbb)
    E2E_Crypto_SecureMessage.addVectorOf(signature: signature, &fbb)
    return E2E_Crypto_SecureMessage.endSecureMessage(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.sender.p, fieldName: "sender", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.recipient.p, fieldName: "recipient", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.payload.p, fieldName: "payload", required: false, type: ForwardOffset<E2E_Crypto_Payload>.self)
    try _v.visit(field: VTOFFSET.timestamp.p, fieldName: "timestamp", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.signature.p, fieldName: "signature", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    _v.finish()
  }
}

