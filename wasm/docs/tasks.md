# DA FlatBuffers Website — Required Changes

## 1. Fix Critical Bugs

### 1.1 CSS Bug in docs-html (BLOCKING)
- **File**: `docs-html/README.html` (and likely all docs-html/*.html)
- **Error**: Unclosed CSS blocks starting around line 282 — `.section-icon svg` missing closing `}`, entire `@media` block missing closing braces
- **Impact**: Vite dev server throws `postcss Unclosed block` error, docs pages won't load
- **Fix**: Regenerate docs-html by running `node scripts/build-markdown.mjs` — OR if the template itself (`scripts/build-markdown.mjs`) is the source of bad CSS, fix the template first
- **Note**: The current docs-html/README.html appears to have been generated by a *different* template than what's in build-markdown.mjs (contains `.section-icon`, video background, etc. that aren't in the build script template). The build script needs to be re-run to overwrite with the correct template.

### 1.2 Aligned Binary Code Generator Error
- **File**: `wasm/src/aligned-codegen.mjs:175`
- **Error**: `Schema parsing failed: Schema has no root type defined`
- **Cause**: The schema passed to `generateAlignedCode()` doesn't include a `root_type` declaration
- **Fix**: Ensure the example schema in the Aligned tab includes `root_type Entity;` (or whatever the table name is)
- **UI Enhancement**: Add an error box/toast in the Aligned tab UI so the user sees schema parsing errors inline instead of only in the console

---

## 2. Embedded Language Runtimes — Replace External Downloads

### 2.1 Remove External Repo Downloads
- **Current behavior**: The Runtimes tab shows install commands pointing to npm/pip/cargo/maven/nuget — users download FlatBuffers runtime libraries from published package registries
- **New behavior**: flatc-wasm already has all 11 language runtimes **embedded in the WASM binary** (Brotli-compressed). The website should generate .zip downloads directly from the WASM module using `flatc.getEmbeddedRuntimeZip(language)` — no external package installation needed

### 2.2 Include flatc-wasm on the Website
- The website should include `flatc-wasm` as a dependency (it already imports `FlatcRunner` from `../src/runner.mjs`)
- Use `FlatcRunner.init()` on page load to have the WASM module ready
- When a user clicks "Download" on a runtime card, call `flatc.getEmbeddedRuntimeZip(language)` and trigger a browser download of the resulting ZIP

### 2.3 Update Runtimes Tab UI
- Each language card should show:
  - Language name, icon, and runtime engine
  - **"Download Runtime (.zip)"** button that generates the ZIP in-browser via WASM
  - File count, raw size, and compressed size (from `_wasm_get_embedded_runtime_info`)
  - Link to the language-specific integration guide (docs page)
- Remove or de-emphasize external package manager install commands
- Add a note explaining: *"Runtime files are embedded in the flatc-wasm binary. Downloads are generated locally — no network request needed."*

### 2.4 Document the Change
- Each language guide page (go.md, python.md, rust.md, java.md, csharp.md, swift.md, nodejs.md, browser.md) needs a section explaining:
  - Runtimes are embedded in flatc-wasm and retrieved via `getEmbeddedRuntime()` / `getEmbeddedRuntimeZip()`
  - No need to install FlatBuffers runtime from pip/npm/cargo/etc.
  - How to extract and use the downloaded files

---

## 3. Streaming Code Examples — Tabs, Producer/Consumer, Encryption

### 3.1 Tab-Based Layout Per Language
- **Current**: Streaming examples are sequential code blocks, one after another
- **New**: Use tab UI (like the Schema/Studio tabs) to show examples per language:
  - JavaScript/TypeScript
  - Go
  - Python
  - Rust
  - Java
  - C#
  - Swift

### 3.2 Producer / Consumer Sections
Each language tab must show **both sides** of the streaming flow:

**Producer (Sender)**:
- Create a FlatBuffer message (with schema)
- Mark fields as `(encrypted)`
- Create an `EncryptionContext` with the receiver's public key
- Encrypt the message with `encryptBuffer()` or `generateBinaryEncrypted()`
- Send the encryption header (with `nonce_start`) alongside or before the data
- Push size-prefixed messages into the stream

**Consumer (Receiver)**:
- Receive the encryption header
- Create an `EncryptionContext.forDecryption()` with their private key + the header
- Set the `recordIndex` for each message
- Decrypt and parse each message
- If decryption fails (wrong nonce / unknown record index), use **brute force fallback**: try sequential indices until decryption succeeds (validate via FlatBuffer structure check)

### 3.3 Visual Data Flow Arrow
- Between the Producer and Consumer code panels, show a visual arrow/diagram:
  ```
  Producer ──────────────────→ Consumer
           [EncryptionHeader]
           [Message 0 (encrypted)]
           [Message 1 (encrypted)]
           [Message N (encrypted)]
  ```
- This should be a styled HTML/CSS element, not just ASCII art
- Arrow should clearly show: header is sent first, then encrypted size-prefixed messages follow

### 3.4 Encryption Header Explanation
- Show the `EncryptionHeader` fields in a human-readable format:
  - `ephemeral_public_key` — sender's ephemeral X25519/secp256k1 key (used for ECDH)
  - `nonce_start` — 12-byte random starting nonce (basis for all field nonces)
  - `algorithm` — key exchange algorithm used (0=X25519, 1=secp256k1, 2=P-256, 3=P-384)
  - `context` — optional application context string (mixed into HKDF)
  - `timestamp` — when the session was created
- Explain that receiving the header is **the start of the stream** — without it, the consumer cannot decrypt anything

### 3.5 Brute Force Nonce Recovery
- Include a code example showing the fallback when `recordIndex` is unknown:
  ```javascript
  for (let tryIndex = 0; tryIndex < maxAttempts; tryIndex++) {
    ctx.setRecordIndex(tryIndex);
    try {
      const result = decryptBuffer(encrypted, ctx);
      // Validate FlatBuffer structure
      if (isValidFlatBuffer(result)) return { data: result, recordIndex: tryIndex };
    } catch (e) { continue; }
  }
  ```
- Explain why this is needed (out-of-order delivery, dropped messages, reconnection)

---

## 4. Field-Level Encryption Header Display

### 4.1 Human-Readable Header
- When a record is encrypted in the field-level encryption demo, show the `EncryptionHeader` as a formatted card/table — not just raw JSON
- Each field should have:
  - Field name
  - Value (hex for binary fields, readable for strings/numbers)
  - **Explanation** of what the field means and how it's used

### 4.2 Nonce Start Explanation
- Show `nonce_start` prominently with explanation:
  - *"This 12-byte random value is the basis for all field-level nonces"*
  - *"Each field's nonce = nonce_start + (recordIndex × 65536 + fieldId)"*
  - *"The nonce_start is transmitted once at session start, not per-message"*
- Visual diagram showing nonce derivation for a specific field

### 4.3 Stream Context
- Explain that receiving the header marks the beginning of an encrypted stream
- Show the flow: Header → Record 0 → Record 1 → ... → Record N
- Each record uses the same `nonce_start` but increments `recordIndex`

---

## 5. Streaming Dispatcher — Memory Layout Visualization

### 5.1 Hexdump Layout
- The streaming dispatcher demo should show the **linear memory map** as a hexdump:
  ```
  Offset    00 01 02 03 04 05 06 07  08 09 0A 0B 0C 0D 0E 0F  | Parsed
  ─────────────────────────────────────────────────────────────────────────
  0x0000    40 00 00 00 4D 4F 4E 53  0C 00 00 00 08 00 0C 00  | Monster #0
  0x0010    04 00 08 00 08 00 00 00  E8 03 00 00 64 00 00 00  |   hp=1000 mana=100
  0x0020    ...                                                |
  0x0040    20 00 00 00 57 45 41 50  08 00 00 00 04 00 06 00  | Weapon #0
  0x0050    ...                                                |   damage=150
  ```
- Hex bytes on the left, parsed object descriptions on the right
- Color-code by message type (red=Monster, blue=Weapon, purple=Galaxy)
- Show size-prefix, file_id, vtable, and data sections with labels

### 5.2 Interactive JavaScript Implementation
- Use actual JavaScript to render the hexdump from the dispatcher's ring buffer
- Read the raw `SharedArrayBuffer` / `ArrayBuffer` from the dispatcher
- Parse and annotate each message's position, type, and field values
- Update in real-time as messages are pushed

### 5.3 Ring Buffer Visualization
- Show how the ring buffer wraps around
- Head/tail pointers with current position indicators
- Dropped message count and buffer utilization percentage

---

## 6. Documentation Pages — All Links Must Work

### 6.1 Fix Documentation Card Links
The four documentation cards at the bottom of index.html point to:
1. `docs-html/README.html` — Getting Started
2. `docs-html/README.html#api-reference` — API Reference
3. `docs-html/README.html#security` — Security Guide
4. `docs-html/README.html#performance` — Performance

**Requirements:**
- The anchor targets (`#api-reference`, `#security`, `#performance`) must exist as headings in `docs/README.md`
- Verify these headings exist; add them if missing
- Regenerate `docs-html/` after any markdown changes

### 6.2 Regenerate docs-html
- Run `node wasm/docs/scripts/build-markdown.mjs` to regenerate all HTML from markdown
- Verify the generated CSS is valid (no unclosed blocks)
- Ensure `encryption.html` is generated (currently missing from docs-html/)
- Add `streaming.html` once streaming.md is created

### 6.3 Create Missing Doc Pages

**streaming.md** — New page covering:
- StreamingDispatcher API
- Wire format (size-prefix + file_id)
- Producer/consumer patterns with encryption
- Memory layout and ring buffer mechanics
- Tab-based code examples per language

**Verify existing pages are complete:**
- `encryption.md` — Must cover sessions, nonce management, brute force recovery
- `go.md`, `python.md`, `rust.md`, `java.md`, `csharp.md`, `swift.md` — Must include embedded runtime download info
- `nodejs.md`, `browser.md` — Must include embedded runtime download info

### 6.4 Language Guide Links
The "Language Guides" section at the bottom of `docs/README.md` links to:
- encryption.md, go.md, python.md, rust.md, java.md, csharp.md, swift.md, nodejs.md, browser.md
- Add: **streaming.md** link
- All `.md` links are converted to `.html` by the build script

---

## 7. Aligned Binary Format — Fix and Document

### 7.1 Fix the Demo Schema
- The example schema in the Aligned tab must include `root_type` declaration
- Example fix:
  ```fbs
  table Entity {
    x: float;
    y: float;
    z: float;
    hp: int;
  }
  root_type Entity;
  ```

### 7.2 Error Display in UI
- When `generateAlignedCode()` throws, catch the error and display it in an error box inside the Aligned tab
- Error box should be styled (red border, error icon) and show the error message
- Clear the error box on successful generation

### 7.3 Document Default Behavior
- Document that `root_type` is **required** in the schema for aligned code generation
- Show the expected schema format in the placeholder/example text

---

## 8. General Website Improvements

### 8.1 Consistent Tab UI
- Streaming examples, code generation examples, and language-specific docs should all use the same tab component
- Tab component should support: click to switch, keyboard navigation, URL hash sync

### 8.2 Build Pipeline
After all changes:
1. Fix `scripts/build-markdown.mjs` template if needed
2. Run `node scripts/build-markdown.mjs` to regenerate docs-html/
3. Run `npm run build` in `wasm/docs/` to rebuild dist/
4. Verify all docs links work in dev mode (`npm run dev`)
5. Commit, tag, push, monitor CI

---

## Priority Order

1. **P0 — Fix CSS bug** (docs pages are broken)
2. **P0 — Fix aligned codegen error** (console error on page load)
3. **P1 — Embedded runtime downloads** (core feature change)
4. **P1 — Streaming producer/consumer with encryption** (major doc improvement)
5. **P1 — Encryption header display** (usability)
6. **P2 — Memory layout hexdump** (advanced visualization)
7. **P2 — Create streaming.md** (new doc page)
8. **P2 — Regenerate all docs-html** (depends on all markdown changes)
9. **P3 — Verify all language guide pages complete** (content audit)
