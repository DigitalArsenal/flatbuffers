<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Csharp - DA FlatBuffers</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown-dark.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #0a0a0f;
      --bg-secondary: #12121a;
      --bg-tertiary: #1a1a24;
      --accent-primary: #6366f1;
      --accent-secondary: #818cf8;
      --text-primary: #e2e8f0;
      --text-secondary: #94a3b8;
      --border-color: rgba(99, 102, 241, 0.2);
      --glow-color: rgba(99, 102, 241, 0.15);
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      margin: 0;
      padding: 0;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    /* Animated background */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(ellipse at 20% 20%, rgba(99, 102, 241, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(139, 92, 246, 0.06) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(59, 130, 246, 0.04) 0%, transparent 70%);
      pointer-events: none;
      z-index: 0;
    }

    /* Grid pattern overlay */
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        linear-gradient(rgba(99, 102, 241, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(99, 102, 241, 0.03) 1px, transparent 1px);
      background-size: 50px 50px;
      pointer-events: none;
      z-index: 0;
    }

    .page-container {
      position: relative;
      z-index: 1;
      max-width: 900px;
      margin: 0 auto;
      padding: 40px 20px;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      margin-bottom: 30px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--accent-secondary);
      text-decoration: none;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    .back-link:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent-primary);
      box-shadow: 0 0 20px var(--glow-color);
      transform: translateY(-1px);
    }

    .markdown-body {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      padding: 48px;
      box-shadow:
        0 4px 6px rgba(0, 0, 0, 0.3),
        0 0 40px var(--glow-color);
    }

    .markdown-body h1,
    .markdown-body h2,
    .markdown-body h3,
    .markdown-body h4 {
      color: var(--text-primary);
      border-bottom-color: var(--border-color);
      font-weight: 600;
    }

    .markdown-body h1 {
      background: linear-gradient(135deg, var(--accent-secondary), var(--accent-primary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-size: 2.2em;
      margin-bottom: 24px;
    }

    .markdown-body a {
      color: var(--accent-secondary);
    }

    .markdown-body a:hover {
      color: var(--accent-primary);
    }

    .markdown-body code {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 2px 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9em;
    }

    .markdown-body pre {
      background: var(--bg-primary) !important;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
      overflow-x: auto;
    }

    .markdown-body pre code {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 0.85em;
      line-height: 1.6;
    }

    .markdown-body table {
      border-collapse: collapse;
      width: 100%;
      margin: 20px 0;
    }

    .markdown-body table th,
    .markdown-body table td {
      border: 1px solid var(--border-color);
      padding: 12px 16px;
      text-align: left;
    }

    .markdown-body table th {
      background: var(--bg-tertiary);
      font-weight: 600;
      color: var(--accent-secondary);
    }

    .markdown-body table tr:nth-child(even) {
      background: rgba(99, 102, 241, 0.03);
    }

    .markdown-body blockquote {
      border-left: 4px solid var(--accent-primary);
      background: var(--bg-tertiary);
      padding: 16px 20px;
      margin: 20px 0;
      border-radius: 0 8px 8px 0;
    }

    .markdown-body hr {
      border: none;
      height: 1px;
      background: var(--border-color);
      margin: 32px 0;
    }

    .markdown-body ul, .markdown-body ol {
      padding-left: 24px;
    }

    .markdown-body li {
      margin: 8px 0;
    }

    @media (max-width: 768px) {
      .page-container {
        padding: 20px 16px;
      }
      .markdown-body {
        padding: 24px;
        border-radius: 12px;
      }
      .markdown-body h1 {
        font-size: 1.8em;
      }
    }
  </style>
</head>
<body>
  <div class="page-container">
    <a href="https://digitalarsenal.github.io/flatbuffers/" class="back-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
      Back to DA FlatBuffers
    </a>
    <article class="markdown-body"><h1>C# Integration Guide</h1>
<p>Integrate the FlatBuffers encryption WASM module into .NET applications using <a href="https://wasmtime.dev/">Wasmtime</a>, a fast and secure WebAssembly runtime.</p>
<h2>Why Wasmtime?</h2>
<ul>
<li><strong>Production ready</strong> - Used by Fastly, Shopify, and others</li>
<li><strong>Fast</strong> - Optimizing compiler with excellent performance</li>
<li><strong>.NET 6+ support</strong> - Modern .NET integration</li>
<li><strong>NuGet package</strong> - Easy installation</li>
</ul>
<h2>Prerequisites</h2>
<ul>
<li>.NET 6.0 or later</li>
<li><code>flatc-encryption.wasm</code> binary</li>
</ul>
<h2>Installation</h2>
<pre><code class="language-bash">dotnet add package Wasmtime
</code></pre>
<h2>Quick Start</h2>
<pre><code class="language-csharp">using Wasmtime;

var engine = new Engine();
using var linker = new Linker(engine);
using var store = new Store(engine);

// Add WASI stubs
linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;fd_close&quot;, (int fd) =&gt; 0);
linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;clock_time_get&quot;,
    (Caller caller, int clockId, long precision, int time) =&gt; 0);
// Add other WASI functions as needed...

// Load module
using var module = Module.FromFile(engine, &quot;flatc-encryption.wasm&quot;);
var instance = linker.Instantiate(store, module);

// Get exports
var memory = instance.GetMemory(&quot;memory&quot;)!;
var malloc = instance.GetFunction(&quot;malloc&quot;)!;
var free = instance.GetFunction(&quot;free&quot;)!;
var encrypt = instance.GetFunction(&quot;wasi_encrypt_bytes&quot;)!;

// Encrypt data
var key = new byte[32];
var iv = new byte[16];
Random.Shared.NextBytes(key);
Random.Shared.NextBytes(iv);

var plaintext = System.Text.Encoding.UTF8.GetBytes(&quot;Hello, FlatBuffers!&quot;);

// Allocate WASM memory
var keyPtr = (int)malloc.Invoke(32)!;
var ivPtr = (int)malloc.Invoke(16)!;
var dataPtr = (int)malloc.Invoke(plaintext.Length)!;

// Write to memory
memory.WriteBytes(keyPtr, key);
memory.WriteBytes(ivPtr, iv);
memory.WriteBytes(dataPtr, plaintext);

// Encrypt
encrypt.Invoke(keyPtr, ivPtr, dataPtr, plaintext.Length);

// Read encrypted data
var ciphertext = memory.ReadBytes(dataPtr, plaintext.Length);
Console.WriteLine($&quot;Encrypted: {Convert.ToHexString(ciphertext)}&quot;);

// Clean up
free.Invoke(keyPtr);
free.Invoke(ivPtr);
free.Invoke(dataPtr);
</code></pre>
<h2>Complete Module Wrapper</h2>
<pre><code class="language-csharp">using Wasmtime;
using System.Security.Cryptography;
using System.Text;

namespace FlatBuffers.Encryption;

/// &lt;summary&gt;
/// FlatBuffers Encryption Module for .NET.
///
/// Provides cryptographic operations via the Crypto++ WASM module:
/// - AES-256-CTR symmetric encryption
/// - X25519 ECDH key exchange
/// - secp256k1 ECDH and ECDSA signatures
/// - P-256 ECDH and ECDSA signatures
/// - Ed25519 signatures
/// &lt;/summary&gt;
public sealed class EncryptionModule : IDisposable
{
    // Key and signature sizes
    public const int AesKeySize = 32;
    public const int AesIvSize = 16;
    public const int Sha256Size = 32;

    public const int X25519PrivateKeySize = 32;
    public const int X25519PublicKeySize = 32;

    public const int Secp256k1PrivateKeySize = 32;
    public const int Secp256k1PublicKeySize = 33;
    public const int Secp256k1SignatureMaxSize = 72;

    public const int Ed25519PrivateKeySize = 64;
    public const int Ed25519PublicKeySize = 32;
    public const int Ed25519SignatureSize = 64;

    private readonly Engine _engine;
    private readonly Store _store;
    private readonly Linker _linker;
    private readonly Instance _instance;
    private readonly Memory _memory;

    private readonly Func&lt;int, int&gt; _malloc;
    private readonly Action&lt;int&gt; _free;

    private readonly Func&lt;int, int, int, int, int&gt; _encrypt;
    private readonly Func&lt;int, int, int, int, int&gt; _decrypt;
    private readonly Action&lt;int, int, int&gt; _sha256;
    private readonly Action&lt;int, int, int, int, int, int, int, int&gt; _hkdf;

    private readonly Func&lt;int, int, int&gt; _x25519Generate;
    private readonly Func&lt;int, int, int, int&gt; _x25519Shared;

    private readonly Func&lt;int, int, int&gt; _secp256k1Generate;
    private readonly Func&lt;int, int, int, int, int&gt; _secp256k1Shared;
    private readonly Func&lt;int, int, int, int, int, int&gt; _secp256k1Sign;
    private readonly Func&lt;int, int, int, int, int, int, int&gt; _secp256k1Verify;

    private readonly Func&lt;int, int, int&gt; _ed25519Generate;
    private readonly Func&lt;int, int, int, int, int&gt; _ed25519Sign;
    private readonly Func&lt;int, int, int, int, int&gt; _ed25519Verify;

    public EncryptionModule(string wasmPath)
    {
        _engine = new Engine();
        _store = new Store(_engine);
        _linker = new Linker(_engine);

        // Define WASI stubs
        DefineWasiStubs();
        DefineEnvStubs();

        // Load and instantiate module
        using var module = Module.FromFile(_engine, wasmPath);
        _instance = _linker.Instantiate(_store, module);

        // Get memory
        _memory = _instance.GetMemory(&quot;memory&quot;)
            ?? throw new InvalidOperationException(&quot;Memory export not found&quot;);

        // Get functions
        _malloc = _instance.GetFunction&lt;int, int&gt;(&quot;malloc&quot;)
            ?? throw new InvalidOperationException(&quot;malloc not found&quot;);
        _free = _instance.GetAction&lt;int&gt;(&quot;free&quot;)
            ?? throw new InvalidOperationException(&quot;free not found&quot;);

        _encrypt = _instance.GetFunction&lt;int, int, int, int, int&gt;(&quot;wasi_encrypt_bytes&quot;)!;
        _decrypt = _instance.GetFunction&lt;int, int, int, int, int&gt;(&quot;wasi_decrypt_bytes&quot;)!;
        _sha256 = _instance.GetAction&lt;int, int, int&gt;(&quot;wasi_sha256&quot;)!;
        _hkdf = _instance.GetAction&lt;int, int, int, int, int, int, int, int&gt;(&quot;wasi_hkdf&quot;)!;

        _x25519Generate = _instance.GetFunction&lt;int, int, int&gt;(&quot;wasi_x25519_generate_keypair&quot;)!;
        _x25519Shared = _instance.GetFunction&lt;int, int, int, int&gt;(&quot;wasi_x25519_shared_secret&quot;)!;

        _secp256k1Generate = _instance.GetFunction&lt;int, int, int&gt;(&quot;wasi_secp256k1_generate_keypair&quot;)!;
        _secp256k1Shared = _instance.GetFunction&lt;int, int, int, int, int&gt;(&quot;wasi_secp256k1_shared_secret&quot;)!;
        _secp256k1Sign = _instance.GetFunction&lt;int, int, int, int, int, int&gt;(&quot;wasi_secp256k1_sign&quot;)!;
        _secp256k1Verify = _instance.GetFunction&lt;int, int, int, int, int, int, int&gt;(&quot;wasi_secp256k1_verify&quot;)!;

        _ed25519Generate = _instance.GetFunction&lt;int, int, int&gt;(&quot;wasi_ed25519_generate_keypair&quot;)!;
        _ed25519Sign = _instance.GetFunction&lt;int, int, int, int, int&gt;(&quot;wasi_ed25519_sign&quot;)!;
        _ed25519Verify = _instance.GetFunction&lt;int, int, int, int, int&gt;(&quot;wasi_ed25519_verify&quot;)!;
    }

    private void DefineWasiStubs()
    {
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;fd_close&quot;,
            (int fd) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;fd_seek&quot;,
            (Caller c, int fd, long offset, int whence, int newOffset) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;fd_write&quot;,
            (Caller c, int fd, int iovs, int iovsLen, int nwritten) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;fd_read&quot;,
            (Caller c, int fd, int iovs, int iovsLen, int nread) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;environ_sizes_get&quot;,
            (Caller c, int count, int size) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;environ_get&quot;,
            (Caller c, int environ, int environBuf) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;clock_time_get&quot;,
            (Caller c, int clockId, long precision, int time) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;proc_exit&quot;,
            (int code) =&gt; { });
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;random_get&quot;,
            (Caller c, int buf, int bufLen) =&gt; 0);
    }

    private void DefineEnvStubs()
    {
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_v&quot;, (int idx) =&gt; { });
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_vi&quot;, (int idx, int a) =&gt; { });
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_vii&quot;, (int idx, int a, int b) =&gt; { });
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_viii&quot;, (int idx, int a, int b, int c) =&gt; { });
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_i&quot;, (int idx) =&gt; 0);
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_ii&quot;, (int idx, int a) =&gt; 0);
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_iii&quot;, (int idx, int a, int b) =&gt; 0);
    }

    // Key pair records

    public record X25519KeyPair(byte[] PrivateKey, byte[] PublicKey);
    public record Ed25519KeyPair(byte[] PrivateKey, byte[] PublicKey);
    public record Secp256k1KeyPair(byte[] PrivateKey, byte[] PublicKey);

    // Memory helpers

    private void WriteBytes(int offset, ReadOnlySpan&lt;byte&gt; data)
    {
        var span = _memory.GetSpan&lt;byte&gt;(offset, data.Length);
        data.CopyTo(span);
    }

    private byte[] ReadBytes(int offset, int length)
    {
        var span = _memory.GetSpan&lt;byte&gt;(offset, length);
        return span.ToArray();
    }

    private int Allocate(int size)
    {
        var ptr = _malloc(size);
        if (ptr == 0)
            throw new OutOfMemoryException(&quot;WASM malloc returned null&quot;);
        return ptr;
    }

    // Symmetric Encryption

    /// &lt;summary&gt;
    /// Encrypt data using AES-256-CTR.
    /// &lt;/summary&gt;
    public byte[] Encrypt(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; iv, ReadOnlySpan&lt;byte&gt; data)
    {
        if (key.Length != AesKeySize)
            throw new ArgumentException($&quot;Key must be {AesKeySize} bytes&quot;, nameof(key));
        if (iv.Length != AesIvSize)
            throw new ArgumentException($&quot;IV must be {AesIvSize} bytes&quot;, nameof(iv));

        var keyPtr = Allocate(key.Length);
        var ivPtr = Allocate(iv.Length);
        var dataPtr = Allocate(data.Length);

        try
        {
            WriteBytes(keyPtr, key);
            WriteBytes(ivPtr, iv);
            WriteBytes(dataPtr, data);

            var result = _encrypt(keyPtr, ivPtr, dataPtr, data.Length);
            if (result != 0)
                throw new CryptographicException(&quot;Encryption failed&quot;);

            return ReadBytes(dataPtr, data.Length);
        }
        finally
        {
            _free(keyPtr);
            _free(ivPtr);
            _free(dataPtr);
        }
    }

    /// &lt;summary&gt;
    /// Decrypt data using AES-256-CTR.
    /// &lt;/summary&gt;
    public byte[] Decrypt(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; iv, ReadOnlySpan&lt;byte&gt; data)
    {
        // CTR mode is symmetric
        return Encrypt(key, iv, data);
    }

    // Hash Functions

    /// &lt;summary&gt;
    /// Compute SHA-256 hash.
    /// &lt;/summary&gt;
    public byte[] Sha256(ReadOnlySpan&lt;byte&gt; data)
    {
        var dataPtr = Allocate(data.Length);
        var outPtr = Allocate(Sha256Size);

        try
        {
            WriteBytes(dataPtr, data);
            _sha256(dataPtr, data.Length, outPtr);
            return ReadBytes(outPtr, Sha256Size);
        }
        finally
        {
            _free(dataPtr);
            _free(outPtr);
        }
    }

    /// &lt;summary&gt;
    /// Derive key using HKDF-SHA256.
    /// &lt;/summary&gt;
    public byte[] Hkdf(ReadOnlySpan&lt;byte&gt; ikm, ReadOnlySpan&lt;byte&gt; salt, ReadOnlySpan&lt;byte&gt; info, int length)
    {
        var ikmPtr = Allocate(ikm.Length);
        WriteBytes(ikmPtr, ikm);

        var saltPtr = 0;
        var saltLen = 0;
        if (!salt.IsEmpty)
        {
            saltPtr = Allocate(salt.Length);
            WriteBytes(saltPtr, salt);
            saltLen = salt.Length;
        }

        var infoPtr = Allocate(info.Length);
        WriteBytes(infoPtr, info);

        var outPtr = Allocate(length);

        try
        {
            _hkdf(ikmPtr, ikm.Length, saltPtr, saltLen, infoPtr, info.Length, outPtr, length);
            return ReadBytes(outPtr, length);
        }
        finally
        {
            _free(ikmPtr);
            if (saltPtr != 0) _free(saltPtr);
            _free(infoPtr);
            _free(outPtr);
        }
    }

    // X25519 Key Exchange

    /// &lt;summary&gt;
    /// Generate X25519 key pair.
    /// &lt;/summary&gt;
    public X25519KeyPair X25519GenerateKeyPair()
    {
        var privPtr = Allocate(X25519PrivateKeySize);
        var pubPtr = Allocate(X25519PublicKeySize);

        try
        {
            var result = _x25519Generate(privPtr, pubPtr);
            if (result != 0)
                throw new CryptographicException(&quot;Key generation failed&quot;);

            return new X25519KeyPair(
                ReadBytes(privPtr, X25519PrivateKeySize),
                ReadBytes(pubPtr, X25519PublicKeySize)
            );
        }
        finally
        {
            _free(privPtr);
            _free(pubPtr);
        }
    }

    /// &lt;summary&gt;
    /// Compute X25519 shared secret.
    /// &lt;/summary&gt;
    public byte[] X25519SharedSecret(ReadOnlySpan&lt;byte&gt; privateKey, ReadOnlySpan&lt;byte&gt; publicKey)
    {
        var privPtr = Allocate(privateKey.Length);
        var pubPtr = Allocate(publicKey.Length);
        var outPtr = Allocate(32);

        try
        {
            WriteBytes(privPtr, privateKey);
            WriteBytes(pubPtr, publicKey);

            var result = _x25519Shared(privPtr, pubPtr, outPtr);
            if (result != 0)
                throw new CryptographicException(&quot;Shared secret computation failed&quot;);

            return ReadBytes(outPtr, 32);
        }
        finally
        {
            _free(privPtr);
            _free(pubPtr);
            _free(outPtr);
        }
    }

    // Ed25519 Signatures

    /// &lt;summary&gt;
    /// Generate Ed25519 key pair.
    /// &lt;/summary&gt;
    public Ed25519KeyPair Ed25519GenerateKeyPair()
    {
        var privPtr = Allocate(Ed25519PrivateKeySize);
        var pubPtr = Allocate(Ed25519PublicKeySize);

        try
        {
            var result = _ed25519Generate(privPtr, pubPtr);
            if (result != 0)
                throw new CryptographicException(&quot;Key generation failed&quot;);

            return new Ed25519KeyPair(
                ReadBytes(privPtr, Ed25519PrivateKeySize),
                ReadBytes(pubPtr, Ed25519PublicKeySize)
            );
        }
        finally
        {
            _free(privPtr);
            _free(pubPtr);
        }
    }

    /// &lt;summary&gt;
    /// Sign with Ed25519.
    /// &lt;/summary&gt;
    public byte[] Ed25519Sign(ReadOnlySpan&lt;byte&gt; privateKey, ReadOnlySpan&lt;byte&gt; message)
    {
        var privPtr = Allocate(privateKey.Length);
        var msgPtr = Allocate(message.Length);
        var sigPtr = Allocate(Ed25519SignatureSize);

        try
        {
            WriteBytes(privPtr, privateKey);
            WriteBytes(msgPtr, message);

            var result = _ed25519Sign(privPtr, msgPtr, message.Length, sigPtr);
            if (result != 0)
                throw new CryptographicException(&quot;Signing failed&quot;);

            return ReadBytes(sigPtr, Ed25519SignatureSize);
        }
        finally
        {
            _free(privPtr);
            _free(msgPtr);
            _free(sigPtr);
        }
    }

    /// &lt;summary&gt;
    /// Verify Ed25519 signature.
    /// &lt;/summary&gt;
    public bool Ed25519Verify(ReadOnlySpan&lt;byte&gt; publicKey, ReadOnlySpan&lt;byte&gt; message, ReadOnlySpan&lt;byte&gt; signature)
    {
        var pubPtr = Allocate(publicKey.Length);
        var msgPtr = Allocate(message.Length);
        var sigPtr = Allocate(signature.Length);

        try
        {
            WriteBytes(pubPtr, publicKey);
            WriteBytes(msgPtr, message);
            WriteBytes(sigPtr, signature);

            var result = _ed25519Verify(pubPtr, msgPtr, message.Length, sigPtr);
            return result == 0;
        }
        finally
        {
            _free(pubPtr);
            _free(msgPtr);
            _free(sigPtr);
        }
    }

    public void Dispose()
    {
        _store.Dispose();
        _linker.Dispose();
        _engine.Dispose();
    }
}
</code></pre>
<h2>Template Project Structure</h2>
<pre><code>MyProject/
├── MyProject.csproj
├── Program.cs
├── Encryption/
│   └── EncryptionModule.cs
├── wasm/
│   └── flatc-encryption.wasm
└── Tests/
    └── EncryptionTests.cs
</code></pre>
<p><strong>MyProject.csproj:</strong></p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;Wasmtime&quot; Version=&quot;18.0.0&quot; /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;None Update=&quot;wasm\flatc-encryption.wasm&quot;&gt;
      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
    &lt;/None&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<h2>Usage Examples</h2>
<h3>Basic Encryption</h3>
<pre><code class="language-csharp">using var module = new EncryptionModule(&quot;flatc-encryption.wasm&quot;);

var key = new byte[32];
var iv = new byte[16];
Random.Shared.NextBytes(key);
Random.Shared.NextBytes(iv);

var plaintext = Encoding.UTF8.GetBytes(&quot;Secret message&quot;);
var ciphertext = module.Encrypt(key, iv, plaintext);
var decrypted = module.Decrypt(key, iv, ciphertext);

Debug.Assert(plaintext.SequenceEqual(decrypted));
</code></pre>
<h3>End-to-End Encryption</h3>
<pre><code class="language-csharp">using var module = new EncryptionModule(&quot;flatc-encryption.wasm&quot;);

// Generate key pairs
var alice = module.X25519GenerateKeyPair();
var bob = module.X25519GenerateKeyPair();

// Compute shared secrets
var aliceShared = module.X25519SharedSecret(alice.PrivateKey, bob.PublicKey);
var bobShared = module.X25519SharedSecret(bob.PrivateKey, alice.PublicKey);

Debug.Assert(aliceShared.SequenceEqual(bobShared));

// Derive encryption key
var encryptionKey = module.Hkdf(aliceShared, default, &quot;encryption-v1&quot;u8, 32);

// Encrypt
var iv = new byte[16];
Random.Shared.NextBytes(iv);
var ciphertext = module.Encrypt(encryptionKey, iv, &quot;Hello Bob!&quot;u8);

// Decrypt
var decrypted = module.Decrypt(encryptionKey, iv, ciphertext);
Console.WriteLine(Encoding.UTF8.GetString(decrypted)); // &quot;Hello Bob!&quot;
</code></pre>
<h2>Performance Tips</h2>
<ol>
<li><strong>Reuse module instances</strong> - Module loading is expensive</li>
<li><strong>Use Span<byte></strong> - Avoid unnecessary allocations</li>
<li><strong>Consider object pooling</strong> - For high-throughput scenarios</li>
</ol>
<pre><code class="language-csharp">// Good: Reuse instance
using var module = new EncryptionModule(&quot;wasm&quot;);
foreach (var item in items)
{
    module.Encrypt(key, iv, item);
}

// Bad: Create new instance each time
foreach (var item in items)
{
    using var module = new EncryptionModule(&quot;wasm&quot;); // Slow!
    module.Encrypt(key, iv, item);
}
</code></pre>
<h2>Troubleshooting</h2>
<h3>&quot;Function not found&quot;</h3>
<p>Ensure WASI and env stubs are defined before instantiation.</p>
<h3>&quot;Memory access out of bounds&quot;</h3>
<p>Check allocation succeeded:</p>
<pre><code class="language-csharp">var ptr = _malloc(size);
if (ptr == 0)
    throw new OutOfMemoryException(&quot;Allocation failed&quot;);
</code></pre>
<h2>See Also</h2>
<ul>
<li><a href="https://docs.wasmtime.dev/">Wasmtime .NET Documentation</a></li>
<li><a href="README.md#api-reference">API Reference</a></li>
<li><a href="README.md#security-considerations">Security Considerations</a></li>
</ul>
</article>
  </div>
</body>
</html>