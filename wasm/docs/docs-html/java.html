<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Java - DA FlatBuffers</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --black: #000000;
      --white: #F5F5F7;
      --white-90: rgba(255, 255, 255, 0.9);
      --white-80: rgba(255, 255, 255, 0.8);
      --white-60: rgba(255, 255, 255, 0.6);
      --white-40: rgba(255, 255, 255, 0.4);
      --white-20: rgba(255, 255, 255, 0.2);
      --white-10: rgba(255, 255, 255, 0.1);
      --white-05: rgba(255, 255, 255, 0.05);
      --muted: rgba(134, 134, 139, 1.0);
      --glass-bg: rgba(42, 42, 45, 0.72);
      --glass-hover: rgba(66, 66, 69, 0.72);
      --glass-border: rgba(255, 255, 255, 0.1);
      --glass-blur: blur(20px);
      --radius: 28px;
      --radius-sm: 14px;

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;

    html {
      scroll-behavior: smooth;

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--black);
      color: var(--white);
      line-height: 1.6;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;

    /* Video Background */
    .video-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      overflow: hidden;

    .video-background video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.3;

    .video-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        to bottom,
        rgba(0, 0, 0, 0.4) 0%,
        rgba(0, 0, 0, 0.6) 50%,
        rgba(0, 0, 0, 0.85) 100%
      );

    .page-container {
      position: relative;
      z-index: 1;
      max-width: 900px;
      margin: 0 auto;
      padding: 60px 24px 80px;

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      margin-bottom: 40px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      color: var(--white);
      text-decoration: none;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.3s ease;

    .back-link:hover {
      background: var(--glass-hover);
      transform: translateY(-2px);

    .markdown-body {
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      padding: 64px;

    .markdown-body h1 {
      color: var(--white);
      font-size: 56px;
      font-weight: 600;
      line-height: 1.1;
      margin-bottom: 32px;
      letter-spacing: -0.02em;

    .markdown-body h2 {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--white);
      font-size: 28px;
      font-weight: 600;
      line-height: 1.15;
      margin-top: 56px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--glass-border);

    .markdown-body h2::before {
      content: '';
      display: inline-flex;
      width: 24px;
      height: 24px;
      background: var(--white);
      -webkit-mask-size: contain;
      mask-size: contain;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
      flex-shrink: 0;

    /* Icon mappings for h2 headers based on content */
    .markdown-body h2[id*="why"]::before,
    .markdown-body h2:has(+ p:first-of-type)::before {
      -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
      mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");

    .markdown-body h3,
    .markdown-body h4 {
      color: var(--white);
      font-weight: 600;
      margin-top: 32px;
      margin-bottom: 16px;

    .markdown-body h3 {
      font-size: 22px;

    .markdown-body h4 {
      font-size: 18px;
      color: var(--white-90);

    .markdown-body p {
      color: var(--white-80);
      font-size: 18px;
      line-height: 1.7;
      margin-bottom: 20px;

    .markdown-body a {
      color: var(--white);
      text-decoration: underline;
      text-underline-offset: 3px;
      transition: opacity 0.2s;

    .markdown-body a:hover {
      opacity: 0.7;

    .markdown-body strong {
      color: var(--white);
      font-weight: 600;

    .markdown-body code {
      background: var(--glass-hover);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      padding: 3px 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9em;
      color: var(--white);

    .markdown-body pre {
      background: var(--black) !important;
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      padding: 24px;
      overflow-x: auto;
      margin: 24px 0;

    .markdown-body pre code {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 14px;
      line-height: 1.7;
      color: var(--white-90);

    .markdown-body ul, .markdown-body ol {
      padding-left: 24px;
      margin-bottom: 20px;

    .markdown-body li {
      margin: 12px 0;
      color: var(--white-80);
      font-size: 18px;

    .markdown-body li strong {
      color: var(--white);

    .markdown-body table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      border-radius: var(--radius-sm);
      overflow: hidden;

    .markdown-body table th,
    .markdown-body table td {
      border: 1px solid var(--glass-border);
      padding: 14px 18px;
      text-align: left;

    .markdown-body table th {
      background: var(--glass-hover);
      font-weight: 600;
      color: var(--white);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;

    .markdown-body table td {
      background: var(--white-05);
      color: var(--white-80);

    .markdown-body table tr:nth-child(even) td {
      background: var(--white-10);

    .markdown-body blockquote {
      border-left: 4px solid var(--white-40);
      background: var(--white-05);
      padding: 20px 24px;
      margin: 24px 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;

    .markdown-body blockquote p {
      margin: 0;
      color: var(--white-80);

    .markdown-body hr {
      border: none;
      height: 1px;
      background: var(--glass-border);
      margin: 48px 0;

    /* Section header icons */
    .section-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: var(--white-10);
      border-radius: 8px;
      margin-right: 12px;
      flex-shrink: 0;

    .section-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--white);
      fill: none;
      stroke-width: 2;

    @media (max-width: 768px) {
      .page-container {
        padding: 40px 16px 60px;
      .markdown-body {
        padding: 32px 24px;
        border-radius: 20px;
      .markdown-body h1 {
        font-size: 36px;
      .markdown-body h2 {
        font-size: 24px;
      .markdown-body p,
      .markdown-body li {
        font-size: 16px;
  </style>
</head>
<body>
  <!-- Video Background -->
  <div class="video-background">
    <video autoplay loop muted playsinline id="bg-video">
      <source src="" type="application/x-mpegURL">
    </video>
    <div class="video-overlay"></div>
  </div>

  <div class="page-container">
    <a href="../index.html" class="back-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
      Back to DA FlatBuffers
    </a>
    <article class="markdown-body"><h1>Java Integration Guide</h1>
<p>Integrate the FlatBuffers encryption WASM module into Java applications using <a href="https://github.com/nickmccoll/chicory">Chicory</a>, a pure Java WebAssembly runtime.</p>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg></span>Why Chicory?</h2>
<ul>
<li><strong>Pure Java</strong> - No JNI, no native dependencies</li>
<li><strong>JVM optimized</strong> - Designed for Java performance</li>
<li><strong>Easy deployment</strong> - Just add a Maven dependency</li>
<li><strong>GraalVM compatible</strong> - Works with native-image</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>Prerequisites</h2>
<ul>
<li>Java 17 or later</li>
<li>Maven or Gradle</li>
<li><code>flatc-encryption.wasm</code> binary</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></span>Installation</h2>
<p><strong>Maven:</strong></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.dylibso.chicory&lt;/groupId&gt;
    &lt;artifactId&gt;runtime&lt;/artifactId&gt;
    &lt;version&gt;1.5.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p><strong>Gradle:</strong></p>
<pre><code class="language-groovy">implementation &#39;com.dylibso.chicory:runtime:1.5.3&#39;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>Quick Start</h2>
<pre><code class="language-java">import com.dylibso.chicory.runtime.Instance;
import com.dylibso.chicory.runtime.Module;
import com.dylibso.chicory.runtime.Memory;
import com.dylibso.chicory.wasm.types.Value;

import java.nio.file.Files;
import java.nio.file.Path;
import java.security.SecureRandom;

public class QuickStart {
    public static void main(String[] args) throws Exception {
        // Load WASM module
        byte[] wasmBytes = Files.readAllBytes(Path.of(&quot;flatc-encryption.wasm&quot;));
        Module module = Module.builder(wasmBytes).build();
        Instance instance = module.instantiate();

        // Get memory and functions
        Memory memory = instance.memory();
        var malloc = instance.export(&quot;malloc&quot;);
        var free = instance.export(&quot;free&quot;);
        var encrypt = instance.export(&quot;wasi_encrypt_bytes&quot;);
        var decrypt = instance.export(&quot;wasi_decrypt_bytes&quot;);

        // Generate key and IV
        SecureRandom random = new SecureRandom();
        byte[] key = new byte[32];
        byte[] iv = new byte[16];
        random.nextBytes(key);
        random.nextBytes(iv);

        byte[] plaintext = &quot;Hello, FlatBuffers!&quot;.getBytes();

        // Allocate WASM memory
        int keyPtr = (int) malloc.apply(Value.i32(32))[0].asInt();
        int ivPtr = (int) malloc.apply(Value.i32(16))[0].asInt();
        int dataPtr = (int) malloc.apply(Value.i32(plaintext.length))[0].asInt();

        // Write to memory
        memory.write(keyPtr, key);
        memory.write(ivPtr, iv);
        memory.write(dataPtr, plaintext);

        // Encrypt
        encrypt.apply(
            Value.i32(keyPtr),
            Value.i32(ivPtr),
            Value.i32(dataPtr),
            Value.i32(plaintext.length)
        );

        // Read encrypted data
        byte[] ciphertext = memory.readBytes(dataPtr, plaintext.length);
        System.out.println(&quot;Encrypted: &quot; + bytesToHex(ciphertext));

        // Decrypt
        decrypt.apply(
            Value.i32(keyPtr),
            Value.i32(ivPtr),
            Value.i32(dataPtr),
            Value.i32(plaintext.length)
        );

        // Read decrypted data
        byte[] decrypted = memory.readBytes(dataPtr, plaintext.length);
        System.out.println(&quot;Decrypted: &quot; + new String(decrypted));

        // Clean up
        free.apply(Value.i32(keyPtr));
        free.apply(Value.i32(ivPtr));
        free.apply(Value.i32(dataPtr));

    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format(&quot;%02x&quot;, b));
        return sb.toString();
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></span>Complete Module Wrapper</h2>
<pre><code class="language-java">package com.example.encryption;

import com.dylibso.chicory.runtime.Instance;
import com.dylibso.chicory.runtime.Module;
import com.dylibso.chicory.runtime.Memory;
import com.dylibso.chicory.runtime.ExportFunction;
import com.dylibso.chicory.wasm.types.Value;

import java.nio.file.Files;
import java.nio.file.Path;
import java.security.SecureRandom;

/**
 * FlatBuffers Encryption Module for Java.
 *
 * Provides cryptographic operations via the Crypto++ WASM module:
 * - AES-256-CTR symmetric encryption
 * - X25519 ECDH key exchange
 * - secp256k1 ECDH and ECDSA signatures
 * - P-256 ECDH and ECDSA signatures
 * - Ed25519 signatures
 */
public class EncryptionModule implements AutoCloseable {

    // Key and signature sizes
    public static final int AES_KEY_SIZE = 32;
    public static final int AES_IV_SIZE = 16;
    public static final int SHA256_SIZE = 32;

    public static final int X25519_PRIVATE_KEY_SIZE = 32;
    public static final int X25519_PUBLIC_KEY_SIZE = 32;

    public static final int SECP256K1_PRIVATE_KEY_SIZE = 32;
    public static final int SECP256K1_PUBLIC_KEY_SIZE = 33;
    public static final int SECP256K1_SIGNATURE_MAX_SIZE = 72;

    public static final int ED25519_PRIVATE_KEY_SIZE = 64;
    public static final int ED25519_PUBLIC_KEY_SIZE = 32;
    public static final int ED25519_SIGNATURE_SIZE = 64;

    private final Instance instance;
    private final Memory memory;
    private final ExportFunction malloc;
    private final ExportFunction free;

    // Encryption
    private final ExportFunction encrypt;
    private final ExportFunction decrypt;

    // Hash
    private final ExportFunction sha256;
    private final ExportFunction hkdf;

    // X25519
    private final ExportFunction x25519Generate;
    private final ExportFunction x25519Shared;

    // secp256k1
    private final ExportFunction secp256k1Generate;
    private final ExportFunction secp256k1Shared;
    private final ExportFunction secp256k1Sign;
    private final ExportFunction secp256k1Verify;

    // Ed25519
    private final ExportFunction ed25519Generate;
    private final ExportFunction ed25519Sign;
    private final ExportFunction ed25519Verify;

    /**
     * Create a new encryption module from WASM bytes.
     */
    public EncryptionModule(byte[] wasmBytes) {
        Module module = Module.builder(wasmBytes).build();
        this.instance = module.instantiate();
        this.memory = instance.memory();

        // Core
        this.malloc = instance.export(&quot;malloc&quot;);
        this.free = instance.export(&quot;free&quot;);

        // Encryption
        this.encrypt = instance.export(&quot;wasi_encrypt_bytes&quot;);
        this.decrypt = instance.export(&quot;wasi_decrypt_bytes&quot;);

        // Hash
        this.sha256 = instance.export(&quot;wasi_sha256&quot;);
        this.hkdf = instance.export(&quot;wasi_hkdf&quot;);

        // X25519
        this.x25519Generate = instance.export(&quot;wasi_x25519_generate_keypair&quot;);
        this.x25519Shared = instance.export(&quot;wasi_x25519_shared_secret&quot;);

        // secp256k1
        this.secp256k1Generate = instance.export(&quot;wasi_secp256k1_generate_keypair&quot;);
        this.secp256k1Shared = instance.export(&quot;wasi_secp256k1_shared_secret&quot;);
        this.secp256k1Sign = instance.export(&quot;wasi_secp256k1_sign&quot;);
        this.secp256k1Verify = instance.export(&quot;wasi_secp256k1_verify&quot;);

        // Ed25519
        this.ed25519Generate = instance.export(&quot;wasi_ed25519_generate_keypair&quot;);
        this.ed25519Sign = instance.export(&quot;wasi_ed25519_sign&quot;);
        this.ed25519Verify = instance.export(&quot;wasi_ed25519_verify&quot;);

    /**
     * Create from file path.
     */
    public static EncryptionModule fromFile(String path) throws Exception {
        byte[] wasmBytes = Files.readAllBytes(Path.of(path));
        return new EncryptionModule(wasmBytes);

    // Key pair classes

    public record X25519KeyPair(byte[] privateKey, byte[] publicKey) {}
    public record Ed25519KeyPair(byte[] privateKey, byte[] publicKey) {}
    public record Secp256k1KeyPair(byte[] privateKey, byte[] publicKey) {}

    // Symmetric Encryption

    /**
     * Encrypt data using AES-256-CTR.
     *
     * @param key 32-byte encryption key
     * @param iv 16-byte initialization vector
     * @param data Data to encrypt
     * @return Encrypted data
     */
    public byte[] encrypt(byte[] key, byte[] iv, byte[] data) {
        if (key.length != AES_KEY_SIZE) {
            throw new IllegalArgumentException(&quot;Key must be &quot; + AES_KEY_SIZE + &quot; bytes&quot;);
        if (iv.length != AES_IV_SIZE) {
            throw new IllegalArgumentException(&quot;IV must be &quot; + AES_IV_SIZE + &quot; bytes&quot;);

        int keyPtr = allocate(key.length);
        int ivPtr = allocate(iv.length);
        int dataPtr = allocate(data.length);

        try {
            memory.write(keyPtr, key);
            memory.write(ivPtr, iv);
            memory.write(dataPtr, data);

            Value[] result = encrypt.apply(
                Value.i32(keyPtr),
                Value.i32(ivPtr),
                Value.i32(dataPtr),
                Value.i32(data.length)
            );

            if (result[0].asInt() != 0) {
                throw new RuntimeException(&quot;Encryption failed&quot;);

            return memory.readBytes(dataPtr, data.length);
        } finally {
            free(keyPtr);
            free(ivPtr);
            free(dataPtr);

    /**
     * Decrypt data using AES-256-CTR.
     */
    public byte[] decrypt(byte[] key, byte[] iv, byte[] data) {
        // CTR mode is symmetric
        return encrypt(key, iv, data);

    // Hash Functions

    /**
     * Compute SHA-256 hash.
     */
    public byte[] sha256(byte[] data) {
        int dataPtr = allocate(data.length);
        int outPtr = allocate(SHA256_SIZE);

        try {
            memory.write(dataPtr, data);
            sha256.apply(
                Value.i32(dataPtr),
                Value.i32(data.length),
                Value.i32(outPtr)
            );
            return memory.readBytes(outPtr, SHA256_SIZE);
        } finally {
            free(dataPtr);
            free(outPtr);

    /**
     * Derive key using HKDF-SHA256.
     *
     * @param ikm Input key material
     * @param salt Optional salt (can be null)
     * @param info Context info
     * @param length Output length
     * @return Derived key
     */
    public byte[] hkdf(byte[] ikm, byte[] salt, byte[] info, int length) {
        int ikmPtr = allocate(ikm.length);
        memory.write(ikmPtr, ikm);

        int saltPtr = 0;
        int saltLen = 0;
        if (salt != null &amp;&amp; salt.length &gt; 0) {
            saltPtr = allocate(salt.length);
            memory.write(saltPtr, salt);
            saltLen = salt.length;

        int infoPtr = allocate(info.length);
        memory.write(infoPtr, info);

        int outPtr = allocate(length);

        try {
            hkdf.apply(
                Value.i32(ikmPtr), Value.i32(ikm.length),
                Value.i32(saltPtr), Value.i32(saltLen),
                Value.i32(infoPtr), Value.i32(info.length),
                Value.i32(outPtr), Value.i32(length)
            );
            return memory.readBytes(outPtr, length);
        } finally {
            free(ikmPtr);
            if (saltPtr != 0) free(saltPtr);
            free(infoPtr);
            free(outPtr);

    // X25519 Key Exchange

    /**
     * Generate X25519 key pair.
     */
    public X25519KeyPair x25519GenerateKeyPair() {
        int privPtr = allocate(X25519_PRIVATE_KEY_SIZE);
        int pubPtr = allocate(X25519_PUBLIC_KEY_SIZE);

        try {
            Value[] result = x25519Generate.apply(
                Value.i32(privPtr),
                Value.i32(pubPtr)
            );

            if (result[0].asInt() != 0) {
                throw new RuntimeException(&quot;Key generation failed&quot;);

            return new X25519KeyPair(
                memory.readBytes(privPtr, X25519_PRIVATE_KEY_SIZE),
                memory.readBytes(pubPtr, X25519_PUBLIC_KEY_SIZE)
            );
        } finally {
            free(privPtr);
            free(pubPtr);

    /**
     * Compute X25519 shared secret.
     */
    public byte[] x25519SharedSecret(byte[] privateKey, byte[] publicKey) {
        int privPtr = allocate(privateKey.length);
        int pubPtr = allocate(publicKey.length);
        int outPtr = allocate(32);

        try {
            memory.write(privPtr, privateKey);
            memory.write(pubPtr, publicKey);

            Value[] result = x25519Shared.apply(
                Value.i32(privPtr),
                Value.i32(pubPtr),
                Value.i32(outPtr)
            );

            if (result[0].asInt() != 0) {
                throw new RuntimeException(&quot;Shared secret computation failed&quot;);

            return memory.readBytes(outPtr, 32);
        } finally {
            free(privPtr);
            free(pubPtr);
            free(outPtr);

    // Ed25519 Signatures

    /**
     * Generate Ed25519 key pair.
     */
    public Ed25519KeyPair ed25519GenerateKeyPair() {
        int privPtr = allocate(ED25519_PRIVATE_KEY_SIZE);
        int pubPtr = allocate(ED25519_PUBLIC_KEY_SIZE);

        try {
            Value[] result = ed25519Generate.apply(
                Value.i32(privPtr),
                Value.i32(pubPtr)
            );

            if (result[0].asInt() != 0) {
                throw new RuntimeException(&quot;Key generation failed&quot;);

            return new Ed25519KeyPair(
                memory.readBytes(privPtr, ED25519_PRIVATE_KEY_SIZE),
                memory.readBytes(pubPtr, ED25519_PUBLIC_KEY_SIZE)
            );
        } finally {
            free(privPtr);
            free(pubPtr);

    /**
     * Sign with Ed25519.
     */
    public byte[] ed25519Sign(byte[] privateKey, byte[] message) {
        int privPtr = allocate(privateKey.length);
        int msgPtr = allocate(message.length);
        int sigPtr = allocate(ED25519_SIGNATURE_SIZE);

        try {
            memory.write(privPtr, privateKey);
            memory.write(msgPtr, message);

            Value[] result = ed25519Sign.apply(
                Value.i32(privPtr),
                Value.i32(msgPtr),
                Value.i32(message.length),
                Value.i32(sigPtr)
            );

            if (result[0].asInt() != 0) {
                throw new RuntimeException(&quot;Signing failed&quot;);

            return memory.readBytes(sigPtr, ED25519_SIGNATURE_SIZE);
        } finally {
            free(privPtr);
            free(msgPtr);
            free(sigPtr);

    /**
     * Verify Ed25519 signature.
     */
    public boolean ed25519Verify(byte[] publicKey, byte[] message, byte[] signature) {
        int pubPtr = allocate(publicKey.length);
        int msgPtr = allocate(message.length);
        int sigPtr = allocate(signature.length);

        try {
            memory.write(pubPtr, publicKey);
            memory.write(msgPtr, message);
            memory.write(sigPtr, signature);

            Value[] result = ed25519Verify.apply(
                Value.i32(pubPtr),
                Value.i32(msgPtr),
                Value.i32(message.length),
                Value.i32(sigPtr)
            );

            return result[0].asInt() == 0;
        } finally {
            free(pubPtr);
            free(msgPtr);
            free(sigPtr);

    // Helpers

    private int allocate(int size) {
        Value[] result = malloc.apply(Value.i32(size));
        int ptr = result[0].asInt();
        if (ptr == 0) {
            throw new OutOfMemoryError(&quot;WASM malloc returned null&quot;);
        return ptr;

    private void free(int ptr) {
        free.apply(Value.i32(ptr));

    @Override
    public void close() {
        // Chicory handles cleanup automatically
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>Template Project Structure</h2>
<pre><code>myproject/
├── pom.xml
├── src/
│   └── main/
│       ├── java/
│       │   └── com/example/
│       │       ├── Main.java
│       │       └── encryption/
│       │           └── EncryptionModule.java
│       └── resources/
│           └── flatc-encryption.wasm
└── src/
    └── test/
        └── java/
            └── com/example/
                └── EncryptionTest.java
</code></pre>
<p><strong>pom.xml:</strong></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.example&lt;/groupId&gt;
    &lt;artifactId&gt;flatbuffers-encryption&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.dylibso.chicory&lt;/groupId&gt;
            &lt;artifactId&gt;runtime&lt;/artifactId&gt;
            &lt;version&gt;1.5.3&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
            &lt;version&gt;5.10.0&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Usage Examples</h2>
<h3>Basic Encryption</h3>
<pre><code class="language-java">var module = EncryptionModule.fromFile(&quot;flatc-encryption.wasm&quot;);

SecureRandom random = new SecureRandom();
byte[] key = new byte[32];
byte[] iv = new byte[16];
random.nextBytes(key);
random.nextBytes(iv);

byte[] plaintext = &quot;Secret message&quot;.getBytes();
byte[] ciphertext = module.encrypt(key, iv, plaintext);
byte[] decrypted = module.decrypt(key, iv, ciphertext);

assert Arrays.equals(plaintext, decrypted);
</code></pre>
<h3>End-to-End Encryption</h3>
<pre><code class="language-java">var module = EncryptionModule.fromFile(&quot;flatc-encryption.wasm&quot;);

// Generate key pairs
var alice = module.x25519GenerateKeyPair();
var bob = module.x25519GenerateKeyPair();

// Compute shared secrets
byte[] aliceShared = module.x25519SharedSecret(alice.privateKey(), bob.publicKey());
byte[] bobShared = module.x25519SharedSecret(bob.privateKey(), alice.publicKey());

assert Arrays.equals(aliceShared, bobShared);

// Derive encryption key
byte[] encryptionKey = module.hkdf(aliceShared, null, &quot;encryption-v1&quot;.getBytes(), 32);

// Encrypt message
byte[] iv = new byte[16];
new SecureRandom().nextBytes(iv);
byte[] ciphertext = module.encrypt(encryptionKey, iv, &quot;Hello Bob!&quot;.getBytes());

// Decrypt
byte[] decrypted = module.decrypt(encryptionKey, iv, ciphertext);
System.out.println(new String(decrypted)); // &quot;Hello Bob!&quot;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg></span>Performance Tips</h2>
<ol>
<li><strong>Reuse module instances</strong> - Module loading is expensive</li>
<li><strong>Use try-with-resources</strong> - Ensures proper cleanup</li>
<li><strong>Consider thread safety</strong> - Chicory instances are not thread-safe</li>
</ol>
<pre><code class="language-java">// Good: Reuse instance
var module = EncryptionModule.fromFile(&quot;wasm&quot;);
for (var item : items) {
    module.encrypt(key, iv, item);

// Bad: Create new instance each time
for (var item : items) {
    var module = EncryptionModule.fromFile(&quot;wasm&quot;); // Slow!
    module.encrypt(key, iv, item);
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg></span>Troubleshooting</h2>
<h3>"Function not found"</h3>
<p>Check that you&#39;re using the correct export names (wasi_* prefix).</p>
<h3>"Memory access out of bounds"</h3>
<p>Ensure allocated memory is valid:</p>
<pre><code class="language-java">int ptr = allocate(size);
if (ptr == 0) {
    throw new RuntimeException(&quot;Allocation failed&quot;);
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg></span>See Also</h2>
<ul>
<li><a href="https://github.com/nickmccoll/chicory">Chicory Documentation</a></li>
<li><a href="README.html#api-reference">API Reference</a></li>
<li><a href="README.html#security-considerations">Security Considerations</a></li>
</ul>
</article>
  </div>

  <script>
    // Initialize video with random selection
    const videoUrls = [
      "../videos/bg-1.mp4",
      "../videos/bg-2.mp4",
      "../videos/bg-3.mp4",
      "../videos/bg-4.mp4",
      "../videos/bg-5.mp4",
      "../videos/bg-6.mp4",
      "../videos/bg-7.mp4",
      "../videos/bg-8.mp4",
      "../videos/bg-9.mp4",
      "../videos/bg-10.mp4",
      "../videos/bg-11.mp4"
    ];

    const video = document.getElementById('bg-video');
    video.src = videoUrls[Math.floor(Math.random() * videoUrls.length)];
  </script>
</body>
</html>