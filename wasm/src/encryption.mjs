/**
 * @module encryption
 *
 * FlatBuffers field-level encryption using Crypto++ via WASM.
 * All cryptographic operations are performed by the flatc-encryption.wasm module
 * compiled from C++ with Crypto++.
 *
 * Features:
 * - AES-256-CTR symmetric encryption
 * - X25519 ECDH key exchange
 * - secp256k1 ECDH and ECDSA (Bitcoin/Ethereum compatible)
 * - P-256 ECDH and ECDSA (NIST)
 * - Ed25519 signatures
 * - HKDF-SHA256 key derivation
 */

// WASM module instance (set by initEncryption)
let wasmModule = null;
let wasmMemory = null;

// Cached encoder/decoder instances for performance
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

// Key sizes
export const KEY_SIZE = 32;
export const IV_SIZE = 16;
export const SHA256_SIZE = 32;
export const X25519_PRIVATE_KEY_SIZE = 32;
export const X25519_PUBLIC_KEY_SIZE = 32;
export const SECP256K1_PRIVATE_KEY_SIZE = 32;
export const SECP256K1_PUBLIC_KEY_SIZE = 33;
export const P256_PRIVATE_KEY_SIZE = 32;
export const P256_PUBLIC_KEY_SIZE = 33;
export const ED25519_PRIVATE_KEY_SIZE = 64;
export const ED25519_PUBLIC_KEY_SIZE = 32;
export const ED25519_SIGNATURE_SIZE = 64;

/**
 * Initialize the encryption module with WASM
 * @param {WebAssembly.Instance} instance - The flatc-encryption.wasm instance
 */
export function initEncryption(instance) {
  wasmModule = instance.exports;
  wasmMemory = wasmModule.memory;
  // Call _initialize if it exists (WASI startup)
  if (wasmModule._initialize) {
    wasmModule._initialize();
  }
}

/**
 * Load and initialize the encryption WASM module
 * @param {string|URL|Uint8Array|ArrayBuffer} wasmSource - Path to WASM file, URL, or binary data
 * @returns {Promise<void>}
 */
export async function loadEncryptionWasm(wasmSource) {
  let wasmBytes;

  if (wasmSource instanceof Uint8Array || wasmSource instanceof ArrayBuffer) {
    wasmBytes = wasmSource;
  } else if (typeof wasmSource === 'string' || wasmSource instanceof URL) {
    // In Node.js, use fs to read the file
    if (typeof process !== 'undefined' && process.versions?.node) {
      const { readFileSync } = await import('fs');
      const { fileURLToPath } = await import('url');
      const path = wasmSource instanceof URL ? fileURLToPath(wasmSource) : wasmSource;
      wasmBytes = readFileSync(path);
    } else {
      // In browser, use fetch
      const response = await fetch(wasmSource);
      wasmBytes = await response.arrayBuffer();
    }
  } else {
    throw new Error('Invalid WASM source: must be a path, URL, or binary data');
  }

  // Exception handling state
  let threwValue = 0;
  let exceptionPtr = 0;

  // Helper to call a WASM function with exception handling
  function invoke(fn, ...args) {
    try {
      return fn(...args);
    } catch (e) {
      // Set exception state
      threwValue = 1;
      return 0;
    }
  }

  // WASI and env imports required by the encryption module
  const imports = {
    wasi_snapshot_preview1: {
      // Clock
      clock_time_get: (clockId, precision, resultPtr) => {
        const now = BigInt(Date.now()) * 1000000n;
        const view = new DataView(wasmMemory.buffer);
        view.setBigUint64(resultPtr, now, true);
        return 0;
      },
      // Environment
      environ_sizes_get: (countPtr, sizePtr) => {
        const view = new DataView(wasmMemory.buffer);
        view.setUint32(countPtr, 0, true);
        view.setUint32(sizePtr, 0, true);
        return 0;
      },
      environ_get: () => 0,
      // File descriptors
      fd_write: () => 0,
      fd_read: () => 0,
      fd_close: () => 0,
      fd_seek: () => 0,
    },
    env: {
      // Exception handling for Emscripten
      __cxa_throw: (ptr, type, destructor) => {
        exceptionPtr = ptr;
        throw new Error('C++ exception');
      },
      __cxa_begin_catch: (ptr) => ptr,
      __cxa_end_catch: () => {},
      __cxa_find_matching_catch_2: () => {
        return exceptionPtr;
      },
      __cxa_find_matching_catch_3: () => {
        return exceptionPtr;
      },
      __cxa_uncaught_exceptions: () => 0,
      __resumeException: (ptr) => {
        throw new Error('Resumed C++ exception');
      },
      llvm_eh_typeid_for: (type) => type,

      // Invoke wrappers for exception-safe calls
      // These are generated by Emscripten to wrap function calls that might throw
      invoke_v: (fn) => invoke(() => wasmModule.__indirect_function_table.get(fn)()),
      invoke_i: (fn) => invoke(() => wasmModule.__indirect_function_table.get(fn)()),
      invoke_ii: (fn, a) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a)),
      invoke_iii: (fn, a, b) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b)),
      invoke_iiii: (fn, a, b, c) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c)),
      invoke_iiiii: (fn, a, b, c, d) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c, d)),
      invoke_iiiiii: (fn, a, b, c, d, e) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c, d, e)),
      invoke_iiiiiii: (fn, a, b, c, d, e, f) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c, d, e, f)),
      invoke_iiiiiiii: (fn, a, b, c, d, e, f, g) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c, d, e, f, g)),
      invoke_iiiiiiiiii: (fn, a, b, c, d, e, f, g, h, i) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c, d, e, f, g, h, i)),
      invoke_vi: (fn, a) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a)),
      invoke_vii: (fn, a, b) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b)),
      invoke_viii: (fn, a, b, c) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c)),
      invoke_viiii: (fn, a, b, c, d) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c, d)),
      invoke_viiiii: (fn, a, b, c, d, e) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c, d, e)),
      invoke_viiiiii: (fn, a, b, c, d, e, f) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c, d, e, f)),
      invoke_viiiiiii: (fn, a, b, c, d, e, f, g) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c, d, e, f, g)),
      invoke_viiiiiiiii: (fn, a, b, c, d, e, f, g, h, i) => invoke(() => wasmModule.__indirect_function_table.get(fn)(a, b, c, d, e, f, g, h, i)),
    }
  };

  // Compile and instantiate
  const { instance } = await WebAssembly.instantiate(wasmBytes, imports);

  // Store memory reference before initializing
  wasmMemory = instance.exports.memory;

  // Initialize
  initEncryption(instance);
}

/**
 * Check if encryption module is initialized
 * @returns {boolean}
 */
export function isInitialized() {
  return wasmModule !== null;
}

/**
 * Check if Crypto++ is available in the WASM module
 * @returns {boolean}
 */
export function hasCryptopp() {
  if (!wasmModule || !wasmModule.wasi_has_cryptopp) return false;
  return wasmModule.wasi_has_cryptopp() === 1;
}

/**
 * Get the WASM module version
 * @returns {string}
 */
export function getVersion() {
  if (!wasmModule || !wasmModule.wasi_get_version) return 'unknown';
  const ptr = wasmModule.wasi_get_version();
  return readString(ptr);
}

// =============================================================================
// Memory helpers
// =============================================================================

function readString(ptr, maxLen = 32) {
  if (!wasmMemory) throw new Error('WASM memory not initialized');
  if (ptr < 0 || ptr >= wasmMemory.buffer.byteLength) {
    throw new Error(`Invalid pointer: ${ptr} (memory size: ${wasmMemory.buffer.byteLength})`);
  }
  const safeLen = Math.min(maxLen, wasmMemory.buffer.byteLength - ptr);
  const view = new Uint8Array(wasmMemory.buffer, ptr, safeLen);
  let end = view.indexOf(0);
  if (end === -1) end = safeLen;
  return textDecoder.decode(view.subarray(0, end));
}

// Cached Node.js crypto module (lazy-loaded)
let nodeCryptoModule = null;

/**
 * Get cryptographically secure random bytes (works in Node.js and browser)
 * @param {number} size - Number of random bytes
 * @returns {Uint8Array}
 * @throws {Error} If no cryptographic random source is available
 */
function getRandomBytes(size) {
  if (size <= 0) {
    throw new Error('Size must be a positive integer');
  }

  // Browser environment - check for SecureContext
  if (typeof globalThis.crypto !== 'undefined' && globalThis.crypto.getRandomValues) {
    try {
      return globalThis.crypto.getRandomValues(new Uint8Array(size));
    } catch (e) {
      // getRandomValues may fail if not in a secure context
      throw new Error(`crypto.getRandomValues failed: ${e.message}. Ensure you are in a secure context (HTTPS).`);
    }
  }

  // Node.js environment - use cached module
  if (typeof process !== 'undefined' && process.versions?.node) {
    if (!nodeCryptoModule) {
      // Node.js has crypto as a built-in, access via globalThis or lazy import
      // In Node.js 18+, crypto is available on globalThis
      if (globalThis.crypto?.randomBytes) {
        nodeCryptoModule = globalThis.crypto;
      } else {
        // Fallback: use Function constructor to avoid static analysis of require
        // This is necessary because we're in an ESM module
        try {
          // eslint-disable-next-line no-new-func
          nodeCryptoModule = new Function('return require("crypto")')();
        } catch {
          throw new Error('Node.js crypto module not available');
        }
      }
    }
    return new Uint8Array(nodeCryptoModule.randomBytes(size));
  }

  throw new Error('No cryptographic random source available. Use a modern browser with HTTPS or Node.js 18+.');
}

/**
 * Allocate memory in WASM heap
 * @param {number} size - Number of bytes to allocate
 * @returns {number} Pointer to allocated memory
 * @throws {Error} If allocation fails or module not initialized
 */
function allocate(size) {
  if (!wasmModule) throw new Error('Encryption module not initialized. Call loadEncryptionWasm() first.');
  if (size <= 0) throw new Error(`Invalid allocation size: ${size}`);
  const ptr = wasmModule.malloc(size);
  if (ptr === 0) throw new Error(`Memory allocation failed for ${size} bytes`);
  return ptr;
}

/**
 * Securely deallocate memory by zeroing it first.
 * This prevents sensitive data (keys, plaintext) from remaining in freed memory.
 * @param {number} ptr - Pointer to memory
 * @param {number} size - Size of memory to clear before freeing
 */
function secureDeallocate(ptr, size) {
  if (ptr !== 0 && wasmMemory) {
    // Zero-fill the memory before freeing to prevent data leakage
    try {
      const view = new Uint8Array(wasmMemory.buffer, ptr, size);
      view.fill(0);
    } catch {
      // Memory may already be invalid, continue with free
    }
    wasmModule.free(ptr);
  }
}

/**
 * Deallocate memory (non-secure, for non-sensitive data)
 * @param {number} ptr - Pointer to memory
 */
function deallocate(ptr) {
  if (ptr !== 0) wasmModule.free(ptr);
}

/**
 * Write bytes to WASM memory with bounds checking
 * @param {number} ptr - Destination pointer
 * @param {Uint8Array} data - Data to write
 * @throws {Error} If write would exceed memory bounds
 */
function writeBytes(ptr, data) {
  if (!wasmMemory) throw new Error('WASM memory not initialized');
  if (ptr < 0) throw new Error(`Invalid pointer: ${ptr}`);

  const memSize = wasmMemory.buffer.byteLength;
  if (ptr + data.length > memSize) {
    throw new Error(`Memory write overflow: ptr=${ptr}, size=${data.length}, memSize=${memSize}`);
  }

  new Uint8Array(wasmMemory.buffer, ptr, data.length).set(data);
}

/**
 * Read bytes from WASM memory with bounds checking
 * @param {number} ptr - Source pointer
 * @param {number} size - Number of bytes to read
 * @returns {Uint8Array} Copy of the data
 * @throws {Error} If read would exceed memory bounds
 */
function readBytes(ptr, size) {
  if (!wasmMemory) throw new Error('WASM memory not initialized');
  if (ptr < 0) throw new Error(`Invalid pointer: ${ptr}`);
  if (size < 0) throw new Error(`Invalid size: ${size}`);

  const memSize = wasmMemory.buffer.byteLength;
  if (ptr + size > memSize) {
    throw new Error(`Memory read overflow: ptr=${ptr}, size=${size}, memSize=${memSize}`);
  }

  return new Uint8Array(wasmMemory.buffer, ptr, size).slice();
}

// =============================================================================
// SHA-256
// =============================================================================

/**
 * Compute SHA-256 hash
 * @param {Uint8Array} data - Data to hash
 * @returns {Uint8Array} - 32-byte hash
 */
export function sha256(data) {
  if (!wasmModule) throw new Error('Encryption module not initialized');

  const dataPtr = allocate(data.length);
  const hashPtr = allocate(SHA256_SIZE);

  try {
    writeBytes(dataPtr, data);
    wasmModule.wasi_sha256(dataPtr, data.length, hashPtr);
    return readBytes(hashPtr, SHA256_SIZE);
  } finally {
    secureDeallocate(dataPtr, data.length);
    deallocate(hashPtr);
  }
}

// =============================================================================
// AES-256-CTR Encryption
// =============================================================================

/**
 * Encrypt data in-place using AES-256-CTR
 * @param {Uint8Array} data - Data to encrypt (modified in-place)
 * @param {Uint8Array} key - 32-byte key
 * @param {Uint8Array} iv - 16-byte IV
 */
export function encryptBytes(data, key, iv) {
  if (!wasmModule) throw new Error('Encryption module not initialized');
  if (!(data instanceof Uint8Array)) throw new Error('Data must be a Uint8Array');
  if (!(key instanceof Uint8Array)) throw new Error('Key must be a Uint8Array');
  if (!(iv instanceof Uint8Array)) throw new Error('IV must be a Uint8Array');
  if (key.length !== KEY_SIZE) throw new Error(`Key must be ${KEY_SIZE} bytes, got ${key.length}`);
  if (iv.length !== IV_SIZE) throw new Error(`IV must be ${IV_SIZE} bytes, got ${iv.length}`);
  if (data.length === 0) return; // Nothing to encrypt - data is unchanged

  const keyPtr = allocate(KEY_SIZE);
  const ivPtr = allocate(IV_SIZE);
  const dataPtr = allocate(data.length);

  try {
    writeBytes(keyPtr, key);
    writeBytes(ivPtr, iv);
    writeBytes(dataPtr, data);

    const result = wasmModule.wasi_encrypt_bytes(keyPtr, ivPtr, dataPtr, data.length);
    if (result !== 0) throw new Error('Encryption failed');

    data.set(readBytes(dataPtr, data.length));
  } finally {
    // Securely clear sensitive data (key, IV, plaintext/ciphertext)
    secureDeallocate(keyPtr, KEY_SIZE);
    secureDeallocate(ivPtr, IV_SIZE);
    secureDeallocate(dataPtr, data.length);
  }
}

/**
 * Decrypt data in-place using AES-256-CTR
 * Same as encryptBytes (CTR mode is symmetric)
 */
export const decryptBytes = encryptBytes;

// =============================================================================
// HKDF Key Derivation
// =============================================================================

/**
 * Derive key using HKDF-SHA256
 * @param {Uint8Array} ikm - Input key material
 * @param {Uint8Array|null} salt - Optional salt
 * @param {Uint8Array|null} info - Optional context info
 * @param {number} length - Output length
 * @returns {Uint8Array}
 */
export function hkdf(ikm, salt, info, length) {
  if (!wasmModule) throw new Error('Encryption module not initialized');

  const ikmPtr = allocate(ikm.length);
  const saltPtr = salt ? allocate(salt.length) : 0;
  const infoPtr = info ? allocate(info.length) : 0;
  const okmPtr = allocate(length);

  try {
    writeBytes(ikmPtr, ikm);
    if (salt) writeBytes(saltPtr, salt);
    if (info) writeBytes(infoPtr, info);

    wasmModule.wasi_hkdf(
      ikmPtr, ikm.length,
      saltPtr, salt ? salt.length : 0,
      infoPtr, info ? info.length : 0,
      okmPtr, length
    );

    return readBytes(okmPtr, length);
  } finally {
    // Securely clear input key material and derived key
    secureDeallocate(ikmPtr, ikm.length);
    if (saltPtr) secureDeallocate(saltPtr, salt.length);
    if (infoPtr) deallocate(infoPtr); // info is not sensitive
    secureDeallocate(okmPtr, length);
  }
}

// =============================================================================
// X25519 Key Exchange
// =============================================================================

/**
 * Generate X25519 key pair
 * @param {Uint8Array} [privateKey] - Optional 32-byte private key (generates random if not provided)
 * @returns {{privateKey: Uint8Array, publicKey: Uint8Array}}
 */
export function x25519GenerateKeyPair(privateKey) {
  if (!wasmModule) throw new Error('Encryption module not initialized');
  if (privateKey && privateKey.length !== X25519_PRIVATE_KEY_SIZE) {
    throw new Error(`Private key must be ${X25519_PRIVATE_KEY_SIZE} bytes`);
  }

  const privPtr = allocate(X25519_PRIVATE_KEY_SIZE);
  const pubPtr = allocate(X25519_PUBLIC_KEY_SIZE);

  try {
    if (privateKey) {
      writeBytes(privPtr, privateKey);
    }

    const result = wasmModule.wasi_x25519_generate_keypair(privPtr, pubPtr);
    if (result !== 0) throw new Error('X25519 key generation failed');

    return {
      privateKey: readBytes(privPtr, X25519_PRIVATE_KEY_SIZE),
      publicKey: readBytes(pubPtr, X25519_PUBLIC_KEY_SIZE),
    };
  } finally {
    secureDeallocate(privPtr, X25519_PRIVATE_KEY_SIZE);
    deallocate(pubPtr);
  }
}

/**
 * Compute X25519 shared secret
 * @param {Uint8Array} privateKey - Our private key (32 bytes)
 * @param {Uint8Array} publicKey - Their public key (32 bytes)
 * @returns {Uint8Array} - 32-byte shared secret
 */
export function x25519SharedSecret(privateKey, publicKey) {
  if (!wasmModule) throw new Error('Encryption module not initialized');
  if (privateKey.length !== X25519_PRIVATE_KEY_SIZE) {
    throw new Error(`Private key must be ${X25519_PRIVATE_KEY_SIZE} bytes`);
  }
  if (publicKey.length !== X25519_PUBLIC_KEY_SIZE) {
    throw new Error(`Public key must be ${X25519_PUBLIC_KEY_SIZE} bytes`);
  }

  const privPtr = allocate(X25519_PRIVATE_KEY_SIZE);
  const pubPtr = allocate(X25519_PUBLIC_KEY_SIZE);
  const secretPtr = allocate(KEY_SIZE);

  try {
    writeBytes(privPtr, privateKey);
    writeBytes(pubPtr, publicKey);

    const result = wasmModule.wasi_x25519_shared_secret(privPtr, pubPtr, secretPtr);
    if (result !== 0) throw new Error('X25519 ECDH failed');

    return readBytes(secretPtr, KEY_SIZE);
  } finally {
    secureDeallocate(privPtr, X25519_PRIVATE_KEY_SIZE);
    deallocate(pubPtr);
    secureDeallocate(secretPtr, KEY_SIZE);
  }
}

/**
 * Derive symmetric key from X25519 shared secret
 * @param {Uint8Array} sharedSecret - ECDH shared secret
 * @param {Uint8Array|string} context - Context for key derivation
 * @returns {Uint8Array} - 32-byte symmetric key
 */
export function x25519DeriveKey(sharedSecret, context) {
  const info = typeof context === 'string'
    ? textEncoder.encode(context)
    : context;
  return hkdf(sharedSecret, null, info, KEY_SIZE);
}

// =============================================================================
// secp256k1 Key Exchange and Signatures (Bitcoin/Ethereum)
// =============================================================================

/**
 * Generate secp256k1 key pair
 * @param {Uint8Array} [privateKey] - Optional 32-byte private key
 * @returns {{privateKey: Uint8Array, publicKey: Uint8Array}}
 */
export function secp256k1GenerateKeyPair(privateKey) {
  if (!wasmModule) throw new Error('Encryption module not initialized');
  if (privateKey && privateKey.length !== SECP256K1_PRIVATE_KEY_SIZE) {
    throw new Error(`Private key must be ${SECP256K1_PRIVATE_KEY_SIZE} bytes`);
  }

  const privPtr = allocate(SECP256K1_PRIVATE_KEY_SIZE);
  const pubPtr = allocate(SECP256K1_PUBLIC_KEY_SIZE);

  try {
    if (privateKey) {
      writeBytes(privPtr, privateKey);
    }

    const result = wasmModule.wasi_secp256k1_generate_keypair(privPtr, pubPtr);
    if (result !== 0) throw new Error('secp256k1 key generation failed');

    return {
      privateKey: readBytes(privPtr, SECP256K1_PRIVATE_KEY_SIZE),
      publicKey: readBytes(pubPtr, SECP256K1_PUBLIC_KEY_SIZE),
    };
  } finally {
    secureDeallocate(privPtr, SECP256K1_PRIVATE_KEY_SIZE);
    deallocate(pubPtr);
  }
}

/**
 * Compute secp256k1 ECDH shared secret
 * @param {Uint8Array} privateKey - Our private key (32 bytes)
 * @param {Uint8Array} publicKey - Their public key (33 bytes compressed)
 * @returns {Uint8Array} - 32-byte shared secret
 */
export function secp256k1SharedSecret(privateKey, publicKey) {
  if (!wasmModule) throw new Error('Encryption module not initialized');
  if (privateKey.length !== SECP256K1_PRIVATE_KEY_SIZE) {
    throw new Error(`Private key must be ${SECP256K1_PRIVATE_KEY_SIZE} bytes`);
  }
  if (publicKey.length !== SECP256K1_PUBLIC_KEY_SIZE) {
    throw new Error(`Public key must be ${SECP256K1_PUBLIC_KEY_SIZE} bytes (compressed)`);
  }

  const privPtr = allocate(SECP256K1_PRIVATE_KEY_SIZE);
  const pubPtr = allocate(publicKey.length);
  const secretPtr = allocate(KEY_SIZE);

  try {
    writeBytes(privPtr, privateKey);
    writeBytes(pubPtr, publicKey);

    const result = wasmModule.wasi_secp256k1_shared_secret(
      privPtr, pubPtr, publicKey.length, secretPtr
    );
    if (result !== 0) throw new Error('secp256k1 ECDH failed');

    return readBytes(secretPtr, KEY_SIZE);
  } finally {
    secureDeallocate(privPtr, SECP256K1_PRIVATE_KEY_SIZE);
    deallocate(pubPtr);
    secureDeallocate(secretPtr, KEY_SIZE);
  }
}

/**
 * Derive symmetric key from secp256k1 shared secret
 */
export function secp256k1DeriveKey(sharedSecret, context) {
  const info = typeof context === 'string'
    ? textEncoder.encode(context)
    : context;
  return hkdf(sharedSecret, null, info, KEY_SIZE);
}

/**
 * Sign data with secp256k1 ECDSA
 * @param {Uint8Array} privateKey - Signing private key (32 bytes)
 * @param {Uint8Array} data - Data to sign
 * @returns {Uint8Array} - Signature (DER encoded)
 */
export function secp256k1Sign(privateKey, data) {
  if (!wasmModule) throw new Error('Encryption module not initialized');
  if (privateKey.length !== SECP256K1_PRIVATE_KEY_SIZE) {
    throw new Error(`Private key must be ${SECP256K1_PRIVATE_KEY_SIZE} bytes`);
  }

  const privPtr = allocate(SECP256K1_PRIVATE_KEY_SIZE);
  const dataPtr = allocate(data.length);
  const sigPtr = allocate(72); // Max DER signature size
  const sigSizePtr = allocate(4);

  try {
    writeBytes(privPtr, privateKey);
    writeBytes(dataPtr, data);

    const result = wasmModule.wasi_secp256k1_sign(
      privPtr, dataPtr, data.length, sigPtr, sigSizePtr
    );
    if (result !== 0) throw new Error('secp256k1 signing failed');

    const sigSize = new DataView(wasmMemory.buffer).getUint32(sigSizePtr, true);
    return readBytes(sigPtr, sigSize);
  } finally {
    secureDeallocate(privPtr, SECP256K1_PRIVATE_KEY_SIZE);
    deallocate(dataPtr);
    deallocate(sigPtr);
    deallocate(sigSizePtr);
  }
}

/**
 * Verify secp256k1 ECDSA signature
 * @param {Uint8Array} publicKey - Verification public key (33 bytes)
 * @param {Uint8Array} data - Original data
 * @param {Uint8Array} signature - Signature to verify
 * @returns {boolean} - True if valid
 */
export function secp256k1Verify(publicKey, data, signature) {
  if (!wasmModule) throw new Error('Encryption module not initialized');

  const pubPtr = allocate(publicKey.length);
  const dataPtr = allocate(data.length);
  const sigPtr = allocate(signature.length);

  try {
    writeBytes(pubPtr, publicKey);
    writeBytes(dataPtr, data);
    writeBytes(sigPtr, signature);

    const result = wasmModule.wasi_secp256k1_verify(
      pubPtr, publicKey.length,
      dataPtr, data.length,
      sigPtr, signature.length
    );
    return result === 0;
  } finally {
    deallocate(pubPtr);
    deallocate(dataPtr);
    deallocate(sigPtr);
  }
}

// =============================================================================
// P-256 Key Exchange and Signatures (NIST)
// =============================================================================

/**
 * Generate P-256 key pair
 * @param {Uint8Array} [privateKey] - Optional 32-byte private key
 * @returns {{privateKey: Uint8Array, publicKey: Uint8Array}}
 */
export function p256GenerateKeyPair(privateKey) {
  if (!wasmModule) throw new Error('Encryption module not initialized');
  if (privateKey && privateKey.length !== P256_PRIVATE_KEY_SIZE) {
    throw new Error(`Private key must be ${P256_PRIVATE_KEY_SIZE} bytes`);
  }

  const privPtr = allocate(P256_PRIVATE_KEY_SIZE);
  const pubPtr = allocate(P256_PUBLIC_KEY_SIZE);

  try {
    if (privateKey) {
      writeBytes(privPtr, privateKey);
    }

    const result = wasmModule.wasi_p256_generate_keypair(privPtr, pubPtr);
    if (result !== 0) throw new Error('P-256 key generation failed');

    return {
      privateKey: readBytes(privPtr, P256_PRIVATE_KEY_SIZE),
      publicKey: readBytes(pubPtr, P256_PUBLIC_KEY_SIZE),
    };
  } finally {
    secureDeallocate(privPtr, P256_PRIVATE_KEY_SIZE);
    deallocate(pubPtr);
  }
}

/**
 * Compute P-256 ECDH shared secret
 * @param {Uint8Array} privateKey - Our private key (32 bytes)
 * @param {Uint8Array} publicKey - Their public key (33 bytes compressed)
 * @returns {Uint8Array} - 32-byte shared secret
 */
export function p256SharedSecret(privateKey, publicKey) {
  if (!wasmModule) throw new Error('Encryption module not initialized');
  if (privateKey.length !== P256_PRIVATE_KEY_SIZE) {
    throw new Error(`Private key must be ${P256_PRIVATE_KEY_SIZE} bytes`);
  }
  if (publicKey.length !== P256_PUBLIC_KEY_SIZE) {
    throw new Error(`Public key must be ${P256_PUBLIC_KEY_SIZE} bytes (compressed)`);
  }

  const privPtr = allocate(P256_PRIVATE_KEY_SIZE);
  const pubPtr = allocate(publicKey.length);
  const secretPtr = allocate(KEY_SIZE);

  try {
    writeBytes(privPtr, privateKey);
    writeBytes(pubPtr, publicKey);

    const result = wasmModule.wasi_p256_shared_secret(
      privPtr, pubPtr, publicKey.length, secretPtr
    );
    if (result !== 0) throw new Error('P-256 ECDH failed');

    return readBytes(secretPtr, KEY_SIZE);
  } finally {
    secureDeallocate(privPtr, P256_PRIVATE_KEY_SIZE);
    deallocate(pubPtr);
    secureDeallocate(secretPtr, KEY_SIZE);
  }
}

/**
 * Derive symmetric key from P-256 shared secret
 */
export function p256DeriveKey(sharedSecret, context) {
  const info = typeof context === 'string'
    ? textEncoder.encode(context)
    : context;
  return hkdf(sharedSecret, null, info, KEY_SIZE);
}

/**
 * Sign data with P-256 ECDSA
 * @param {Uint8Array} privateKey - Signing private key (32 bytes)
 * @param {Uint8Array} data - Data to sign
 * @returns {Uint8Array} - Signature (DER encoded)
 */
export function p256Sign(privateKey, data) {
  if (!wasmModule) throw new Error('Encryption module not initialized');
  if (privateKey.length !== P256_PRIVATE_KEY_SIZE) {
    throw new Error(`Private key must be ${P256_PRIVATE_KEY_SIZE} bytes`);
  }

  const privPtr = allocate(P256_PRIVATE_KEY_SIZE);
  const dataPtr = allocate(data.length);
  const sigPtr = allocate(72); // Max DER signature size
  const sigSizePtr = allocate(4);

  try {
    writeBytes(privPtr, privateKey);
    writeBytes(dataPtr, data);

    const result = wasmModule.wasi_p256_sign(
      privPtr, dataPtr, data.length, sigPtr, sigSizePtr
    );
    if (result !== 0) throw new Error('P-256 signing failed');

    const sigSize = new DataView(wasmMemory.buffer).getUint32(sigSizePtr, true);
    return readBytes(sigPtr, sigSize);
  } finally {
    secureDeallocate(privPtr, P256_PRIVATE_KEY_SIZE);
    deallocate(dataPtr);
    deallocate(sigPtr);
    deallocate(sigSizePtr);
  }
}

/**
 * Verify P-256 ECDSA signature
 * @param {Uint8Array} publicKey - Verification public key (33 bytes)
 * @param {Uint8Array} data - Original data
 * @param {Uint8Array} signature - Signature to verify
 * @returns {boolean} - True if valid
 */
export function p256Verify(publicKey, data, signature) {
  if (!wasmModule) throw new Error('Encryption module not initialized');

  const pubPtr = allocate(publicKey.length);
  const dataPtr = allocate(data.length);
  const sigPtr = allocate(signature.length);

  try {
    writeBytes(pubPtr, publicKey);
    writeBytes(dataPtr, data);
    writeBytes(sigPtr, signature);

    const result = wasmModule.wasi_p256_verify(
      pubPtr, publicKey.length,
      dataPtr, data.length,
      sigPtr, signature.length
    );
    return result === 0;
  } finally {
    deallocate(pubPtr);
    deallocate(dataPtr);
    deallocate(sigPtr);
  }
}

// =============================================================================
// Ed25519 Signatures
// =============================================================================

/**
 * Generate Ed25519 signing key pair
 * @returns {{privateKey: Uint8Array, publicKey: Uint8Array}}
 */
export function ed25519GenerateKeyPair() {
  if (!wasmModule) throw new Error('Encryption module not initialized');

  const privPtr = allocate(ED25519_PRIVATE_KEY_SIZE);
  const pubPtr = allocate(ED25519_PUBLIC_KEY_SIZE);

  try {
    const result = wasmModule.wasi_ed25519_generate_keypair(privPtr, pubPtr);
    if (result !== 0) throw new Error('Ed25519 key generation failed');

    return {
      privateKey: readBytes(privPtr, ED25519_PRIVATE_KEY_SIZE),
      publicKey: readBytes(pubPtr, ED25519_PUBLIC_KEY_SIZE),
    };
  } finally {
    secureDeallocate(privPtr, ED25519_PRIVATE_KEY_SIZE);
    deallocate(pubPtr);
  }
}

/**
 * Sign data with Ed25519
 * @param {Uint8Array} privateKey - Signing private key (64 bytes)
 * @param {Uint8Array} data - Data to sign
 * @returns {Uint8Array} - 64-byte signature
 */
export function ed25519Sign(privateKey, data) {
  if (!wasmModule) throw new Error('Encryption module not initialized');
  if (privateKey.length !== ED25519_PRIVATE_KEY_SIZE) {
    throw new Error(`Private key must be ${ED25519_PRIVATE_KEY_SIZE} bytes`);
  }

  const privPtr = allocate(ED25519_PRIVATE_KEY_SIZE);
  const dataPtr = allocate(data.length);
  const sigPtr = allocate(ED25519_SIGNATURE_SIZE);

  try {
    writeBytes(privPtr, privateKey);
    writeBytes(dataPtr, data);

    const result = wasmModule.wasi_ed25519_sign(
      privPtr, dataPtr, data.length, sigPtr
    );
    if (result !== 0) throw new Error('Ed25519 signing failed');

    return readBytes(sigPtr, ED25519_SIGNATURE_SIZE);
  } finally {
    secureDeallocate(privPtr, ED25519_PRIVATE_KEY_SIZE);
    deallocate(dataPtr);
    deallocate(sigPtr);
  }
}

/**
 * Verify Ed25519 signature
 * @param {Uint8Array} publicKey - Verification public key (32 bytes)
 * @param {Uint8Array} data - Original data
 * @param {Uint8Array} signature - 64-byte signature
 * @returns {boolean} - True if valid
 */
export function ed25519Verify(publicKey, data, signature) {
  if (!wasmModule) throw new Error('Encryption module not initialized');

  const pubPtr = allocate(ED25519_PUBLIC_KEY_SIZE);
  const dataPtr = allocate(data.length);
  const sigPtr = allocate(ED25519_SIGNATURE_SIZE);

  try {
    writeBytes(pubPtr, publicKey);
    writeBytes(dataPtr, data);
    writeBytes(sigPtr, signature);

    const result = wasmModule.wasi_ed25519_verify(
      pubPtr, dataPtr, data.length, sigPtr
    );
    return result === 0;
  } finally {
    deallocate(pubPtr);
    deallocate(dataPtr);
    deallocate(sigPtr);
  }
}

// =============================================================================
// Algorithm Constants (for backward compatibility)
// =============================================================================

export const KeyExchangeAlgorithm = {
  X25519: 'x25519',
  SECP256K1: 'secp256k1',
  P256: 'p256',
};

export const SignatureAlgorithm = {
  ED25519: 'ed25519',
  SECP256K1_ECDSA: 'secp256k1-ecdsa',
  P256_ECDSA: 'p256-ecdsa',
};

export const SymmetricAlgorithm = {
  AES_256_CTR: 'aes-256-ctr',
};

export const KeyDerivationFunction = {
  HKDF_SHA256: 'hkdf-sha256',
};

// =============================================================================
// Encryption Context (field-level key derivation)
// =============================================================================

/**
 * Encryption context for field-level key derivation.
 *
 * WARNING: Methods that encrypt data modify the buffer in-place.
 */
export class EncryptionContext {
  #key;

  /**
   * Create encryption context
   * @param {Uint8Array|string} key - 32-byte master key as Uint8Array or 64-char hex string
   */
  constructor(key) {
    if (typeof key === 'string') {
      // Validate hex string
      if (!/^[0-9a-fA-F]*$/.test(key)) {
        throw new Error('Invalid hex string: must contain only hex characters (0-9, a-f, A-F)');
      }
      if (key.length !== 64) {
        throw new Error(`Invalid hex key length: expected 64 characters (32 bytes), got ${key.length}`);
      }
      // Parse hex string
      const bytes = new Uint8Array(32);
      for (let i = 0; i < 64; i += 2) {
        bytes[i / 2] = parseInt(key.substring(i, i + 2), 16);
      }
      this.#key = bytes;
    } else if (key instanceof Uint8Array) {
      if (key.length !== KEY_SIZE) {
        throw new Error(`Invalid key length: expected ${KEY_SIZE} bytes, got ${key.length}`);
      }
      this.#key = new Uint8Array(key);
    } else {
      throw new Error('Key must be a Uint8Array or 64-character hex string');
    }
  }

  /**
   * Check if context is valid
   * @returns {boolean}
   */
  isValid() {
    return this.#key !== null && this.#key.length === KEY_SIZE;
  }

  /**
   * Create from hex string
   * @param {string} hexKey - 64-character hex string
   * @returns {EncryptionContext}
   */
  static fromHex(hexKey) {
    if (typeof hexKey !== 'string') {
      throw new Error('hexKey must be a string');
    }
    if (!/^[0-9a-fA-F]*$/.test(hexKey)) {
      throw new Error('Invalid hex string: must contain only hex characters (0-9, a-f, A-F)');
    }
    if (hexKey.length !== 64) {
      throw new Error(`Invalid hex key length: expected 64 characters (32 bytes), got ${hexKey.length}`);
    }
    return new EncryptionContext(hexKey);
  }

  /**
   * Derive field-specific key
   * @param {number} fieldId
   * @returns {Uint8Array}
   */
  deriveFieldKey(fieldId) {
    const info = new Uint8Array(19);
    textEncoder.encodeInto('flatbuffers-field', info);
    info[17] = (fieldId >> 8) & 0xff;
    info[18] = fieldId & 0xff;
    return hkdf(this.#key, null, info, KEY_SIZE);
  }

  /**
   * Derive field-specific IV
   * @param {number} fieldId
   * @returns {Uint8Array}
   */
  deriveFieldIV(fieldId) {
    const info = new Uint8Array(16);
    textEncoder.encodeInto('flatbuffers-iv', info);
    info[14] = (fieldId >> 8) & 0xff;
    info[15] = fieldId & 0xff;
    return hkdf(this.#key, null, info, IV_SIZE);
  }

  /**
   * Encrypt scalar value
   * @param {Uint8Array} buffer
   * @param {number} offset
   * @param {number} size
   * @param {number} fieldId
   */
  encryptScalar(buffer, offset, size, fieldId) {
    const key = this.deriveFieldKey(fieldId);
    const iv = this.deriveFieldIV(fieldId);
    const data = buffer.subarray(offset, offset + size);
    encryptBytes(data, key, iv);
  }

  /**
   * Encrypt string value
   * @param {Uint8Array} buffer
   * @param {number} offset
   * @param {number} length
   * @param {number} fieldId
   */
  encryptString(buffer, offset, length, fieldId) {
    const key = this.deriveFieldKey(fieldId);
    const iv = this.deriveFieldIV(fieldId);
    const data = buffer.subarray(offset, offset + length);
    encryptBytes(data, key, iv);
  }

  /**
   * Encrypt vector data
   * @param {Uint8Array} buffer
   * @param {number} offset
   * @param {number} elementSize
   * @param {number} count
   * @param {number} fieldId
   */
  encryptVector(buffer, offset, elementSize, count, fieldId) {
    const key = this.deriveFieldKey(fieldId);
    const iv = this.deriveFieldIV(fieldId);
    const data = buffer.subarray(offset, offset + elementSize * count);
    encryptBytes(data, key, iv);
  }
}

// =============================================================================
// Encryption Header (for hybrid encryption)
// =============================================================================

/**
 * Create encryption header for hybrid encryption
 * @param {Object} options
 * @param {string} options.algorithm - Key exchange algorithm
 * @param {Uint8Array} options.senderPublicKey - Sender's public key
 * @param {Uint8Array} options.recipientKeyId - Recipient key identifier
 * @param {Uint8Array} [options.iv] - Optional IV (generated if not provided)
 * @returns {Object}
 */
export function createEncryptionHeader(options) {
  const iv = options.iv || getRandomBytes(IV_SIZE);
  return {
    version: 1,
    algorithm: options.algorithm,
    senderPublicKey: options.senderPublicKey,
    recipientKeyId: options.recipientKeyId,
    iv,
  };
}

/**
 * Compute key ID from public key (first 8 bytes of SHA-256)
 * @param {Uint8Array} publicKey
 * @returns {Uint8Array} - 8-byte key ID
 */
export function computeKeyId(publicKey) {
  return sha256(publicKey).subarray(0, 8);
}

/**
 * Convert encryption header to JSON
 * @param {Object} header
 * @returns {Object}
 */
export function encryptionHeaderToJSON(header) {
  return {
    version: header.version,
    algorithm: header.algorithm,
    senderPublicKey: Array.from(header.senderPublicKey),
    recipientKeyId: Array.from(header.recipientKeyId),
    iv: Array.from(header.iv),
  };
}

/**
 * Parse encryption header from JSON
 * @param {Object} json
 * @returns {Object}
 */
export function encryptionHeaderFromJSON(json) {
  return {
    version: json.version,
    algorithm: json.algorithm,
    senderPublicKey: new Uint8Array(json.senderPublicKey),
    recipientKeyId: new Uint8Array(json.recipientKeyId),
    iv: new Uint8Array(json.iv),
  };
}

// =============================================================================
// Field-level encryption helpers
// =============================================================================

/**
 * Encrypt scalar in buffer
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @param {number} size
 * @param {EncryptionContext} ctx
 * @param {number} fieldId
 */
export function encryptScalar(buffer, offset, size, ctx, fieldId) {
  ctx.encryptScalar(buffer, offset, size, fieldId);
}

// =============================================================================
// Schema Parsing and Buffer Encryption
// =============================================================================

/**
 * Type sizes for FlatBuffer scalar types
 */
const TYPE_SIZES = {
  bool: 1, byte: 1, ubyte: 1,
  short: 2, ushort: 2,
  int: 4, uint: 4, float: 4,
  long: 8, ulong: 8, double: 8,
};

const SCALAR_TYPES = new Set(Object.keys(TYPE_SIZES));

/**
 * Parse a FlatBuffers schema to extract field encryption info
 * @param {string} schemaContent - FlatBuffers schema content (.fbs)
 * @param {string} rootType - Name of the root type
 * @returns {Object} Parsed schema with encryption metadata
 */
export function parseSchemaForEncryption(schemaContent, rootType) {
  const schema = { fields: [] };

  // Find the table definition
  const tableRegex = new RegExp(`table\\s+${rootType}\\s*\\{([^}]+)\\}`, 's');
  const match = schemaContent.match(tableRegex);
  if (!match) return schema;

  const tableBody = match[1];
  // Match field definitions: name: type (attributes);
  const fieldRegex = /(\w+)\s*:\s*(\[?\w+\]?)\s*(?:\(([^)]*)\))?/g;
  let fieldId = 0;
  let fieldMatch;

  while ((fieldMatch = fieldRegex.exec(tableBody)) !== null) {
    const name = fieldMatch[1];
    const typeStr = fieldMatch[2];
    const attributes = fieldMatch[3] || '';

    const isEncrypted = attributes.includes('encrypted');
    const isVector = typeStr.startsWith('[') && typeStr.endsWith(']');
    const baseType = isVector ? typeStr.slice(1, -1) : typeStr;

    let fieldType;
    if (isVector) {
      fieldType = 'vector';
    } else if (SCALAR_TYPES.has(baseType)) {
      fieldType = baseType;
    } else if (baseType === 'string') {
      fieldType = 'string';
    } else {
      fieldType = 'struct';
    }

    schema.fields.push({
      name,
      id: fieldId++,
      type: fieldType,
      encrypted: isEncrypted,
      elementType: isVector ? (SCALAR_TYPES.has(baseType) ? baseType : 'struct') : undefined,
      elementSize: TYPE_SIZES[baseType] || 1,
    });
  }

  return schema;
}

/**
 * Read uint32 from buffer (little-endian)
 */
function readUint32(buffer, offset) {
  return buffer[offset] | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24) >>> 0;
}

/**
 * Read int32 from buffer (little-endian)
 */
function readInt32(buffer, offset) {
  return buffer[offset] | (buffer[offset + 1] << 8) | (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24);
}

/**
 * Read uint16 from buffer (little-endian)
 */
function readUint16(buffer, offset) {
  return buffer[offset] | (buffer[offset + 1] << 8);
}

/**
 * Process a FlatBuffer table and encrypt/decrypt marked fields
 * @param {Uint8Array} buffer - The FlatBuffer
 * @param {number} tableOffset - Offset to the table
 * @param {Object} schema - Parsed schema
 * @param {EncryptionContext} ctx - Encryption context
 */
function processTable(buffer, tableOffset, schema, ctx) {
  // Read vtable offset (soffset_t at table start)
  const vtableOffsetDelta = readInt32(buffer, tableOffset);
  const vtableOffset = tableOffset - vtableOffsetDelta;

  // Read vtable size
  const vtableSize = readUint16(buffer, vtableOffset);

  for (const field of schema.fields) {
    // Field offset is at vtable + (field.id + 2) * 2
    const fieldVtableIdx = (field.id + 2) * 2;
    if (fieldVtableIdx >= vtableSize) continue;

    const fieldOffset = readUint16(buffer, vtableOffset + fieldVtableIdx);
    if (fieldOffset === 0) continue; // Field not present

    const fieldLoc = tableOffset + fieldOffset;

    if (!field.encrypted) continue;

    const key = ctx.deriveFieldKey(field.id);
    const iv = ctx.deriveFieldIV(field.id);

    // Handle different field types
    const size = TYPE_SIZES[field.type];
    if (size) {
      // Scalar type - encrypt in place
      const data = buffer.subarray(fieldLoc, fieldLoc + size);
      encryptBytes(data, key, iv);
    } else if (field.type === 'string') {
      // String: offset to string, then length-prefixed data
      const strOffset = readUint32(buffer, fieldLoc);
      const strLoc = fieldLoc + strOffset;
      const strLen = readUint32(buffer, strLoc);
      const strData = buffer.subarray(strLoc + 4, strLoc + 4 + strLen);
      encryptBytes(strData, key, iv);
    } else if (field.type === 'vector') {
      // Vector: offset to vector, then length-prefixed elements
      const vecOffset = readUint32(buffer, fieldLoc);
      const vecLoc = fieldLoc + vecOffset;
      const vecLen = readUint32(buffer, vecLoc);
      const elemSize = field.elementSize || 1;
      const vecData = buffer.subarray(vecLoc + 4, vecLoc + 4 + vecLen * elemSize);
      encryptBytes(vecData, key, iv);
    } else if (field.type === 'struct') {
      // Struct is inline - we need structSize, but for now encrypt as single block
      // This is a simplification; real implementation should know struct size
      console.warn(`Struct encryption for field '${field.name}' requires struct size`);
    }
  }
}

/**
 * Encrypt a FlatBuffer in-place.
 *
 * Fields marked with the (encrypted) attribute will be encrypted.
 * The buffer structure remains valid - only field values change.
 *
 * WARNING: This function modifies the buffer in-place.
 *
 * @param {Uint8Array} buffer - FlatBuffer to encrypt (modified in-place)
 * @param {Object|string} schema - Parsed schema or schema content string
 * @param {Uint8Array|string|EncryptionContext} key - Encryption key or context
 * @param {string} [rootType] - Root type name (required if schema is string)
 * @returns {Uint8Array} The encrypted buffer (same reference)
 */
export function encryptBuffer(buffer, schema, key, rootType) {
  // Get or create encryption context
  let ctx;
  if (key instanceof EncryptionContext) {
    ctx = key;
  } else {
    ctx = new EncryptionContext(key);
  }

  if (!ctx.isValid()) {
    throw new Error('Invalid encryption key');
  }

  // Parse schema if needed
  const parsedSchema = typeof schema === 'string'
    ? parseSchemaForEncryption(schema, rootType)
    : schema;

  if (!parsedSchema.fields || parsedSchema.fields.length === 0) {
    throw new Error('No fields found in schema. Check that rootType matches the table name.');
  }

  // Read root table offset
  const rootOffset = readUint32(buffer, 0);

  // Process the root table
  processTable(buffer, rootOffset, parsedSchema, ctx);

  return buffer;
}

/**
 * Decrypt a FlatBuffer in-place.
 *
 * Same as encryptBuffer since AES-CTR is symmetric.
 *
 * WARNING: This function modifies the buffer in-place.
 *
 * @param {Uint8Array} buffer - FlatBuffer to decrypt (modified in-place)
 * @param {Object|string} schema - Parsed schema or schema content string
 * @param {Uint8Array|string|EncryptionContext} key - Encryption key or context
 * @param {string} [rootType] - Root type name (required if schema is string)
 * @returns {Uint8Array} The decrypted buffer (same reference)
 */
export const decryptBuffer = encryptBuffer;

// =============================================================================
// Default export
// =============================================================================

export default {
  // Initialization
  initEncryption,
  isInitialized,
  hasCryptopp,
  getVersion,

  // Hash
  sha256,

  // Symmetric encryption
  encryptBytes,
  decryptBytes,
  hkdf,

  // X25519
  x25519GenerateKeyPair,
  x25519SharedSecret,
  x25519DeriveKey,

  // secp256k1
  secp256k1GenerateKeyPair,
  secp256k1SharedSecret,
  secp256k1DeriveKey,
  secp256k1Sign,
  secp256k1Verify,

  // P-256
  p256GenerateKeyPair,
  p256SharedSecret,
  p256DeriveKey,
  p256Sign,
  p256Verify,

  // Ed25519
  ed25519GenerateKeyPair,
  ed25519Sign,
  ed25519Verify,

  // Constants
  KeyExchangeAlgorithm,
  SignatureAlgorithm,
  SymmetricAlgorithm,
  KeyDerivationFunction,

  // Classes
  EncryptionContext,

  // Header utilities
  createEncryptionHeader,
  computeKeyId,
  encryptionHeaderToJSON,
  encryptionHeaderFromJSON,
  encryptScalar,

  // Buffer encryption
  parseSchemaForEncryption,
  encryptBuffer,
  decryptBuffer,
};
