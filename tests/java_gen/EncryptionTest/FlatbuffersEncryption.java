// automatically generated by the FlatBuffers compiler, do not modify

package EncryptionTest;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * FlatBuffers field-level encryption support using AES-256-CTR.
 */
public class FlatbuffersEncryption {

  private static byte[] deriveNonce(byte[] ctx, int fieldOffset) {
    if (ctx == null || ctx.length < 12) {
      throw new IllegalArgumentException("Encryption context must be at least 12 bytes");
    }
    byte[] nonce = new byte[16];
    System.arraycopy(ctx, 0, nonce, 0, 12);
    ByteBuffer.wrap(nonce, 12, 4).order(ByteOrder.LITTLE_ENDIAN).putInt(fieldOffset);
    return nonce;
  }

  private static byte[] decryptBytes(byte[] data, byte[] ctx, int fieldOffset) {
    if (ctx == null) {
      throw new IllegalArgumentException("Encryption context required");
    }
    if (ctx.length < 32) {
      throw new IllegalArgumentException("Encryption context must be at least 32 bytes");
    }
    try {
      byte[] key = new byte[32];
      System.arraycopy(ctx, 0, key, 0, 32);
      byte[] nonce = deriveNonce(ctx, fieldOffset);
      SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
      IvParameterSpec ivSpec = new IvParameterSpec(nonce);
      Cipher cipher = Cipher.getInstance("AES/CTR/NoPadding");
      cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
      return cipher.doFinal(data);
    } catch (Exception e) {
      throw new RuntimeException("Decryption failed", e);
    }
  }

  public static boolean decryptScalar(boolean value, byte[] ctx, int fieldOffset) {
    if (ctx == null) return value;
    byte[] data = new byte[] { (byte)(value ? 1 : 0) };
    byte[] decrypted = decryptBytes(data, ctx, fieldOffset);
    return decrypted[0] != 0;
  }

  public static byte decryptScalar(byte value, byte[] ctx, int fieldOffset) {
    if (ctx == null) return value;
    byte[] data = new byte[] { value };
    byte[] decrypted = decryptBytes(data, ctx, fieldOffset);
    return decrypted[0];
  }

  public static short decryptScalar(short value, byte[] ctx, int fieldOffset) {
    if (ctx == null) return value;
    byte[] data = ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).putShort(value).array();
    byte[] decrypted = decryptBytes(data, ctx, fieldOffset);
    return ByteBuffer.wrap(decrypted).order(ByteOrder.LITTLE_ENDIAN).getShort();
  }

  public static float decryptScalar(float value, byte[] ctx, int fieldOffset) {
    if (ctx == null) return value;
    byte[] data = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putFloat(value).array();
    byte[] decrypted = decryptBytes(data, ctx, fieldOffset);
    return ByteBuffer.wrap(decrypted).order(ByteOrder.LITTLE_ENDIAN).getFloat();
  }

  public static double decryptScalar(double value, byte[] ctx, int fieldOffset) {
    if (ctx == null) return value;
    byte[] data = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putDouble(value).array();
    byte[] decrypted = decryptBytes(data, ctx, fieldOffset);
    return ByteBuffer.wrap(decrypted).order(ByteOrder.LITTLE_ENDIAN).getDouble();
  }

  public static int decryptScalar(int value, byte[] ctx, int fieldOffset) {
    if (ctx == null) return value;
    byte[] data = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value).array();
    byte[] decrypted = decryptBytes(data, ctx, fieldOffset);
    return ByteBuffer.wrap(decrypted).order(ByteOrder.LITTLE_ENDIAN).getInt();
  }

  public static long decryptScalar(long value, byte[] ctx, int fieldOffset) {
    if (ctx == null) return value;
    byte[] data = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(value).array();
    byte[] decrypted = decryptBytes(data, ctx, fieldOffset);
    return ByteBuffer.wrap(decrypted).order(ByteOrder.LITTLE_ENDIAN).getLong();
  }

  public static String decryptString(ByteBuffer bb, int offset, byte[] ctx, int fieldOffset) {
    if (ctx == null) {
      // No encryption context, decode as regular string
      int pos = offset + bb.getInt(offset);
      int len = bb.getInt(pos);
      byte[] data = new byte[len];
      for (int i = 0; i < len; i++) data[i] = bb.get(pos + 4 + i);
      return new String(data, java.nio.charset.StandardCharsets.UTF_8);
    }
    // Read raw bytes and decrypt
    int pos = offset + bb.getInt(offset);
    int len = bb.getInt(pos);
    byte[] data = new byte[len];
    for (int i = 0; i < len; i++) data[i] = bb.get(pos + 4 + i);
    byte[] decrypted = decryptBytes(data, ctx, fieldOffset);
    return new String(decrypted, java.nio.charset.StandardCharsets.UTF_8);
  }
}
