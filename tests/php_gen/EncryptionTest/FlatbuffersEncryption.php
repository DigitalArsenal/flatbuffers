<?php
// automatically generated by the FlatBuffers compiler, do not modify

namespace EncryptionTest;

/**
 * FlatBuffers field-level encryption support using AES-256-CTR.
 */
class FlatbuffersEncryption
{
    /**
     * Derive a 16-byte nonce from encryption context and field offset.
     */
    private static function deriveNonce($ctx, $fieldOffset)
    {
        if (strlen($ctx) < 12) {
            throw new \Exception('Encryption context must be at least 12 bytes');
        }
        $nonce = substr($ctx, 0, 12);
        $nonce .= pack('V', $fieldOffset); // Little-endian 4-byte int
        return $nonce;
    }

    /**
     * Decrypt bytes using AES-256-CTR.
     */
    private static function decryptBytes($data, $ctx, $fieldOffset)
    {
        if (strlen($ctx) < 32) {
            throw new \Exception('Encryption context must be at least 32 bytes');
        }
        $key = substr($ctx, 0, 32);
        $nonce = self::deriveNonce($ctx, $fieldOffset);
        return openssl_decrypt($data, 'aes-256-ctr', $key, OPENSSL_RAW_DATA, $nonce);
    }

    /**
     * Decrypt a scalar value.
     */
    public static function decryptScalar($value, $ctx, $fieldOffset, $type)
    {
        if ($ctx === null) return $value;
        switch ($type) {
            case 'bool':
                $data = pack('C', $value ? 1 : 0);
                $decrypted = self::decryptBytes($data, $ctx, $fieldOffset);
                return unpack('C', $decrypted)[1] !== 0;
            case 'byte': case 'sbyte':
                $data = pack('c', $value);
                $decrypted = self::decryptBytes($data, $ctx, $fieldOffset);
                return unpack('c', $decrypted)[1];
            case 'ubyte':
                $data = pack('C', $value);
                $decrypted = self::decryptBytes($data, $ctx, $fieldOffset);
                return unpack('C', $decrypted)[1];
            case 'short':
                $data = pack('v', $value & 0xFFFF);
                $decrypted = self::decryptBytes($data, $ctx, $fieldOffset);
                $unsigned = unpack('v', $decrypted)[1];
                return $unsigned >= 0x8000 ? $unsigned - 0x10000 : $unsigned;
            case 'ushort':
                $data = pack('v', $value);
                $decrypted = self::decryptBytes($data, $ctx, $fieldOffset);
                return unpack('v', $decrypted)[1];
            case 'int':
                $data = pack('V', $value & 0xFFFFFFFF);
                $decrypted = self::decryptBytes($data, $ctx, $fieldOffset);
                $unsigned = unpack('V', $decrypted)[1];
                return $unsigned >= 0x80000000 ? $unsigned - 0x100000000 : $unsigned;
            case 'uint':
                $data = pack('V', $value);
                $decrypted = self::decryptBytes($data, $ctx, $fieldOffset);
                return unpack('V', $decrypted)[1];
            case 'long':
                $data = pack('P', $value);
                $decrypted = self::decryptBytes($data, $ctx, $fieldOffset);
                return unpack('P', $decrypted)[1];
            case 'ulong':
                $data = pack('P', $value);
                $decrypted = self::decryptBytes($data, $ctx, $fieldOffset);
                return unpack('P', $decrypted)[1];
            case 'float':
                $data = pack('g', $value);
                $decrypted = self::decryptBytes($data, $ctx, $fieldOffset);
                return unpack('g', $decrypted)[1];
            case 'double':
                $data = pack('e', $value);
                $decrypted = self::decryptBytes($data, $ctx, $fieldOffset);
                return unpack('e', $decrypted)[1];
            default:
                throw new \Exception('Unknown scalar type: ' . $type);
        }
    }

    /**
     * Decrypt a string value.
     */
    public static function decryptString($value, $ctx, $fieldOffset)
    {
        if ($value === null || $ctx === null) return $value;
        $decrypted = self::decryptBytes($value, $ctx, $fieldOffset);
        return $decrypted;
    }
}
