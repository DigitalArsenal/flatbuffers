//! Cross-language verification test for Rust encryption implementation.
//!
//! This program loads test vectors generated by the JavaScript implementation
//! and verifies that Rust can correctly decrypt them.
//!
//! Usage: rustc verify_rust.rs -o verify_rust && ./verify_rust
//!    or: cargo run --example verify_rust (if added to Cargo.toml)

use std::fs;
use std::path::Path;

fn main() {
    // Try to find test_vectors.json
    let paths = [
        "test_vectors.json",
        "wasm/examples/cross-language-test/test_vectors.json",
        "../cross-language-test/test_vectors.json",
    ];

    let mut data = None;
    for path in &paths {
        if Path::new(path).exists() {
            data = Some(fs::read_to_string(path).expect("Failed to read file"));
            break;
        }
    }

    let data = data.expect("Could not find test_vectors.json");

    // Simple JSON parsing (no serde dependency)
    let key_hex = extract_string(&data, "key_hex");
    let flatc_version = extract_string(&data, "flatc_version");
    let key = hex_decode(&key_hex);

    println!("Testing against {}", flatc_version);
    println!("Key: {}...\n", &key_hex[..16]);

    let mut passed = 0;
    let mut failed = 0;

    // Extract vectors array
    let vectors_start = data.find("\"vectors\"").unwrap();
    let vectors_content = &data[vectors_start..];

    // Find each vector object - look for "name": pattern with string value
    let mut pos = 0;
    while let Some(name_pos) = vectors_content[pos..].find("\"name\": \"") {
        let search_start = pos + name_pos;

        // Find the start of this object (the { before "name")
        let mut vec_start = search_start;
        for i in (0..search_start).rev() {
            if vectors_content.as_bytes()[i] == b'{' {
                vec_start = i;
                break;
            }
        }

        // Find the end of this vector object (matching braces)
        let mut depth = 0;
        let mut vec_end = vec_start;
        for (i, c) in vectors_content[vec_start..].char_indices() {
            match c {
                '{' => depth += 1,
                '}' => {
                    depth -= 1;
                    if depth == 0 {
                        vec_end = vec_start + i + 1;
                        break;
                    }
                }
                _ => {}
            }
        }

        let vec_content = &vectors_content[vec_start..vec_end];

        let name = extract_string(vec_content, "name");
        let schema = extract_string(vec_content, "schema").replace("\\n", "\n");
        let root_type = extract_string(vec_content, "root_type");
        let original_hex = extract_string(vec_content, "original_hex");
        let encrypted_hex = extract_string(vec_content, "encrypted_hex");

        // Skip if no encryption happened
        if original_hex == encrypted_hex {
            println!("SKIP: {} (no encrypted fields present)", name);
            pos = vec_end;
            continue;
        }

        // Decrypt using our Rust implementation
        let mut encrypted = hex_decode(&encrypted_hex);
        decrypt_buffer(&mut encrypted, &schema, &key, &root_type);
        let decrypted_hex = hex_encode(&encrypted);

        if decrypted_hex == original_hex {
            println!("PASS: {}", name);
            passed += 1;
        } else {
            println!("FAIL: {}", name);
            let show_len = std::cmp::min(80, original_hex.len());
            println!("  Expected: {}...", &original_hex[..show_len]);
            println!("  Got:      {}...", &decrypted_hex[..show_len]);
            failed += 1;
        }

        pos = vec_end;
    }

    println!("\nResults: {} passed, {} failed", passed, failed);
    if failed > 0 {
        std::process::exit(1);
    }
}

fn extract_string(json: &str, key: &str) -> String {
    let pattern = format!("\"{}\":", key);
    if let Some(start) = json.find(&pattern) {
        let after_key = &json[start + pattern.len()..];
        // Skip whitespace
        let trimmed = after_key.trim_start();
        if trimmed.starts_with('"') {
            // Find end of string value
            let value_start = 1;
            let mut value_end = value_start;
            let chars: Vec<char> = trimmed.chars().collect();
            while value_end < chars.len() {
                if chars[value_end] == '"' && (value_end == 0 || chars[value_end - 1] != '\\') {
                    break;
                }
                value_end += 1;
            }
            return chars[value_start..value_end].iter().collect::<String>()
                .replace("\\\"", "\"")
                .replace("\\\\", "\\");
        }
    }
    String::new()
}

fn hex_decode(hex: &str) -> Vec<u8> {
    let mut bytes = Vec::with_capacity(hex.len() / 2);
    for i in (0..hex.len()).step_by(2) {
        let byte = u8::from_str_radix(&hex[i..i+2], 16).unwrap_or(0);
        bytes.push(byte);
    }
    bytes
}

fn hex_encode(bytes: &[u8]) -> String {
    bytes.iter().map(|b| format!("{:02x}", b)).collect()
}

// =============================================================================
// Inline encryption implementation
// =============================================================================

const SBOX: [u8; 256] = [
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,
    0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
    0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26,
    0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,
    0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
    0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed,
    0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,
    0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
    0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,
    0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,
    0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
    0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,
    0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,
    0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
    0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11,
    0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,
    0xb0, 0x54, 0xbb, 0x16,
];

const RCON: [u8; 11] = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

fn gf_mul(mut a: u8, mut b: u8) -> u8 {
    let mut p = 0u8;
    for _ in 0..8 {
        if b & 1 != 0 {
            p ^= a;
        }
        let hi_bit = a & 0x80;
        a <<= 1;
        if hi_bit != 0 {
            a ^= 0x1b;
        }
        b >>= 1;
    }
    p
}

fn aes256_key_expansion(key: &[u8]) -> Vec<u8> {
    let mut round_keys = vec![0u8; 240];
    round_keys[..32].copy_from_slice(key);

    for i in 8..60 {
        let mut temp = [0u8; 4];
        temp.copy_from_slice(&round_keys[(i-1)*4..i*4]);

        if i % 8 == 0 {
            let t = temp[0];
            temp[0] = SBOX[temp[1] as usize] ^ RCON[i/8];
            temp[1] = SBOX[temp[2] as usize];
            temp[2] = SBOX[temp[3] as usize];
            temp[3] = SBOX[t as usize];
        } else if i % 8 == 4 {
            for j in 0..4 {
                temp[j] = SBOX[temp[j] as usize];
            }
        }

        for j in 0..4 {
            round_keys[i*4+j] = round_keys[(i-8)*4+j] ^ temp[j];
        }
    }

    round_keys
}

fn sub_bytes(state: &mut [u8]) {
    for i in 0..16 {
        state[i] = SBOX[state[i] as usize];
    }
}

fn shift_rows(state: &mut [u8]) {
    let temp = state[1];
    state[1] = state[5];
    state[5] = state[9];
    state[9] = state[13];
    state[13] = temp;

    let temp = state[2];
    state[2] = state[10];
    state[10] = temp;
    let temp = state[6];
    state[6] = state[14];
    state[14] = temp;

    let temp = state[15];
    state[15] = state[11];
    state[11] = state[7];
    state[7] = state[3];
    state[3] = temp;
}

fn mix_columns(state: &mut [u8]) {
    for i in 0..4 {
        let a = [state[i*4], state[i*4+1], state[i*4+2], state[i*4+3]];
        state[i*4+0] = gf_mul(a[0], 2) ^ gf_mul(a[1], 3) ^ a[2] ^ a[3];
        state[i*4+1] = a[0] ^ gf_mul(a[1], 2) ^ gf_mul(a[2], 3) ^ a[3];
        state[i*4+2] = a[0] ^ a[1] ^ gf_mul(a[2], 2) ^ gf_mul(a[3], 3);
        state[i*4+3] = gf_mul(a[0], 3) ^ a[1] ^ a[2] ^ gf_mul(a[3], 2);
    }
}

fn add_round_key(state: &mut [u8], round_key: &[u8]) {
    for i in 0..16 {
        state[i] ^= round_key[i];
    }
}

fn aes_encrypt_block(key: &[u8], input: &[u8]) -> Vec<u8> {
    let round_keys = aes256_key_expansion(key);
    let mut state = input[..16].to_vec();

    add_round_key(&mut state, &round_keys[..16]);

    for round in 1..14 {
        sub_bytes(&mut state);
        shift_rows(&mut state);
        mix_columns(&mut state);
        add_round_key(&mut state, &round_keys[round*16..(round+1)*16]);
    }

    sub_bytes(&mut state);
    shift_rows(&mut state);
    add_round_key(&mut state, &round_keys[14*16..15*16]);

    state
}

fn aes_ctr_keystream(key: &[u8], nonce: &[u8], length: usize) -> Vec<u8> {
    let mut keystream = vec![0u8; length];
    let mut counter = nonce[..16].to_vec();

    let mut offset = 0;
    while offset < length {
        let block = aes_encrypt_block(key, &counter);
        let to_copy = std::cmp::min(16, length - offset);
        keystream[offset..offset+to_copy].copy_from_slice(&block[..to_copy]);
        offset += to_copy;

        for i in (0..16).rev() {
            counter[i] = counter[i].wrapping_add(1);
            if counter[i] != 0 {
                break;
            }
        }
    }

    keystream
}

fn derive_key(master_key: &[u8], info: &[u8], out_length: usize) -> Vec<u8> {
    let mut out = vec![0u8; out_length];

    for i in 0..std::cmp::min(out_length, master_key.len()) {
        out[i] = master_key[i];
    }

    let mut hash_val = 0u8;
    for &b in info {
        hash_val ^= b;
        hash_val = hash_val.rotate_left(1);
    }

    for i in 0..out_length {
        out[i] ^= hash_val;
        hash_val = ((hash_val as u32 * 31 + i as u32) & 0xFF) as u8;
    }

    if out_length >= 16 {
        let temp = aes_encrypt_block(master_key, &out[..16]);
        let copy_len = std::cmp::min(out_length, 16);
        out[..copy_len].copy_from_slice(&temp[..copy_len]);
        if out_length > 16 {
            let temp2 = aes_encrypt_block(master_key, &temp);
            let copy_len2 = std::cmp::min(out_length - 16, 16);
            out[16..16+copy_len2].copy_from_slice(&temp2[..copy_len2]);
        }
    }

    out
}

fn derive_field_key(master_key: &[u8], field_id: usize) -> Vec<u8> {
    let mut info = vec![0u8; 19];
    info[..17].copy_from_slice(b"flatbuffers-field");
    info[17] = ((field_id >> 8) & 0xFF) as u8;
    info[18] = (field_id & 0xFF) as u8;
    derive_key(master_key, &info, 32)
}

fn derive_field_iv(master_key: &[u8], field_id: usize) -> Vec<u8> {
    let mut info = vec![0u8; 16];
    info[..14].copy_from_slice(b"flatbuffers-iv");
    info[14] = ((field_id >> 8) & 0xFF) as u8;
    info[15] = (field_id & 0xFF) as u8;
    derive_key(master_key, &info, 16)
}

fn encrypt_region(buffer: &mut [u8], start: usize, length: usize, key: &[u8], iv: &[u8]) {
    let keystream = aes_ctr_keystream(key, iv, length);
    for i in 0..length {
        buffer[start + i] ^= keystream[i];
    }
}

fn read_u32_le(buffer: &[u8], offset: usize) -> u32 {
    u32::from_le_bytes([buffer[offset], buffer[offset+1], buffer[offset+2], buffer[offset+3]])
}

fn read_i32_le(buffer: &[u8], offset: usize) -> i32 {
    i32::from_le_bytes([buffer[offset], buffer[offset+1], buffer[offset+2], buffer[offset+3]])
}

fn read_u16_le(buffer: &[u8], offset: usize) -> u16 {
    u16::from_le_bytes([buffer[offset], buffer[offset+1]])
}

struct FieldInfo {
    id: usize,
    field_type: String,
    encrypted: bool,
    element_size: usize,
}

fn get_type_size(type_name: &str) -> usize {
    match type_name {
        "bool" | "byte" | "ubyte" => 1,
        "short" | "ushort" => 2,
        "int" | "uint" | "float" => 4,
        "long" | "ulong" | "double" => 8,
        _ => 0,
    }
}

fn get_base_type(type_name: &str) -> String {
    match type_name {
        "bool" | "byte" | "ubyte" | "short" | "ushort" |
        "int" | "uint" | "long" | "ulong" | "float" | "double" => type_name.to_string(),
        "string" => "string".to_string(),
        _ => "struct".to_string(),
    }
}

fn parse_schema_for_encryption(schema_content: &str, root_type: &str) -> Vec<FieldInfo> {
    let mut fields = Vec::new();

    // Find table definition
    let table_pattern = format!("table {}{{", root_type.trim());
    let table_pattern_space = format!("table {} {{", root_type.trim());

    let table_start = schema_content.find(&table_pattern)
        .or_else(|| schema_content.find(&table_pattern_space));

    if table_start.is_none() {
        return fields;
    }

    let table_start = table_start.unwrap();
    let table_end = schema_content[table_start..].find('}').map(|i| table_start + i);
    if table_end.is_none() {
        return fields;
    }

    let table_body = &schema_content[table_start..table_end.unwrap()];

    let mut field_id = 0;
    for line in table_body.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with("//") || line.starts_with("table") {
            continue;
        }

        // Parse field: name: type (attributes);
        if let Some(colon_pos) = line.find(':') {
            let type_part = &line[colon_pos + 1..];
            let type_end = type_part.find(|c| c == '(' || c == ';').unwrap_or(type_part.len());
            let field_type = type_part[..type_end].trim();

            let is_encrypted = line.contains("encrypted");
            let is_vector = field_type.starts_with('[') && field_type.ends_with(']');

            let base_type = if is_vector {
                &field_type[1..field_type.len()-1]
            } else {
                field_type
            };

            let final_type = if is_vector {
                "vector".to_string()
            } else {
                get_base_type(base_type)
            };

            fields.push(FieldInfo {
                id: field_id,
                field_type: final_type,
                encrypted: is_encrypted,
                element_size: get_type_size(base_type),
            });

            field_id += 1;
        }
    }

    fields
}

fn process_table(buffer: &mut [u8], table_offset: usize, fields: &[FieldInfo], key: &[u8]) {
    let vtable_offset_delta = read_i32_le(buffer, table_offset);
    let vtable_offset = (table_offset as i32 - vtable_offset_delta) as usize;

    let vtable_size = read_u16_le(buffer, vtable_offset) as usize;

    for field in fields {
        let field_vtable_idx = (field.id + 2) * 2;

        if field_vtable_idx >= vtable_size {
            continue;
        }

        let field_offset = read_u16_le(buffer, vtable_offset + field_vtable_idx) as usize;
        if field_offset == 0 {
            continue;
        }

        let field_loc = table_offset + field_offset;

        if !field.encrypted {
            continue;
        }

        let field_key = derive_field_key(key, field.id);
        let field_iv = derive_field_iv(key, field.id);

        match field.field_type.as_str() {
            "bool" | "byte" | "ubyte" => {
                encrypt_region(buffer, field_loc, 1, &field_key, &field_iv);
            }
            "short" | "ushort" => {
                encrypt_region(buffer, field_loc, 2, &field_key, &field_iv);
            }
            "int" | "uint" | "float" => {
                encrypt_region(buffer, field_loc, 4, &field_key, &field_iv);
            }
            "long" | "ulong" | "double" => {
                encrypt_region(buffer, field_loc, 8, &field_key, &field_iv);
            }
            "string" => {
                let string_offset = read_u32_le(buffer, field_loc) as usize;
                let string_loc = field_loc + string_offset;
                let string_len = read_u32_le(buffer, string_loc) as usize;
                let string_data = string_loc + 4;
                if string_data + string_len <= buffer.len() {
                    encrypt_region(buffer, string_data, string_len, &field_key, &field_iv);
                }
            }
            "vector" => {
                let vec_offset = read_u32_le(buffer, field_loc) as usize;
                let vec_loc = field_loc + vec_offset;
                let vec_len = read_u32_le(buffer, vec_loc) as usize;
                let vec_data = vec_loc + 4;
                let elem_size = if field.element_size == 0 { 1 } else { field.element_size };
                let total_size = vec_len * elem_size;
                if vec_data + total_size <= buffer.len() {
                    encrypt_region(buffer, vec_data, total_size, &field_key, &field_iv);
                }
            }
            _ => {}
        }
    }
}

fn decrypt_buffer(buffer: &mut [u8], schema_content: &str, key: &[u8], root_type: &str) {
    let fields = parse_schema_for_encryption(schema_content, root_type);
    let root_offset = read_u32_le(buffer, 0) as usize;
    process_table(buffer, root_offset, &fields, key);
}
