// Package main implements the Go E2E test runner for FlatBuffers cross-language encryption.
//
// This test runner:
// 1. Loads test vectors and encryption keys
// 2. Reads binary files generated by Node.js
// 3. Decrypts using the WASM encryption module
// 4. Verifies decryption produces expected values
// 5. Generates its own encrypted binaries for other languages to verify
package main

import (
	"context"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
	"github.com/tetratelabs/wazero/experimental/table"
	"github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1"
)

// WasmPath is the path to the encryption WASM module
const WasmPath = "../../../../../build/wasm/wasm/flatc-encryption.wasm"

// EncryptionKeys holds the derived encryption keys for each chain
type EncryptionKeys map[string]struct {
	KeyHex    string `json:"key_hex"`
	IVHex     string `json:"iv_hex"`
	KeyBase64 string `json:"key_base64"`
	IVBase64  string `json:"iv_base64"`
}

// CryptoKey holds the crypto key material for a chain
type CryptoKey struct {
	PrivateKeyHex string `json:"private_key_hex"`
	PublicKeyHex  string `json:"public_key_hex"`
	Address       string `json:"address"`
	Scheme        string `json:"scheme"`
}

// ECDHHeader stores ECDH header data for cross-language testing
type ECDHHeader struct {
	Version            int    `json:"version"`
	KeyExchange        int    `json:"key_exchange"`
	Symmetric          int    `json:"symmetric"`
	Kdf                int    `json:"kdf"`
	EphemeralPublicKey string `json:"ephemeral_public_key"`
	Context            string `json:"context"`
	Timestamp          int64  `json:"timestamp"`
	SessionKey         string `json:"session_key"`
	SessionIV          string `json:"session_iv"`
}

// TestResult tracks test outcomes
type TestResult struct {
	Name    string
	Passed  int
	Failed  int
	Errors  []string
}

func (r *TestResult) Pass(msg string) {
	r.Passed++
	fmt.Printf("  ✓ %s\n", msg)
}

func (r *TestResult) Fail(msg string, err error) {
	r.Failed++
	errMsg := msg
	if err != nil {
		errMsg = fmt.Sprintf("%s: %v", msg, err)
	}
	r.Errors = append(r.Errors, errMsg)
	fmt.Printf("  ✗ %s\n", errMsg)
}

func (r *TestResult) Summary() bool {
	total := r.Passed + r.Failed
	status := "✓"
	if r.Failed > 0 {
		status = "✗"
	}
	fmt.Printf("\n%s %s: %d/%d passed\n", status, r.Name, r.Passed, total)
	return r.Failed == 0
}

// EncryptionModule wraps the WASM encryption module
type EncryptionModule struct {
	runtime wazero.Runtime
	module  api.Module
	ctx     context.Context

	malloc       api.Function
	free         api.Function
	encryptBytes api.Function
	decryptBytes api.Function
	sha256       api.Function
	hkdf         api.Function
	getVersion   api.Function
	hasCryptopp  api.Function

	// X25519 functions
	x25519GenerateKeypair api.Function
	x25519SharedSecret    api.Function

	// secp256k1 functions
	secp256k1GenerateKeypair api.Function
	secp256k1SharedSecret    api.Function

	// P-256 functions
	p256GenerateKeypair api.Function
	p256SharedSecret    api.Function
}

var wasmModule api.Module

func NewEncryptionModule(ctx context.Context, wasmBytes []byte) (*EncryptionModule, error) {
	r := wazero.NewRuntime(ctx)

	// Instantiate WASI
	wasi_snapshot_preview1.MustInstantiate(ctx, r)

	// Create env module with invoke_* trampolines
	i32 := api.ValueTypeI32

	setException := func(ctx context.Context) {
		if wasmModule != nil {
			if setThrew := wasmModule.ExportedFunction("setThrew"); setThrew != nil {
				setThrew.Call(ctx, 1, 0)
			}
		}
	}

	_, err := r.NewHostModuleBuilder("env").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, nil, nil)
			f.Call(ctx)
		}).Export("invoke_v").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32}, nil)
			f.Call(ctx, uint64(a))
		}).Export("invoke_vi").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b))
		}).Export("invoke_vii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c))
		}).Export("invoke_viii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d))
		}).Export("invoke_viiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e))
		}).Export("invoke_viiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff))
		}).Export("invoke_viiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g))
		}).Export("invoke_viiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g, h, ii uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g), uint64(h), uint64(ii))
		}).Export("invoke_viiiiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, nil, []api.ValueType{i32})
			res, _ := f.Call(ctx)
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_i").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_ii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g, h, ii uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g), uint64(h), uint64(ii))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module) uint32 { return 0 }).Export("__cxa_find_matching_catch_2").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) uint32 { return 0 }).Export("__cxa_find_matching_catch_3").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) {}).Export("__resumeException").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) uint32 { return 0 }).Export("__cxa_begin_catch").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module) {}).Export("__cxa_end_catch").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) uint32 { return 0 }).Export("llvm_eh_typeid_for").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a, b, c uint32) {}).Export("__cxa_throw").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module) uint32 { return 0 }).Export("__cxa_uncaught_exceptions").
		Instantiate(ctx)
	if err != nil {
		r.Close(ctx)
		return nil, fmt.Errorf("failed to instantiate env module: %w", err)
	}

	// Compile and instantiate the WASM module
	compiled, err := r.CompileModule(ctx, wasmBytes)
	if err != nil {
		r.Close(ctx)
		return nil, fmt.Errorf("failed to compile module: %w", err)
	}

	config := wazero.NewModuleConfig().WithName("flatc-encryption")
	mod, err := r.InstantiateModule(ctx, compiled, config)
	if err != nil {
		r.Close(ctx)
		return nil, fmt.Errorf("failed to instantiate module: %w", err)
	}

	wasmModule = mod

	return &EncryptionModule{
		runtime:                  r,
		module:                   mod,
		ctx:                      ctx,
		malloc:                   mod.ExportedFunction("malloc"),
		free:                     mod.ExportedFunction("free"),
		encryptBytes:             mod.ExportedFunction("wasi_encrypt_bytes"),
		decryptBytes:             mod.ExportedFunction("wasi_decrypt_bytes"),
		sha256:                   mod.ExportedFunction("wasi_sha256"),
		hkdf:                     mod.ExportedFunction("wasi_hkdf"),
		getVersion:               mod.ExportedFunction("wasi_get_version"),
		hasCryptopp:              mod.ExportedFunction("wasi_has_cryptopp"),
		x25519GenerateKeypair:    mod.ExportedFunction("wasi_x25519_generate_keypair"),
		x25519SharedSecret:       mod.ExportedFunction("wasi_x25519_shared_secret"),
		secp256k1GenerateKeypair: mod.ExportedFunction("wasi_secp256k1_generate_keypair"),
		secp256k1SharedSecret:    mod.ExportedFunction("wasi_secp256k1_shared_secret"),
		p256GenerateKeypair:      mod.ExportedFunction("wasi_p256_generate_keypair"),
		p256SharedSecret:         mod.ExportedFunction("wasi_p256_shared_secret"),
	}, nil
}

func (em *EncryptionModule) Close() {
	em.runtime.Close(em.ctx)
}

func (em *EncryptionModule) memory() api.Memory {
	return em.module.Memory()
}

func (em *EncryptionModule) Version() string {
	res, _ := em.getVersion.Call(em.ctx)
	if len(res) == 0 || res[0] == 0 {
		return "unknown"
	}
	ptr := uint32(res[0])
	mem := em.memory()
	var result []byte
	for i := uint32(0); ; i++ {
		b, ok := mem.ReadByte(ptr + i)
		if !ok || b == 0 {
			break
		}
		result = append(result, b)
	}
	return string(result)
}

func (em *EncryptionModule) HasCryptopp() bool {
	res, _ := em.hasCryptopp.Call(em.ctx)
	return len(res) > 0 && res[0] != 0
}

func (em *EncryptionModule) EncryptBytes(key, iv, data []byte) error {
	keyPtr := em.alloc(32)
	ivPtr := em.alloc(16)
	dataPtr := em.alloc(uint32(len(data)))

	defer func() {
		em.dealloc(keyPtr)
		em.dealloc(ivPtr)
		em.dealloc(dataPtr)
	}()

	em.memory().Write(keyPtr, key)
	em.memory().Write(ivPtr, iv)
	em.memory().Write(dataPtr, data)

	_, err := em.encryptBytes.Call(em.ctx, uint64(keyPtr), uint64(ivPtr), uint64(dataPtr), uint64(len(data)))
	if err != nil {
		return err
	}

	// Read encrypted data back
	encrypted, ok := em.memory().Read(dataPtr, uint32(len(data)))
	if !ok {
		return fmt.Errorf("failed to read encrypted data")
	}
	copy(data, encrypted)
	return nil
}

func (em *EncryptionModule) DecryptBytes(key, iv, data []byte) error {
	return em.EncryptBytes(key, iv, data) // CTR mode is symmetric
}

func (em *EncryptionModule) SHA256(data []byte) ([]byte, error) {
	dataPtr := em.alloc(uint32(max(len(data), 1)))
	hashPtr := em.alloc(32)

	defer func() {
		em.dealloc(dataPtr)
		em.dealloc(hashPtr)
	}()

	if len(data) > 0 {
		em.memory().Write(dataPtr, data)
	}

	_, err := em.sha256.Call(em.ctx, uint64(dataPtr), uint64(len(data)), uint64(hashPtr))
	if err != nil {
		return nil, err
	}

	hash, ok := em.memory().Read(hashPtr, 32)
	if !ok {
		return nil, fmt.Errorf("failed to read hash")
	}
	return hash, nil
}

func (em *EncryptionModule) alloc(size uint32) uint32 {
	res, _ := em.malloc.Call(em.ctx, uint64(size))
	return uint32(res[0])
}

func (em *EncryptionModule) dealloc(ptr uint32) {
	em.free.Call(em.ctx, uint64(ptr))
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// HKDF derives key material from input keying material
func (em *EncryptionModule) HKDF(ikm, salt, info []byte, length int) ([]byte, error) {
	if em.hkdf == nil {
		return nil, fmt.Errorf("HKDF not available")
	}

	ikmPtr := em.alloc(uint32(max(len(ikm), 1)))
	saltLen := len(salt)
	if saltLen == 0 {
		saltLen = 1
	}
	saltPtr := em.alloc(uint32(saltLen))
	infoPtr := em.alloc(uint32(max(len(info), 1)))
	outPtr := em.alloc(uint32(length))

	defer func() {
		em.dealloc(ikmPtr)
		em.dealloc(saltPtr)
		em.dealloc(infoPtr)
		em.dealloc(outPtr)
	}()

	if len(ikm) > 0 {
		em.memory().Write(ikmPtr, ikm)
	}
	if len(salt) > 0 {
		em.memory().Write(saltPtr, salt)
	}
	if len(info) > 0 {
		em.memory().Write(infoPtr, info)
	}

	actualSaltLen := uint32(len(salt))
	_, err := em.hkdf.Call(em.ctx,
		uint64(ikmPtr), uint64(len(ikm)),
		uint64(saltPtr), uint64(actualSaltLen),
		uint64(infoPtr), uint64(len(info)),
		uint64(outPtr), uint64(length))
	if err != nil {
		return nil, err
	}

	out, ok := em.memory().Read(outPtr, uint32(length))
	if !ok {
		return nil, fmt.Errorf("failed to read HKDF output")
	}
	result := make([]byte, length)
	copy(result, out)
	return result, nil
}

// X25519GenerateKeypair generates an X25519 key pair
func (em *EncryptionModule) X25519GenerateKeypair() (privateKey, publicKey []byte, err error) {
	if em.x25519GenerateKeypair == nil {
		return nil, nil, fmt.Errorf("X25519 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(32)

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
	}()

	res, err := em.x25519GenerateKeypair.Call(em.ctx, uint64(privPtr), uint64(pubPtr))
	if err != nil {
		return nil, nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, nil, fmt.Errorf("X25519 keypair generation failed")
	}

	priv, _ := em.memory().Read(privPtr, 32)
	pub, _ := em.memory().Read(pubPtr, 32)

	privateKey = make([]byte, 32)
	publicKey = make([]byte, 32)
	copy(privateKey, priv)
	copy(publicKey, pub)
	return privateKey, publicKey, nil
}

// X25519SharedSecret computes ECDH shared secret
func (em *EncryptionModule) X25519SharedSecret(privateKey, publicKey []byte) ([]byte, error) {
	if em.x25519SharedSecret == nil {
		return nil, fmt.Errorf("X25519 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(32)
	secretPtr := em.alloc(32)

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
		em.dealloc(secretPtr)
	}()

	em.memory().Write(privPtr, privateKey)
	em.memory().Write(pubPtr, publicKey)

	res, err := em.x25519SharedSecret.Call(em.ctx, uint64(privPtr), uint64(pubPtr), uint64(secretPtr))
	if err != nil {
		return nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, fmt.Errorf("X25519 ECDH failed")
	}

	secret, _ := em.memory().Read(secretPtr, 32)
	result := make([]byte, 32)
	copy(result, secret)
	return result, nil
}

// Secp256k1GenerateKeypair generates a secp256k1 key pair
func (em *EncryptionModule) Secp256k1GenerateKeypair() (privateKey, publicKey []byte, err error) {
	if em.secp256k1GenerateKeypair == nil {
		return nil, nil, fmt.Errorf("secp256k1 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(33) // compressed public key

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
	}()

	res, err := em.secp256k1GenerateKeypair.Call(em.ctx, uint64(privPtr), uint64(pubPtr))
	if err != nil {
		return nil, nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, nil, fmt.Errorf("secp256k1 keypair generation failed")
	}

	priv, _ := em.memory().Read(privPtr, 32)
	pub, _ := em.memory().Read(pubPtr, 33)

	privateKey = make([]byte, 32)
	publicKey = make([]byte, 33)
	copy(privateKey, priv)
	copy(publicKey, pub)
	return privateKey, publicKey, nil
}

// Secp256k1SharedSecret computes ECDH shared secret
func (em *EncryptionModule) Secp256k1SharedSecret(privateKey, publicKey []byte) ([]byte, error) {
	if em.secp256k1SharedSecret == nil {
		return nil, fmt.Errorf("secp256k1 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(uint32(len(publicKey)))
	secretPtr := em.alloc(32)

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
		em.dealloc(secretPtr)
	}()

	em.memory().Write(privPtr, privateKey)
	em.memory().Write(pubPtr, publicKey)

	res, err := em.secp256k1SharedSecret.Call(em.ctx, uint64(privPtr), uint64(pubPtr), uint64(len(publicKey)), uint64(secretPtr))
	if err != nil {
		return nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, fmt.Errorf("secp256k1 ECDH failed")
	}

	secret, _ := em.memory().Read(secretPtr, 32)
	result := make([]byte, 32)
	copy(result, secret)
	return result, nil
}

// P256GenerateKeypair generates a P-256 key pair
func (em *EncryptionModule) P256GenerateKeypair() (privateKey, publicKey []byte, err error) {
	if em.p256GenerateKeypair == nil {
		return nil, nil, fmt.Errorf("P-256 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(33) // compressed public key

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
	}()

	res, err := em.p256GenerateKeypair.Call(em.ctx, uint64(privPtr), uint64(pubPtr))
	if err != nil {
		return nil, nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, nil, fmt.Errorf("P-256 keypair generation failed")
	}

	priv, _ := em.memory().Read(privPtr, 32)
	pub, _ := em.memory().Read(pubPtr, 33)

	privateKey = make([]byte, 32)
	publicKey = make([]byte, 33)
	copy(privateKey, priv)
	copy(publicKey, pub)
	return privateKey, publicKey, nil
}

// P256SharedSecret computes ECDH shared secret
func (em *EncryptionModule) P256SharedSecret(privateKey, publicKey []byte) ([]byte, error) {
	if em.p256SharedSecret == nil {
		return nil, fmt.Errorf("P-256 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(uint32(len(publicKey)))
	secretPtr := em.alloc(32)

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
		em.dealloc(secretPtr)
	}()

	em.memory().Write(privPtr, privateKey)
	em.memory().Write(pubPtr, publicKey)

	res, err := em.p256SharedSecret.Call(em.ctx, uint64(privPtr), uint64(pubPtr), uint64(len(publicKey)), uint64(secretPtr))
	if err != nil {
		return nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, fmt.Errorf("P-256 ECDH failed")
	}

	secret, _ := em.memory().Read(secretPtr, 32)
	result := make([]byte, 32)
	copy(result, secret)
	return result, nil
}

func main() {
	fmt.Println(string(make([]byte, 60, 60)))
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()
	fmt.Println("FlatBuffers Cross-Language Encryption E2E Tests - Go")
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()
	fmt.Println()
	fmt.Println("Mode: TRANSPARENT ENCRYPTION")
	fmt.Println("Schema: tests/monster_test.fbs (upstream)")
	fmt.Println()

	ctx := context.Background()

	// Load WASM module
	wasmPath := WasmPath
	wasmBytes, err := os.ReadFile(wasmPath)
	if err != nil {
		fmt.Printf("Failed to load WASM module: %v\n", err)
		fmt.Println("Build the WASM module first:")
		fmt.Println("  cmake --build build/wasm --target flatc_wasm_wasi")
		os.Exit(1)
	}

	em, err := NewEncryptionModule(ctx, wasmBytes)
	if err != nil {
		fmt.Printf("Failed to initialize encryption module: %v\n", err)
		os.Exit(1)
	}
	defer em.Close()

	fmt.Printf("Encryption module version: %s\n", em.Version())
	fmt.Printf("Crypto++ available: %v\n", em.HasCryptopp())
	fmt.Println()

	// Load encryption keys
	keysPath := filepath.Join("..", "..", "vectors", "encryption_keys.json")
	keysData, err := os.ReadFile(keysPath)
	if err != nil {
		fmt.Printf("Failed to load encryption keys: %v\n", err)
		fmt.Println("Run the vector generator first: node generate_vectors.mjs")
		os.Exit(1)
	}

	var encryptionKeys EncryptionKeys
	if err := json.Unmarshal(keysData, &encryptionKeys); err != nil {
		fmt.Printf("Failed to parse encryption keys: %v\n", err)
		os.Exit(1)
	}

	results := []bool{}

	// Test 1: SHA-256
	fmt.Println("Test 1: SHA-256 Hash")
	fmt.Println("----------------------------------------")
	{
		result := &TestResult{Name: "SHA-256"}

		hash, err := em.SHA256([]byte("hello"))
		if err != nil {
			result.Fail("SHA-256 computation", err)
		} else {
			hashHex := hex.EncodeToString(hash)
			expected := "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
			if hashHex == expected {
				result.Pass("SHA-256('hello') matches expected")
			} else {
				result.Fail(fmt.Sprintf("SHA-256 mismatch: got %s", hashHex), nil)
			}
		}

		results = append(results, result.Summary())
	}

	// Test 2: Encryption/Decryption with each chain key
	fmt.Println("\nTest 2: Encryption/Decryption (per-chain keys)")
	fmt.Println("----------------------------------------")

	for chain, keys := range encryptionKeys {
		result := &TestResult{Name: fmt.Sprintf("Encryption with %s", chain)}

		key, err := hex.DecodeString(keys.KeyHex)
		if err != nil {
			result.Fail("Decode key", err)
			results = append(results, result.Summary())
			continue
		}

		iv, err := hex.DecodeString(keys.IVHex)
		if err != nil {
			result.Fail("Decode IV", err)
			results = append(results, result.Summary())
			continue
		}

		// Test data
		plaintext := []byte("Hello, FlatBuffers encryption test from Go!")
		originalHex := hex.EncodeToString(plaintext)

		// Encrypt
		data := make([]byte, len(plaintext))
		copy(data, plaintext)

		if err := em.EncryptBytes(key, iv, data); err != nil {
			result.Fail("Encryption", err)
			results = append(results, result.Summary())
			continue
		}

		encryptedHex := hex.EncodeToString(data)
		if encryptedHex != originalHex {
			result.Pass("Data encrypted (changed from original)")
		} else {
			result.Fail("Data unchanged after encryption", nil)
		}

		// Decrypt
		if err := em.DecryptBytes(key, iv, data); err != nil {
			result.Fail("Decryption", err)
			results = append(results, result.Summary())
			continue
		}

		decryptedHex := hex.EncodeToString(data)
		if decryptedHex == originalHex {
			result.Pass("Decryption restored original data")
		} else {
			result.Fail("Decryption mismatch", nil)
		}

		if string(data) == string(plaintext) {
			result.Pass("Plaintext matches after round-trip")
		} else {
			result.Fail("Plaintext mismatch after round-trip", nil)
		}

		results = append(results, result.Summary())
	}

	// Test 3: Read Node.js generated binaries and verify decryption
	fmt.Println("\nTest 3: Cross-Language Binary Verification")
	fmt.Println("----------------------------------------")
	{
		result := &TestResult{Name: "Cross-Language Verification"}

		binaryDir := filepath.Join("..", "..", "vectors", "binary")
		unencryptedPath := filepath.Join(binaryDir, "monster_unencrypted.bin")

		if _, err := os.Stat(unencryptedPath); os.IsNotExist(err) {
			result.Fail("Node.js binaries not found. Run Node.js test first.", nil)
		} else {
			unencryptedData, err := os.ReadFile(unencryptedPath)
			if err != nil {
				result.Fail("Read unencrypted binary", err)
			} else {
				result.Pass(fmt.Sprintf("Read unencrypted binary: %d bytes", len(unencryptedData)))

				// Verify FlatBuffer file identifier "MONS" at offset 4-7
				if len(unencryptedData) >= 8 {
					fileIdent := string(unencryptedData[4:8])
					if fileIdent == "MONS" {
						result.Pass("FlatBuffer file identifier: MONS")
					} else {
						result.Fail(fmt.Sprintf("Unexpected file identifier: %s", fileIdent), nil)
					}
				}

				// Decrypt each chain's encrypted binary and compare
				for chain, keys := range encryptionKeys {
					encryptedPath := filepath.Join(binaryDir, fmt.Sprintf("monster_encrypted_%s.bin", chain))
					encryptedData, err := os.ReadFile(encryptedPath)
					if err != nil {
						// Skip if file doesn't exist
						continue
					}

					key, _ := hex.DecodeString(keys.KeyHex)
					iv, _ := hex.DecodeString(keys.IVHex)

					// Decrypt
					decrypted := make([]byte, len(encryptedData))
					copy(decrypted, encryptedData)
					if err := em.DecryptBytes(key, iv, decrypted); err != nil {
						result.Fail(fmt.Sprintf("Decrypt %s binary", chain), err)
						continue
					}

					// Verify decrypted matches unencrypted
					if hex.EncodeToString(decrypted) == hex.EncodeToString(unencryptedData) {
						result.Pass(fmt.Sprintf("Decrypted %s matches original", chain))
					} else {
						result.Fail(fmt.Sprintf("Decrypted %s mismatch", chain), nil)
					}

					// Verify file identifier survived decryption
					if len(decrypted) >= 8 && string(decrypted[4:8]) == "MONS" {
						result.Pass(fmt.Sprintf("Decrypted %s: MONS identifier intact", chain))
					}
				}
			}
		}

		results = append(results, result.Summary())
	}

	// Test 4: ECDH Key Exchange Verification
	// Verify we can decrypt Node.js ECDH-encrypted binaries using the header data
	fmt.Println("\nTest 4: ECDH Key Exchange Verification")
	fmt.Println("----------------------------------------")

	ecdhCurves := []struct {
		name        string
		generate    func() ([]byte, []byte, error)
		sharedFunc  func([]byte, []byte) ([]byte, error)
		pubKeySize  int
	}{
		{"x25519", em.X25519GenerateKeypair, em.X25519SharedSecret, 32},
		{"secp256k1", em.Secp256k1GenerateKeypair, em.Secp256k1SharedSecret, 33},
		{"p256", em.P256GenerateKeypair, em.P256SharedSecret, 33},
	}

	for _, curve := range ecdhCurves {
		result := &TestResult{Name: fmt.Sprintf("ECDH %s", curve.name)}

		// Read the ECDH header from Node.js test
		headerPath := filepath.Join("..", "..", "vectors", "binary", fmt.Sprintf("monster_ecdh_%s_header.json", curve.name))
		headerData, err := os.ReadFile(headerPath)
		if err != nil {
			result.Fail(fmt.Sprintf("Read %s header", curve.name), err)
			results = append(results, result.Summary())
			continue
		}

		var header ECDHHeader
		if err := json.Unmarshal(headerData, &header); err != nil {
			result.Fail("Parse header", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass(fmt.Sprintf("Read %s header", curve.name))

		// Read encrypted binary
		encryptedPath := filepath.Join("..", "..", "vectors", "binary", fmt.Sprintf("monster_ecdh_%s.bin", curve.name))
		encryptedData, err := os.ReadFile(encryptedPath)
		if err != nil {
			result.Fail("Read encrypted binary", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass(fmt.Sprintf("Read encrypted binary: %d bytes", len(encryptedData)))

		// Use the session key from the header (for verification)
		sessionKey, err := hex.DecodeString(header.SessionKey)
		if err != nil {
			result.Fail("Decode session key", err)
			results = append(results, result.Summary())
			continue
		}

		sessionIV, err := hex.DecodeString(header.SessionIV)
		if err != nil {
			result.Fail("Decode session IV", err)
			results = append(results, result.Summary())
			continue
		}

		// Decrypt using the session key
		decrypted := make([]byte, len(encryptedData))
		copy(decrypted, encryptedData)
		if err := em.DecryptBytes(sessionKey, sessionIV, decrypted); err != nil {
			result.Fail("Decrypt with session key", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass("Decrypted with session key")

		// Verify FlatBuffer file identifier
		if len(decrypted) >= 8 && string(decrypted[4:8]) == "MONS" {
			result.Pass("FlatBuffer identifier MONS intact")
		} else {
			result.Fail("FlatBuffer identifier corrupted", nil)
		}

		// Test ECDH keypair generation
		privKey, pubKey, err := curve.generate()
		if err != nil {
			result.Fail("Generate keypair", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass(fmt.Sprintf("Generated %s keypair (priv: %d, pub: %d)", curve.name, len(privKey), len(pubKey)))

		// Test ECDH shared secret (with self)
		shared, err := curve.sharedFunc(privKey, pubKey)
		if err != nil {
			result.Fail("Compute shared secret", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass(fmt.Sprintf("Computed shared secret: %d bytes", len(shared)))

		// Test HKDF key derivation
		context := fmt.Sprintf("flatbuffers-%s-encryption", curve.name)
		keyMaterial, err := em.HKDF(shared, nil, []byte(context), 48)
		if err != nil {
			result.Fail("HKDF derivation", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass(fmt.Sprintf("HKDF derived %d bytes", len(keyMaterial)))

		results = append(results, result.Summary())
	}

	// Summary
	fmt.Println()
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()
	fmt.Println("Summary")
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()

	passed := 0
	for _, r := range results {
		if r {
			passed++
		}
	}

	fmt.Printf("\nTotal: %d/%d test suites passed\n", passed, len(results))

	if passed == len(results) {
		fmt.Println("\n✓ All tests passed!")
		os.Exit(0)
	} else {
		fmt.Println("\n✗ Some tests failed")
		os.Exit(1)
	}
}
