// automatically generated by the FlatBuffers compiler, do not modify

package EncryptionTest

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

/**
 * FlatBuffers field-level encryption support using AES-256-CTR.
 */
object FlatbuffersEncryption {

    private fun deriveNonce(ctx: ByteArray, fieldOffset: Int): ByteArray {
        require(ctx.size >= 12) { "Encryption context must be at least 12 bytes" }
        val nonce = ByteArray(16)
        System.arraycopy(ctx, 0, nonce, 0, 12)
        ByteBuffer.wrap(nonce, 12, 4).order(ByteOrder.LITTLE_ENDIAN).putInt(fieldOffset)
        return nonce
    }

    private fun decryptBytes(data: ByteArray, ctx: ByteArray, fieldOffset: Int): ByteArray {
        require(ctx.size >= 32) { "Encryption context must be at least 32 bytes" }
        val key = ctx.copyOfRange(0, 32)
        val nonce = deriveNonce(ctx, fieldOffset)
        val keySpec = SecretKeySpec(key, "AES")
        val ivSpec = IvParameterSpec(nonce)
        val cipher = Cipher.getInstance("AES/CTR/NoPadding")
        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec)
        return cipher.doFinal(data)
    }

    fun decryptScalar(value: Boolean, ctx: ByteArray?, fieldOffset: Int): Boolean {
        if (ctx == null) return value
        val data = byteArrayOf(if (value) 1.toByte() else 0.toByte())
        val decrypted = decryptBytes(data, ctx, fieldOffset)
        return decrypted[0] != 0.toByte()
    }

    fun decryptScalar(value: Byte, ctx: ByteArray?, fieldOffset: Int): Byte {
        if (ctx == null) return value
        val data = byteArrayOf(value)
        val decrypted = decryptBytes(data, ctx, fieldOffset)
        return decrypted[0]
    }

    fun decryptScalar(value: Short, ctx: ByteArray?, fieldOffset: Int): Short {
        if (ctx == null) return value
        val data = ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).putShort(value).array()
        val decrypted = decryptBytes(data, ctx, fieldOffset)
        return ByteBuffer.wrap(decrypted).order(ByteOrder.LITTLE_ENDIAN).getShort()
    }

    fun decryptScalar(value: Int, ctx: ByteArray?, fieldOffset: Int): Int {
        if (ctx == null) return value
        val data = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value).array()
        val decrypted = decryptBytes(data, ctx, fieldOffset)
        return ByteBuffer.wrap(decrypted).order(ByteOrder.LITTLE_ENDIAN).getInt()
    }

    fun decryptScalar(value: Long, ctx: ByteArray?, fieldOffset: Int): Long {
        if (ctx == null) return value
        val data = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putLong(value).array()
        val decrypted = decryptBytes(data, ctx, fieldOffset)
        return ByteBuffer.wrap(decrypted).order(ByteOrder.LITTLE_ENDIAN).getLong()
    }

    fun decryptScalar(value: Float, ctx: ByteArray?, fieldOffset: Int): Float {
        if (ctx == null) return value
        val data = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putFloat(value).array()
        val decrypted = decryptBytes(data, ctx, fieldOffset)
        return ByteBuffer.wrap(decrypted).order(ByteOrder.LITTLE_ENDIAN).getFloat()
    }

    fun decryptScalar(value: Double, ctx: ByteArray?, fieldOffset: Int): Double {
        if (ctx == null) return value
        val data = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN).putDouble(value).array()
        val decrypted = decryptBytes(data, ctx, fieldOffset)
        return ByteBuffer.wrap(decrypted).order(ByteOrder.LITTLE_ENDIAN).getDouble()
    }

    fun decryptScalar(value: UByte, ctx: ByteArray?, fieldOffset: Int): UByte {
        return decryptScalar(value.toByte(), ctx, fieldOffset).toUByte()
    }

    fun decryptScalar(value: UShort, ctx: ByteArray?, fieldOffset: Int): UShort {
        return decryptScalar(value.toShort(), ctx, fieldOffset).toUShort()
    }

    fun decryptScalar(value: UInt, ctx: ByteArray?, fieldOffset: Int): UInt {
        return decryptScalar(value.toInt(), ctx, fieldOffset).toUInt()
    }

    fun decryptScalar(value: ULong, ctx: ByteArray?, fieldOffset: Int): ULong {
        return decryptScalar(value.toLong(), ctx, fieldOffset).toULong()
    }

    fun decryptString(bb: ByteBuffer, offset: Int, ctx: ByteArray?, fieldOffset: Int): String? {
        // Read raw bytes from the vector
        val pos = offset + bb.getInt(offset)
        val len = bb.getInt(pos)
        val data = ByteArray(len)
        for (i in 0 until len) data[i] = bb.get(pos + 4 + i)
        if (ctx == null) {
            // No encryption context, decode as regular string
            return String(data, Charsets.UTF_8)
        }
        // Decrypt and decode
        val decrypted = decryptBytes(data, ctx, fieldOffset)
        return String(decrypted, Charsets.UTF_8)
    }
}

