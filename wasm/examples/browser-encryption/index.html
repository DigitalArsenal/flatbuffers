<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FlatBuffers Encryption Demo</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
    }
    .card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .card h2 {
      margin-top: 0;
      color: #2563eb;
    }
    textarea, input[type="text"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
      font-size: 14px;
    }
    textarea {
      height: 150px;
      resize: vertical;
    }
    button {
      background: #2563eb;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin: 5px 5px 5px 0;
    }
    button:hover {
      background: #1d4ed8;
    }
    button:disabled {
      background: #9ca3af;
      cursor: not-allowed;
    }
    .output {
      background: #1e293b;
      color: #e2e8f0;
      padding: 15px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 300px;
      overflow-y: auto;
    }
    .success {
      color: #22c55e;
    }
    .error {
      color: #ef4444;
    }
    .info {
      color: #3b82f6;
    }
    label {
      display: block;
      margin: 10px 0 5px;
      font-weight: 500;
    }
    .hex-display {
      font-family: monospace;
      font-size: 12px;
      word-break: break-all;
    }
    .row {
      display: flex;
      gap: 20px;
    }
    .col {
      flex: 1;
    }
    #status {
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
    #status.loading {
      background: #fef3c7;
      color: #92400e;
    }
    #status.ready {
      background: #d1fae5;
      color: #065f46;
    }
    #status.error {
      background: #fee2e2;
      color: #991b1b;
    }
  </style>
</head>
<body>
  <h1>üîê FlatBuffers Encryption Demo</h1>

  <div id="status" class="loading">Loading flatc-wasm...</div>

  <div class="card">
    <h2>1. Schema</h2>
    <p>Define your schema with <code>(encrypted)</code> attributes on sensitive fields:</p>
    <textarea id="schema">table UserData {
  user_id: uint64;
  username: string;
  password_hash: string (encrypted);
  balance: double (encrypted);
  notes: string;
}
root_type UserData;</textarea>
  </div>

  <div class="card">
    <h2>2. JSON Data</h2>
    <p>Enter the data to be serialized:</p>
    <textarea id="json-input">{
  "user_id": 12345,
  "username": "alice",
  "password_hash": "secret_hash_abc123",
  "balance": 1000.50,
  "notes": "This is a public note"
}</textarea>
  </div>

  <div class="card">
    <h2>3. Encryption Key</h2>
    <p>256-bit key (64 hex characters):</p>
    <input type="text" id="encryption-key" placeholder="Generate or enter a 64-character hex key">
    <button onclick="generateKey()">üé≤ Generate Random Key</button>
  </div>

  <div class="card">
    <h2>4. Operations</h2>
    <button onclick="createBuffer()" id="btn-create">Create FlatBuffer</button>
    <button onclick="encryptBuffer()" id="btn-encrypt" disabled>Encrypt</button>
    <button onclick="decryptBuffer()" id="btn-decrypt" disabled>Decrypt</button>
    <button onclick="readBuffer()" id="btn-read" disabled>Read as JSON</button>
    <button onclick="compareBuffers()" id="btn-compare" disabled>Compare Original vs Encrypted</button>
  </div>

  <div class="card">
    <h2>5. Output</h2>
    <div class="row">
      <div class="col">
        <label>Buffer (hex):</label>
        <div id="buffer-hex" class="output hex-display">No buffer created yet</div>
      </div>
      <div class="col">
        <label>Log:</label>
        <div id="log" class="output"></div>
      </div>
    </div>
  </div>

  <div class="card">
    <h2>How It Works</h2>
    <ul>
      <li><strong>Create FlatBuffer</strong>: Converts JSON to binary FlatBuffer format</li>
      <li><strong>Encrypt</strong>: Encrypts fields marked with <code>(encrypted)</code> in-place</li>
      <li><strong>Decrypt</strong>: Restores encrypted fields (same operation as encrypt for AES-CTR)</li>
      <li><strong>Read as JSON</strong>: Converts buffer back to JSON (will show garbage if encrypted)</li>
      <li><strong>Compare</strong>: Shows which bytes changed after encryption</li>
    </ul>
    <p><strong>Key insight:</strong> The encrypted buffer maintains valid FlatBuffer structure. Only the field <em>values</em> are encrypted, not the schema/offsets.</p>
  </div>

  <!-- Import from CDN or local -->
  <script type="module">
    // Import encryption module (adjust path as needed)
    // For production, use: import { ... } from 'https://esm.sh/flatc-wasm@latest'

    // For this demo, we'll use the local build
    // In real usage, you'd import from npm/CDN

    // Inline the encryption implementation for the demo
    // (In production, import from flatc-wasm/encryption)

    const SBOX = new Uint8Array([
      0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,
      0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
      0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26,
      0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
      0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,
      0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
      0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed,
      0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
      0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,
      0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
      0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec,
      0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
      0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,
      0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
      0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,
      0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
      0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,
      0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
      0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11,
      0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
      0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,
      0xb0, 0x54, 0xbb, 0x16
    ]);

    const RCON = new Uint8Array([0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]);

    function gfMul(a, b) {
      let p = 0;
      for (let i = 0; i < 8; i++) {
        if (b & 1) p ^= a;
        const hiBit = a & 0x80;
        a = (a << 1) & 0xff;
        if (hiBit) a ^= 0x1b;
        b >>= 1;
      }
      return p;
    }

    function aes256KeyExpansion(key) {
      const roundKeys = new Uint8Array(240);
      roundKeys.set(key);
      const temp = new Uint8Array(4);
      let i = 8;
      while (i < 60) {
        temp.set(roundKeys.subarray((i - 1) * 4, i * 4));
        if (i % 8 === 0) {
          const t = temp[0];
          temp[0] = SBOX[temp[1]] ^ RCON[i / 8];
          temp[1] = SBOX[temp[2]];
          temp[2] = SBOX[temp[3]];
          temp[3] = SBOX[t];
        } else if (i % 8 === 4) {
          for (let j = 0; j < 4; j++) temp[j] = SBOX[temp[j]];
        }
        for (let j = 0; j < 4; j++) {
          roundKeys[i * 4 + j] = roundKeys[(i - 8) * 4 + j] ^ temp[j];
        }
        i++;
      }
      return roundKeys;
    }

    function aesEncryptBlock(key, input) {
      const roundKeys = aes256KeyExpansion(key);
      const state = new Uint8Array(input);

      // AddRoundKey
      for (let i = 0; i < 16; i++) state[i] ^= roundKeys[i];

      for (let round = 1; round < 14; round++) {
        // SubBytes
        for (let i = 0; i < 16; i++) state[i] = SBOX[state[i]];
        // ShiftRows
        let t = state[1]; state[1] = state[5]; state[5] = state[9]; state[9] = state[13]; state[13] = t;
        t = state[2]; state[2] = state[10]; state[10] = t;
        t = state[6]; state[6] = state[14]; state[14] = t;
        t = state[15]; state[15] = state[11]; state[11] = state[7]; state[7] = state[3]; state[3] = t;
        // MixColumns
        for (let i = 0; i < 4; i++) {
          const a = [state[i*4], state[i*4+1], state[i*4+2], state[i*4+3]];
          state[i*4+0] = gfMul(a[0], 2) ^ gfMul(a[1], 3) ^ a[2] ^ a[3];
          state[i*4+1] = a[0] ^ gfMul(a[1], 2) ^ gfMul(a[2], 3) ^ a[3];
          state[i*4+2] = a[0] ^ a[1] ^ gfMul(a[2], 2) ^ gfMul(a[3], 3);
          state[i*4+3] = gfMul(a[0], 3) ^ a[1] ^ a[2] ^ gfMul(a[3], 2);
        }
        // AddRoundKey
        for (let i = 0; i < 16; i++) state[i] ^= roundKeys[round * 16 + i];
      }

      // Final round
      for (let i = 0; i < 16; i++) state[i] = SBOX[state[i]];
      let t = state[1]; state[1] = state[5]; state[5] = state[9]; state[9] = state[13]; state[13] = t;
      t = state[2]; state[2] = state[10]; state[10] = t;
      t = state[6]; state[6] = state[14]; state[14] = t;
      t = state[15]; state[15] = state[11]; state[11] = state[7]; state[7] = state[3]; state[3] = t;
      for (let i = 0; i < 16; i++) state[i] ^= roundKeys[14 * 16 + i];

      return state;
    }

    function aesCtrKeystream(key, nonce, length) {
      const keystream = new Uint8Array(length);
      const counter = new Uint8Array(nonce);
      let offset = 0;
      while (offset < length) {
        const block = aesEncryptBlock(key, counter);
        const toCopy = Math.min(16, length - offset);
        keystream.set(block.subarray(0, toCopy), offset);
        offset += toCopy;
        for (let i = 15; i >= 0; i--) {
          counter[i]++;
          if (counter[i] !== 0) break;
        }
      }
      return keystream;
    }

    function deriveKey(masterKey, info, outLength) {
      const out = new Uint8Array(outLength);
      for (let i = 0; i < Math.min(outLength, masterKey.length); i++) out[i] = masterKey[i];
      let hash = 0;
      for (let i = 0; i < info.length; i++) {
        hash ^= info[i];
        hash = ((hash << 1) | (hash >> 7)) & 0xff;
      }
      for (let i = 0; i < outLength; i++) {
        out[i] ^= hash;
        hash = (hash * 31 + i) & 0xff;
      }
      if (outLength >= 16) {
        const temp = aesEncryptBlock(masterKey, out.subarray(0, 16));
        out.set(temp.subarray(0, Math.min(outLength, 16)));
        if (outLength > 16) {
          const temp2 = aesEncryptBlock(masterKey, temp);
          out.set(temp2.subarray(0, Math.min(outLength - 16, 16)), 16);
        }
      }
      return out;
    }

    class EncryptionContext {
      #key;
      constructor(key) {
        if (typeof key === 'string') {
          this.#key = new Uint8Array(key.length / 2);
          for (let i = 0; i < key.length; i += 2) {
            this.#key[i / 2] = parseInt(key.substring(i, i + 2), 16);
          }
        } else {
          this.#key = new Uint8Array(key);
        }
      }
      isValid() { return this.#key.length === 32; }
      deriveFieldKey(fieldId) {
        const info = new Uint8Array(19);
        const s = 'flatbuffers-field';
        for (let i = 0; i < s.length; i++) info[i] = s.charCodeAt(i);
        info[17] = (fieldId >> 8) & 0xff;
        info[18] = fieldId & 0xff;
        return deriveKey(this.#key, info, 32);
      }
      deriveFieldIV(fieldId) {
        const info = new Uint8Array(16);
        const s = 'flatbuffers-iv';
        for (let i = 0; i < s.length; i++) info[i] = s.charCodeAt(i);
        info[14] = (fieldId >> 8) & 0xff;
        info[15] = fieldId & 0xff;
        return deriveKey(this.#key, info, 16);
      }
    }

    function encryptBytes(data, key, iv) {
      const keystream = aesCtrKeystream(key, iv, data.length);
      for (let i = 0; i < data.length; i++) data[i] ^= keystream[i];
    }

    function parseSchemaForEncryption(schemaContent, rootType) {
      const schema = { fields: [] };
      const tableRegex = new RegExp(`table\\s+${rootType}\\s*\\{([^}]+)\\}`, 's');
      const match = schemaContent.match(tableRegex);
      if (!match) return schema;

      const tableBody = match[1];
      const fieldRegex = /(\w+)\s*:\s*(\[?\w+\]?)\s*(?:\(([^)]*)\))?/g;
      let fieldId = 0;
      let fieldMatch;

      while ((fieldMatch = fieldRegex.exec(tableBody)) !== null) {
        const isEncrypted = (fieldMatch[3] || '').includes('encrypted');
        const isVector = fieldMatch[2].startsWith('[') && fieldMatch[2].endsWith(']');
        const baseType = isVector ? fieldMatch[2].slice(1, -1) : fieldMatch[2];

        const sizes = { bool: 1, byte: 1, ubyte: 1, short: 2, ushort: 2, int: 4, uint: 4, float: 4, long: 8, ulong: 8, double: 8 };
        const scalarTypes = ['bool', 'byte', 'ubyte', 'short', 'ushort', 'int', 'uint', 'long', 'ulong', 'float', 'double'];

        schema.fields.push({
          name: fieldMatch[1],
          id: fieldId++,
          type: isVector ? 'vector' : (scalarTypes.includes(baseType) ? baseType : (baseType === 'string' ? 'string' : 'struct')),
          encrypted: isEncrypted,
          elementSize: sizes[baseType] || 1
        });
      }
      return schema;
    }

    function readUint32(buf, off) { return buf[off] | (buf[off+1] << 8) | (buf[off+2] << 16) | (buf[off+3] << 24) >>> 0; }
    function readInt32(buf, off) { return buf[off] | (buf[off+1] << 8) | (buf[off+2] << 16) | (buf[off+3] << 24); }
    function readUint16(buf, off) { return buf[off] | (buf[off+1] << 8); }

    function processTable(buffer, tableOffset, schema, ctx) {
      const vtableOffsetDelta = readInt32(buffer, tableOffset);
      const vtableOffset = tableOffset - vtableOffsetDelta;
      const vtableSize = readUint16(buffer, vtableOffset);

      for (const field of schema.fields) {
        const fieldVtableIdx = (field.id + 2) * 2;
        if (fieldVtableIdx >= vtableSize) continue;
        const fieldOffset = readUint16(buffer, vtableOffset + fieldVtableIdx);
        if (fieldOffset === 0) continue;
        const fieldLoc = tableOffset + fieldOffset;
        if (!field.encrypted) continue;

        const key = ctx.deriveFieldKey(field.id);
        const iv = ctx.deriveFieldIV(field.id);

        const sizes = { bool: 1, byte: 1, ubyte: 1, short: 2, ushort: 2, int: 4, uint: 4, float: 4, long: 8, ulong: 8, double: 8 };
        if (sizes[field.type]) {
          encryptBytes(buffer.subarray(fieldLoc, fieldLoc + sizes[field.type]), key, iv);
        } else if (field.type === 'string') {
          const strOffset = readUint32(buffer, fieldLoc);
          const strLoc = fieldLoc + strOffset;
          const strLen = readUint32(buffer, strLoc);
          encryptBytes(buffer.subarray(strLoc + 4, strLoc + 4 + strLen), key, iv);
        } else if (field.type === 'vector') {
          const vecOffset = readUint32(buffer, fieldLoc);
          const vecLoc = fieldLoc + vecOffset;
          const vecLen = readUint32(buffer, vecLoc);
          encryptBytes(buffer.subarray(vecLoc + 4, vecLoc + 4 + vecLen * field.elementSize), key, iv);
        }
      }
    }

    function encryptBufferImpl(buffer, schema, key, rootType) {
      const ctx = typeof key === 'string' || key instanceof Uint8Array ? new EncryptionContext(key) : key;
      if (!ctx.isValid()) throw new Error('Invalid key');
      const parsedSchema = typeof schema === 'string' ? parseSchemaForEncryption(schema, rootType) : schema;
      const rootOffset = readUint32(buffer, 0);
      processTable(buffer, rootOffset, parsedSchema, ctx);
      return buffer;
    }

    // Global state
    let flatc = null;
    let currentBuffer = null;
    let originalBuffer = null;

    // UI helpers
    const log = document.getElementById('log');
    const bufferHex = document.getElementById('buffer-hex');
    const status = document.getElementById('status');

    function appendLog(msg, className = '') {
      const line = document.createElement('div');
      line.textContent = msg;
      if (className) line.className = className;
      log.appendChild(line);
      log.scrollTop = log.scrollHeight;
    }

    function clearLog() {
      log.innerHTML = '';
    }

    function toHex(arr) {
      return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join(' ');
    }

    function updateBufferDisplay() {
      if (currentBuffer) {
        bufferHex.textContent = toHex(currentBuffer);
      }
    }

    // Operations
    window.generateKey = function() {
      const key = crypto.getRandomValues(new Uint8Array(32));
      document.getElementById('encryption-key').value = Array.from(key).map(b => b.toString(16).padStart(2, '0')).join('');
      appendLog('Generated new 256-bit key', 'success');
    };

    window.createBuffer = async function() {
      clearLog();
      appendLog('Creating FlatBuffer...', 'info');

      try {
        const schema = document.getElementById('schema').value;
        const json = document.getElementById('json-input').value;

        // Parse to validate JSON
        JSON.parse(json);

        // Extract root type from schema
        const rootMatch = schema.match(/root_type\s+(\w+)/);
        if (!rootMatch) throw new Error('No root_type found in schema');
        const rootType = rootMatch[1];

        const schemaInput = {
          entry: '/schema.fbs',
          files: { '/schema.fbs': schema }
        };

        currentBuffer = flatc.generateBinary(schemaInput, json);
        originalBuffer = new Uint8Array(currentBuffer);

        appendLog(`Created buffer: ${currentBuffer.length} bytes`, 'success');
        updateBufferDisplay();

        document.getElementById('btn-encrypt').disabled = false;
        document.getElementById('btn-read').disabled = false;
        document.getElementById('btn-compare').disabled = false;
      } catch (e) {
        appendLog(`Error: ${e.message}`, 'error');
      }
    };

    window.encryptBuffer = function() {
      appendLog('Encrypting buffer...', 'info');

      try {
        const keyHex = document.getElementById('encryption-key').value;
        if (keyHex.length !== 64) throw new Error('Key must be 64 hex characters (256 bits)');

        const schema = document.getElementById('schema').value;
        const rootMatch = schema.match(/root_type\s+(\w+)/);
        const rootType = rootMatch[1];

        encryptBufferImpl(currentBuffer, schema, keyHex, rootType);

        appendLog('Buffer encrypted!', 'success');
        updateBufferDisplay();
        document.getElementById('btn-decrypt').disabled = false;
      } catch (e) {
        appendLog(`Error: ${e.message}`, 'error');
      }
    };

    window.decryptBuffer = function() {
      appendLog('Decrypting buffer...', 'info');

      try {
        const keyHex = document.getElementById('encryption-key').value;
        const schema = document.getElementById('schema').value;
        const rootMatch = schema.match(/root_type\s+(\w+)/);
        const rootType = rootMatch[1];

        encryptBufferImpl(currentBuffer, schema, keyHex, rootType);

        appendLog('Buffer decrypted!', 'success');
        updateBufferDisplay();
      } catch (e) {
        appendLog(`Error: ${e.message}`, 'error');
      }
    };

    window.readBuffer = function() {
      appendLog('Reading buffer as JSON...', 'info');

      try {
        const schema = document.getElementById('schema').value;
        const schemaInput = {
          entry: '/schema.fbs',
          files: { '/schema.fbs': schema }
        };

        const json = flatc.generateJSON(schemaInput, { path: '/data.bin', data: currentBuffer });
        appendLog('JSON output:', 'info');
        appendLog(JSON.stringify(JSON.parse(json), null, 2));
      } catch (e) {
        appendLog(`Error reading buffer: ${e.message}`, 'error');
        appendLog('(This may be expected if buffer is encrypted and strings contain invalid UTF-8)', 'info');
      }
    };

    window.compareBuffers = function() {
      if (!originalBuffer || !currentBuffer) return;

      appendLog('Comparing original vs current buffer:', 'info');

      let diffCount = 0;
      for (let i = 0; i < originalBuffer.length; i++) {
        if (originalBuffer[i] !== currentBuffer[i]) {
          diffCount++;
        }
      }

      if (diffCount === 0) {
        appendLog('Buffers are identical', 'success');
      } else {
        appendLog(`${diffCount} bytes differ (${((diffCount / originalBuffer.length) * 100).toFixed(1)}% of buffer)`, 'info');
      }
    };

    // Initialize
    async function init() {
      try {
        // Try to load flatc-wasm
        // In production, import from npm/CDN
        const module = await import('../../src/index.mjs');
        const { FlatcRunner } = module;

        flatc = await FlatcRunner.init();
        status.textContent = `‚úÖ Ready! flatc ${flatc.version()}`;
        status.className = 'ready';

        appendLog('flatc-wasm loaded successfully', 'success');
        appendLog(`Version: ${flatc.version()}`, 'info');
      } catch (e) {
        status.textContent = `‚ùå Failed to load flatc-wasm: ${e.message}`;
        status.className = 'error';
        appendLog(`Failed to load: ${e.message}`, 'error');
        appendLog('Make sure you have built the WASM module', 'info');
      }
    }

    init();
  </script>
</body>
</html>
