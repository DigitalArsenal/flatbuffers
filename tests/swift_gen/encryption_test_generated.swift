// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

#if canImport(Common)
import Common
#endif

import FlatBuffers

public struct EncryptionTest_Coordinates: NativeStruct, FlatbuffersVectorInitializable, Verifiable, FlatbuffersInitializable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }

  private var _lat: Double
  private var _lon: Double

  public init(_ bb: ByteBuffer, o: Int32) {
    self = bb.read(def: Self.self, position: Int(o))
  }

  public init(lat: Double, lon: Double) {
    _lat = lat
    _lon = lon
  }

  public init() {
    _lat = 0.0
    _lon = 0.0
  }

  public var lat: Double { _lat }
  public var lon: Double { _lon }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    try verifier.inBuffer(position: position, of: EncryptionTest_Coordinates.self)
  }
}

public struct EncryptionTest_Coordinates_Mutable: FlatBufferStruct, FlatbuffersVectorInitializable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Struct

  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

  public var lat: Double { return _accessor.readBuffer(of: Double.self, at: 0) }
  public var lon: Double { return _accessor.readBuffer(of: Double.self, at: 8) }
}

public struct EncryptionTest_PublicData: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case label = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: UInt64 { let o = _accessor.offset(VTOFFSET.id.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var label: String? { let o = _accessor.offset(VTOFFSET.label.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var labelSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.label.v) }
  public static func startPublicData(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(id: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: id, def: 0, at: VTOFFSET.id.p) }
  public static func add(label: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: label, at: VTOFFSET.label.p) }
  public static func endPublicData(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPublicData(
    _ fbb: inout FlatBufferBuilder,
    id: UInt64 = 0,
    labelOffset label: Offset = Offset()
  ) -> Offset {
    let __start = EncryptionTest_PublicData.startPublicData(&fbb)
    EncryptionTest_PublicData.add(id: id, &fbb)
    EncryptionTest_PublicData.add(label: label, &fbb)
    return EncryptionTest_PublicData.endPublicData(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.label.p, fieldName: "label", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct EncryptionTest_SensorReading: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  /// Encryption context for decrypting encrypted fields
  public var encryptionCtx: [UInt8]?

  private init(_ t: Table, encryptionCtx: [UInt8]? = nil) { _accessor = t; self.encryptionCtx = encryptionCtx }
  public init(_ bb: ByteBuffer, o: Int32, encryptionCtx: [UInt8]? = nil) { _accessor = Table(bb: bb, position: o); self.encryptionCtx = encryptionCtx }

  private enum VTOFFSET: VOffset {
    case deviceId = 4
    case timestamp = 6
    case publicData = 8
    case location = 10
    case temperature = 12
    case rawData = 14
    case secretMessage = 16
    case readings = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var deviceId: String? { let o = _accessor.offset(VTOFFSET.deviceId.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var deviceIdSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.deviceId.v) }
  public var timestamp: UInt64 { let o = _accessor.offset(VTOFFSET.timestamp.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var publicData: EncryptionTest_PublicData? { let o = _accessor.offset(VTOFFSET.publicData.v); return o == 0 ? nil : EncryptionTest_PublicData(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var location: EncryptionTest_Coordinates? { let o = _accessor.offset(VTOFFSET.location.v); return o == 0 ? nil : _accessor.readBuffer(of: EncryptionTest_Coordinates.self, at: o) }
  public var mutableLocation: EncryptionTest_Coordinates_Mutable? { let o = _accessor.offset(VTOFFSET.location.v); return o == 0 ? nil : EncryptionTest_Coordinates_Mutable(_accessor.bb, o: o + _accessor.position) }
  public var temperature: Float32 { let o = _accessor.offset(VTOFFSET.temperature.v); return o == 0 ? 0.0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: Float32.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 12) }
  public var rawData: FlatbufferVector<UInt8> { return _accessor.vector(at: VTOFFSET.rawData.v, byteSize: 1) }
  public func withUnsafePointerToRawData<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.rawData.v, body: body) }
  public var secretMessage: String? { let o = _accessor.offset(VTOFFSET.secretMessage.v); return o == 0 ? nil : FlatbuffersEncryption.decryptString(_accessor.string(at: o), encryptionCtx: self.encryptionCtx, fieldId: 16) }
  public var secretMessageSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.secretMessage.v) }
  public var readings: FlatbufferVector<Float32> { return _accessor.vector(at: VTOFFSET.readings.v, byteSize: 4) }
  public func withUnsafePointerToReadings<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.readings.v, body: body) }
  public static func startSensorReading(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(deviceId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: deviceId, at: VTOFFSET.deviceId.p) }
  public static func add(timestamp: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: timestamp, def: 0, at: VTOFFSET.timestamp.p) }
  public static func add(publicData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: publicData, at: VTOFFSET.publicData.p) }
  public static func add(location: EncryptionTest_Coordinates?, _ fbb: inout FlatBufferBuilder) { guard let location = location else { return }; fbb.create(struct: location, position: VTOFFSET.location.p) }
  public static func add(temperature: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: temperature, def: 0.0, at: VTOFFSET.temperature.p) }
  public static func addVectorOf(rawData: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rawData, at: VTOFFSET.rawData.p) }
  public static func add(secretMessage: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: secretMessage, at: VTOFFSET.secretMessage.p) }
  public static func addVectorOf(readings: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: readings, at: VTOFFSET.readings.p) }
  public static func endSensorReading(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSensorReading(
    _ fbb: inout FlatBufferBuilder,
    deviceIdOffset deviceId: Offset = Offset(),
    timestamp: UInt64 = 0,
    publicDataOffset publicData: Offset = Offset(),
    location: EncryptionTest_Coordinates? = nil,
    temperature: Float32 = 0.0,
    rawDataVectorOffset rawData: Offset = Offset(),
    secretMessageOffset secretMessage: Offset = Offset(),
    readingsVectorOffset readings: Offset = Offset()
  ) -> Offset {
    let __start = EncryptionTest_SensorReading.startSensorReading(&fbb)
    EncryptionTest_SensorReading.add(deviceId: deviceId, &fbb)
    EncryptionTest_SensorReading.add(timestamp: timestamp, &fbb)
    EncryptionTest_SensorReading.add(publicData: publicData, &fbb)
    EncryptionTest_SensorReading.add(location: location, &fbb)
    EncryptionTest_SensorReading.add(temperature: temperature, &fbb)
    EncryptionTest_SensorReading.addVectorOf(rawData: rawData, &fbb)
    EncryptionTest_SensorReading.add(secretMessage: secretMessage, &fbb)
    EncryptionTest_SensorReading.addVectorOf(readings: readings, &fbb)
    return EncryptionTest_SensorReading.endSensorReading(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.deviceId.p, fieldName: "deviceId", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.timestamp.p, fieldName: "timestamp", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.publicData.p, fieldName: "publicData", required: false, type: ForwardOffset<EncryptionTest_PublicData>.self)
    try _v.visit(field: VTOFFSET.location.p, fieldName: "location", required: false, type: EncryptionTest_Coordinates.self)
    try _v.visit(field: VTOFFSET.temperature.p, fieldName: "temperature", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.rawData.p, fieldName: "rawData", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.secretMessage.p, fieldName: "secretMessage", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.readings.p, fieldName: "readings", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    _v.finish()
  }
}

public struct EncryptionTest_UserRecord: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  /// Encryption context for decrypting encrypted fields
  public var encryptionCtx: [UInt8]?

  private init(_ t: Table, encryptionCtx: [UInt8]? = nil) { _accessor = t; self.encryptionCtx = encryptionCtx }
  public init(_ bb: ByteBuffer, o: Int32, encryptionCtx: [UInt8]? = nil) { _accessor = Table(bb: bb, position: o); self.encryptionCtx = encryptionCtx }

  private enum VTOFFSET: VOffset {
    case userId = 4
    case username = 6
    case passwordHash = 8
    case privateKey = 10
    case ssn = 12
    case balance = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var userId: UInt64 { let o = _accessor.offset(VTOFFSET.userId.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var username: String? { let o = _accessor.offset(VTOFFSET.username.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var usernameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.username.v) }
  public var passwordHash: String? { let o = _accessor.offset(VTOFFSET.passwordHash.v); return o == 0 ? nil : FlatbuffersEncryption.decryptString(_accessor.string(at: o), encryptionCtx: self.encryptionCtx, fieldId: 8) }
  public var passwordHashSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.passwordHash.v) }
  public var privateKey: FlatbufferVector<UInt8> { return _accessor.vector(at: VTOFFSET.privateKey.v, byteSize: 1) }
  public func withUnsafePointerToPrivateKey<T>(_ body: (UnsafeRawBufferPointer, Int) throws -> T) rethrows -> T? { return try _accessor.withUnsafePointerToSlice(at: VTOFFSET.privateKey.v, body: body) }
  public var ssn: String? { let o = _accessor.offset(VTOFFSET.ssn.v); return o == 0 ? nil : FlatbuffersEncryption.decryptString(_accessor.string(at: o), encryptionCtx: self.encryptionCtx, fieldId: 12) }
  public var ssnSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.ssn.v) }
  public var balance: Double { let o = _accessor.offset(VTOFFSET.balance.v); return o == 0 ? 0.0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: Double.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 14) }
  public static func startUserRecord(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(userId: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: userId, def: 0, at: VTOFFSET.userId.p) }
  public static func add(username: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: username, at: VTOFFSET.username.p) }
  public static func add(passwordHash: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: passwordHash, at: VTOFFSET.passwordHash.p) }
  public static func addVectorOf(privateKey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: privateKey, at: VTOFFSET.privateKey.p) }
  public static func add(ssn: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ssn, at: VTOFFSET.ssn.p) }
  public static func add(balance: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: balance, def: 0.0, at: VTOFFSET.balance.p) }
  public static func endUserRecord(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUserRecord(
    _ fbb: inout FlatBufferBuilder,
    userId: UInt64 = 0,
    usernameOffset username: Offset = Offset(),
    passwordHashOffset passwordHash: Offset = Offset(),
    privateKeyVectorOffset privateKey: Offset = Offset(),
    ssnOffset ssn: Offset = Offset(),
    balance: Double = 0.0
  ) -> Offset {
    let __start = EncryptionTest_UserRecord.startUserRecord(&fbb)
    EncryptionTest_UserRecord.add(userId: userId, &fbb)
    EncryptionTest_UserRecord.add(username: username, &fbb)
    EncryptionTest_UserRecord.add(passwordHash: passwordHash, &fbb)
    EncryptionTest_UserRecord.addVectorOf(privateKey: privateKey, &fbb)
    EncryptionTest_UserRecord.add(ssn: ssn, &fbb)
    EncryptionTest_UserRecord.add(balance: balance, &fbb)
    return EncryptionTest_UserRecord.endUserRecord(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.userId.p, fieldName: "userId", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.username.p, fieldName: "username", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.passwordHash.p, fieldName: "passwordHash", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.privateKey.p, fieldName: "privateKey", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.ssn.p, fieldName: "ssn", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.balance.p, fieldName: "balance", required: false, type: Double.self)
    _v.finish()
  }
}

public struct EncryptionTest_ScalarTest: FlatBufferTable, FlatbuffersVectorInitializable, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_12_19() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  /// Encryption context for decrypting encrypted fields
  public var encryptionCtx: [UInt8]?

  private init(_ t: Table, encryptionCtx: [UInt8]? = nil) { _accessor = t; self.encryptionCtx = encryptionCtx }
  public init(_ bb: ByteBuffer, o: Int32, encryptionCtx: [UInt8]? = nil) { _accessor = Table(bb: bb, position: o); self.encryptionCtx = encryptionCtx }

  private enum VTOFFSET: VOffset {
    case encryptedBool = 4
    case encryptedByte = 6
    case encryptedUbyte = 8
    case encryptedShort = 10
    case encryptedUshort = 12
    case encryptedInt = 14
    case encryptedUint = 16
    case encryptedLong = 18
    case encryptedUlong = 20
    case encryptedFloat = 22
    case encryptedDouble = 24
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var encryptedBool: Bool { let o = _accessor.offset(VTOFFSET.encryptedBool.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var encryptedByte: Int8 { let o = _accessor.offset(VTOFFSET.encryptedByte.v); return o == 0 ? 0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: Int8.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 6) }
  public var encryptedUbyte: UInt8 { let o = _accessor.offset(VTOFFSET.encryptedUbyte.v); return o == 0 ? 0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: UInt8.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 8) }
  public var encryptedShort: Int16 { let o = _accessor.offset(VTOFFSET.encryptedShort.v); return o == 0 ? 0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: Int16.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 10) }
  public var encryptedUshort: UInt16 { let o = _accessor.offset(VTOFFSET.encryptedUshort.v); return o == 0 ? 0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: UInt16.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 12) }
  public var encryptedInt: Int32 { let o = _accessor.offset(VTOFFSET.encryptedInt.v); return o == 0 ? 0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: Int32.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 14) }
  public var encryptedUint: UInt32 { let o = _accessor.offset(VTOFFSET.encryptedUint.v); return o == 0 ? 0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: UInt32.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 16) }
  public var encryptedLong: Int64 { let o = _accessor.offset(VTOFFSET.encryptedLong.v); return o == 0 ? 0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: Int64.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 18) }
  public var encryptedUlong: UInt64 { let o = _accessor.offset(VTOFFSET.encryptedUlong.v); return o == 0 ? 0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: UInt64.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 20) }
  public var encryptedFloat: Float32 { let o = _accessor.offset(VTOFFSET.encryptedFloat.v); return o == 0 ? 0.0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: Float32.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 22) }
  public var encryptedDouble: Double { let o = _accessor.offset(VTOFFSET.encryptedDouble.v); return o == 0 ? 0.0 : FlatbuffersEncryption.decryptScalar(_accessor.readBuffer(of: Double.self, at: o), encryptionCtx: self.encryptionCtx, fieldId: 24) }
  public static func startScalarTest(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 11) }
  public static func add(encryptedBool: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptedBool, def: false,
   at: VTOFFSET.encryptedBool.p) }
  public static func add(encryptedByte: Int8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptedByte, def: 0, at: VTOFFSET.encryptedByte.p) }
  public static func add(encryptedUbyte: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptedUbyte, def: 0, at: VTOFFSET.encryptedUbyte.p) }
  public static func add(encryptedShort: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptedShort, def: 0, at: VTOFFSET.encryptedShort.p) }
  public static func add(encryptedUshort: UInt16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptedUshort, def: 0, at: VTOFFSET.encryptedUshort.p) }
  public static func add(encryptedInt: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptedInt, def: 0, at: VTOFFSET.encryptedInt.p) }
  public static func add(encryptedUint: UInt32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptedUint, def: 0, at: VTOFFSET.encryptedUint.p) }
  public static func add(encryptedLong: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptedLong, def: 0, at: VTOFFSET.encryptedLong.p) }
  public static func add(encryptedUlong: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptedUlong, def: 0, at: VTOFFSET.encryptedUlong.p) }
  public static func add(encryptedFloat: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptedFloat, def: 0.0, at: VTOFFSET.encryptedFloat.p) }
  public static func add(encryptedDouble: Double, _ fbb: inout FlatBufferBuilder) { fbb.add(element: encryptedDouble, def: 0.0, at: VTOFFSET.encryptedDouble.p) }
  public static func endScalarTest(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createScalarTest(
    _ fbb: inout FlatBufferBuilder,
    encryptedBool: Bool = false,
    encryptedByte: Int8 = 0,
    encryptedUbyte: UInt8 = 0,
    encryptedShort: Int16 = 0,
    encryptedUshort: UInt16 = 0,
    encryptedInt: Int32 = 0,
    encryptedUint: UInt32 = 0,
    encryptedLong: Int64 = 0,
    encryptedUlong: UInt64 = 0,
    encryptedFloat: Float32 = 0.0,
    encryptedDouble: Double = 0.0
  ) -> Offset {
    let __start = EncryptionTest_ScalarTest.startScalarTest(&fbb)
    EncryptionTest_ScalarTest.add(encryptedBool: encryptedBool, &fbb)
    EncryptionTest_ScalarTest.add(encryptedByte: encryptedByte, &fbb)
    EncryptionTest_ScalarTest.add(encryptedUbyte: encryptedUbyte, &fbb)
    EncryptionTest_ScalarTest.add(encryptedShort: encryptedShort, &fbb)
    EncryptionTest_ScalarTest.add(encryptedUshort: encryptedUshort, &fbb)
    EncryptionTest_ScalarTest.add(encryptedInt: encryptedInt, &fbb)
    EncryptionTest_ScalarTest.add(encryptedUint: encryptedUint, &fbb)
    EncryptionTest_ScalarTest.add(encryptedLong: encryptedLong, &fbb)
    EncryptionTest_ScalarTest.add(encryptedUlong: encryptedUlong, &fbb)
    EncryptionTest_ScalarTest.add(encryptedFloat: encryptedFloat, &fbb)
    EncryptionTest_ScalarTest.add(encryptedDouble: encryptedDouble, &fbb)
    return EncryptionTest_ScalarTest.endScalarTest(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.encryptedBool.p, fieldName: "encryptedBool", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.encryptedByte.p, fieldName: "encryptedByte", required: false, type: Int8.self)
    try _v.visit(field: VTOFFSET.encryptedUbyte.p, fieldName: "encryptedUbyte", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.encryptedShort.p, fieldName: "encryptedShort", required: false, type: Int16.self)
    try _v.visit(field: VTOFFSET.encryptedUshort.p, fieldName: "encryptedUshort", required: false, type: UInt16.self)
    try _v.visit(field: VTOFFSET.encryptedInt.p, fieldName: "encryptedInt", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.encryptedUint.p, fieldName: "encryptedUint", required: false, type: UInt32.self)
    try _v.visit(field: VTOFFSET.encryptedLong.p, fieldName: "encryptedLong", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.encryptedUlong.p, fieldName: "encryptedUlong", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.encryptedFloat.p, fieldName: "encryptedFloat", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.encryptedDouble.p, fieldName: "encryptedDouble", required: false, type: Double.self)
    _v.finish()
  }
}

// MARK: - FlatbuffersEncryption

/// FlatBuffers field-level encryption support using AES-256-CTR.
/// Pure Swift implementation - no external dependencies.
public class FlatbuffersEncryption {

  private static let sbox: [UInt8] = [
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
  ]
  private static let rcon: [UInt8] = [0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36]

  private static func xtime(_ x: UInt8) -> UInt8 { ((x << 1) ^ ((x & 0x80) != 0 ? 0x1b : 0)) }

  private static func expandKey(_ key: [UInt8]) -> [UInt8] {
    var expanded = [UInt8](repeating: 0, count: 240)
    for i in 0..<32 { expanded[i] = key[i] }
    var rconIdx = 0
    var i = 32
    while i < 240 {
      var t = [expanded[i-4], expanded[i-3], expanded[i-2], expanded[i-1]]
      if i % 32 == 0 {
        t = [sbox[Int(t[1])] ^ rcon[rconIdx], sbox[Int(t[2])], sbox[Int(t[3])], sbox[Int(t[0])]]
        rconIdx += 1
      } else if i % 32 == 16 {
        t = [sbox[Int(t[0])], sbox[Int(t[1])], sbox[Int(t[2])], sbox[Int(t[3])]]
      }
      for j in 0..<4 { expanded[i + j] = expanded[i - 32 + j] ^ t[j] }
      i += 4
    }
    return expanded
  }

  private static func aesEncryptBlock(_ block: [UInt8], _ expandedKey: [UInt8]) -> [UInt8] {
    var state = block
    for i in 0..<16 { state[i] ^= expandedKey[i] }
    for round in 1...14 {
      for i in 0..<16 { state[i] = sbox[Int(state[i])] }
      let t1 = state[1]; state[1] = state[5]; state[5] = state[9]; state[9] = state[13]; state[13] = t1
      let t2 = state[2]; state[2] = state[10]; state[10] = t2
      let t6 = state[6]; state[6] = state[14]; state[14] = t6
      let t3 = state[15]; state[15] = state[11]; state[11] = state[7]; state[7] = state[3]; state[3] = t3
      if round < 14 {
        for c in 0..<4 {
          let idx = c * 4
          let (s0, s1, s2, s3) = (state[idx], state[idx+1], state[idx+2], state[idx+3])
          let x = s0 ^ s1 ^ s2 ^ s3
          state[idx] ^= x ^ xtime(s0 ^ s1)
          state[idx+1] ^= x ^ xtime(s1 ^ s2)
          state[idx+2] ^= x ^ xtime(s2 ^ s3)
          state[idx+3] ^= x ^ xtime(s3 ^ s0)
        }
      }
      let offset = round * 16
      for i in 0..<16 { state[i] ^= expandedKey[offset + i] }
    }
    return state
  }

  private static func incrementCounter(_ counter: inout [UInt8]) {
    for i in stride(from: 15, through: 0, by: -1) {
      counter[i] = counter[i] &+ 1
      if counter[i] != 0 { break }
    }
  }

  private static func deriveNonce(_ ctx: [UInt8], fieldId: Int) -> [UInt8] {
    var nonce = [UInt8](repeating: 0, count: 16)
    for i in 0..<12 { nonce[i] = ctx[i] }
    let fieldOffset = UInt32(fieldId)
    nonce[12] = UInt8(fieldOffset & 0xFF)
    nonce[13] = UInt8((fieldOffset >> 8) & 0xFF)
    nonce[14] = UInt8((fieldOffset >> 16) & 0xFF)
    nonce[15] = UInt8((fieldOffset >> 24) & 0xFF)
    return nonce
  }

  private static func decryptBytes(_ data: [UInt8], ctx: [UInt8], fieldId: Int) -> [UInt8] {
    guard ctx.count >= 32 else { return data }
    let key = Array(ctx[0..<32])
    var counter = deriveNonce(ctx, fieldId: fieldId)
    let expandedKey = expandKey(key)
    var result = [UInt8](repeating: 0, count: data.count)
    var i = 0
    while i < data.count {
      let keystream = aesEncryptBlock(counter, expandedKey)
      let blockLen = min(16, data.count - i)
      for j in 0..<blockLen { result[i + j] = data[i + j] ^ keystream[j] }
      incrementCounter(&counter)
      i += 16
    }
    return result
  }

  public static func decryptScalar<T: FixedWidthInteger>(_ value: T, encryptionCtx: [UInt8]?, fieldId: Int) -> T {
    guard let ctx = encryptionCtx, ctx.count >= 32 else { return value }
    let bytes = withUnsafeBytes(of: value.littleEndian) { Array($0) }
    let decrypted = decryptBytes(bytes, ctx: ctx, fieldId: fieldId)
    return decrypted.withUnsafeBytes { $0.load(as: T.self) }.littleEndian
  }

  public static func decryptScalar(_ value: Float, encryptionCtx: [UInt8]?, fieldId: Int) -> Float {
    guard let ctx = encryptionCtx, ctx.count >= 32 else { return value }
    let bits = value.bitPattern
    let bytes = withUnsafeBytes(of: bits.littleEndian) { Array($0) }
    let decrypted = decryptBytes(bytes, ctx: ctx, fieldId: fieldId)
    let decryptedBits = decrypted.withUnsafeBytes { $0.load(as: UInt32.self) }.littleEndian
    return Float(bitPattern: decryptedBits)
  }

  public static func decryptScalar(_ value: Double, encryptionCtx: [UInt8]?, fieldId: Int) -> Double {
    guard let ctx = encryptionCtx, ctx.count >= 32 else { return value }
    let bits = value.bitPattern
    let bytes = withUnsafeBytes(of: bits.littleEndian) { Array($0) }
    let decrypted = decryptBytes(bytes, ctx: ctx, fieldId: fieldId)
    let decryptedBits = decrypted.withUnsafeBytes { $0.load(as: UInt64.self) }.littleEndian
    return Double(bitPattern: decryptedBits)
  }

  public static func decryptString(_ value: String?, encryptionCtx: [UInt8]?, fieldId: Int) -> String? {
    guard let str = value, let ctx = encryptionCtx, ctx.count >= 32 else { return value }
    let bytes = Array(str.utf8)
    let decrypted = decryptBytes(bytes, ctx: ctx, fieldId: fieldId)
    return String(bytes: decrypted, encoding: .utf8)
  }
}

