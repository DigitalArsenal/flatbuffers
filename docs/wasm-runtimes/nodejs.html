<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Nodejs - DA FlatBuffers</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown-dark.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #000000;
      --bg-secondary: rgba(42, 42, 45, 0.72);
      --bg-tertiary: rgba(66, 66, 69, 0.72);
      --accent-primary: #3b82f6;
      --accent-secondary: #60a5fa;
      --text-primary: #F5F5F7;
      --text-secondary: rgba(255, 255, 255, 0.6);
      --border-color: rgba(59, 130, 246, 0.3);
      --glow-color: rgba(59, 130, 246, 0.15);
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      margin: 0;
      padding: 0;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
    }

    /* Animated background */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(ellipse at 20% 20%, rgba(59, 130, 246, 0.06) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(59, 130, 246, 0.04) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(59, 130, 246, 0.03) 0%, transparent 70%);
      pointer-events: none;
      z-index: 0;
    }

    /* Grid pattern overlay */
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        linear-gradient(rgba(59, 130, 246, 0.02) 1px, transparent 1px),
        linear-gradient(90deg, rgba(59, 130, 246, 0.02) 1px, transparent 1px);
      background-size: 50px 50px;
      pointer-events: none;
      z-index: 0;
    }

    .page-container {
      position: relative;
      z-index: 1;
      max-width: 900px;
      margin: 0 auto;
      padding: 40px 20px;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      margin-bottom: 30px;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--accent-secondary);
      text-decoration: none;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    .back-link:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent-primary);
      transform: translateY(-1px);
    }

    .markdown-body {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      padding: 48px;
    }

    .markdown-body h1,
    .markdown-body h2,
    .markdown-body h3,
    .markdown-body h4 {
      color: var(--text-primary);
      border-bottom-color: var(--border-color);
      font-weight: 600;
    }

    .markdown-body h1 {
      background: linear-gradient(135deg, var(--accent-secondary), var(--accent-primary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-size: 2.2em;
      margin-bottom: 24px;
    }

    .markdown-body a {
      color: var(--accent-secondary);
    }

    .markdown-body a:hover {
      color: var(--accent-primary);
    }

    .markdown-body code {
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 2px 6px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9em;
    }

    .markdown-body pre {
      background: var(--bg-primary) !important;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
      overflow-x: auto;
    }

    .markdown-body pre code {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 0.85em;
      line-height: 1.6;
    }

    .markdown-body table {
      border-collapse: collapse;
      width: 100%;
      margin: 20px 0;
    }

    .markdown-body table th,
    .markdown-body table td {
      border: 1px solid var(--border-color);
      padding: 12px 16px;
      text-align: left;
    }

    .markdown-body table th {
      background: var(--bg-tertiary);
      font-weight: 600;
      color: var(--accent-secondary);
    }

    .markdown-body table tr:nth-child(even) {
      background: rgba(59, 130, 246, 0.03);
    }

    .markdown-body blockquote {
      border-left: 4px solid var(--accent-primary);
      background: var(--bg-tertiary);
      padding: 16px 20px;
      margin: 20px 0;
      border-radius: 0 8px 8px 0;
    }

    .markdown-body hr {
      border: none;
      height: 1px;
      background: var(--border-color);
      margin: 32px 0;
    }

    .markdown-body ul, .markdown-body ol {
      padding-left: 24px;
    }

    .markdown-body li {
      margin: 8px 0;
    }

    @media (max-width: 768px) {
      .page-container {
        padding: 20px 16px;
      }
      .markdown-body {
        padding: 24px;
        border-radius: 12px;
      }
      .markdown-body h1 {
        font-size: 1.8em;
      }
    }
  </style>
</head>
<body>
  <div class="page-container">
    <a href="https://digitalarsenal.github.io/flatbuffers/" class="back-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
      Back to DA FlatBuffers
    </a>
    <article class="markdown-body"><h1>Node.js Integration Guide</h1>
<p>Integrate the FlatBuffers encryption module into Node.js applications using the native WebAssembly support built into V8.</p>
<h2>Why Node.js Native WASM?</h2>
<ul>
<li><strong>Zero dependencies</strong> - Built into Node.js</li>
<li><strong>Fastest option</strong> - V8&#39;s optimizing JIT compiler</li>
<li><strong>npm ecosystem</strong> - Use the <code>flatc-wasm</code> package directly</li>
<li><strong>TypeScript support</strong> - Full type definitions included</li>
</ul>
<h2>Prerequisites</h2>
<ul>
<li>Node.js 16 or later (18+ recommended)</li>
<li>npm or yarn</li>
</ul>
<h2>Installation</h2>
<pre><code class="language-bash">npm install flatc-wasm
</code></pre>
<h2>Quick Start</h2>
<p>The <code>flatc-wasm</code> package provides a high-level API:</p>
<pre><code class="language-javascript">import {
  encryptBytes,
  decryptBytes,
  sha256,
  hkdf,
  x25519GenerateKeyPair,
  x25519SharedSecret,
  ed25519GenerateKeyPair,
  ed25519Sign,
  ed25519Verify,
  KEY_SIZE,
  IV_SIZE
} from &#39;flatc-wasm&#39;;

import { randomBytes } from &#39;crypto&#39;;

// Encrypt data
const key = randomBytes(KEY_SIZE);  // 32 bytes
const iv = randomBytes(IV_SIZE);    // 16 bytes
const plaintext = new TextEncoder().encode(&#39;Hello, FlatBuffers!&#39;);

// Encrypt in-place (make a copy first)
const data = new Uint8Array(plaintext);
encryptBytes(data, key, iv);
console.log(&#39;Encrypted:&#39;, Buffer.from(data).toString(&#39;hex&#39;));

// Decrypt in-place (CTR mode is symmetric)
decryptBytes(data, key, iv);
console.log(&#39;Decrypted:&#39;, new TextDecoder().decode(data));
</code></pre>
<h2>API Reference</h2>
<h3>Symmetric Encryption</h3>
<pre><code class="language-javascript">import { encryptBytes, decryptBytes, KEY_SIZE, IV_SIZE } from &#39;flatc-wasm&#39;;

// Key: 32 bytes, IV: 16 bytes
const key = new Uint8Array(32);
const iv = new Uint8Array(16);
crypto.getRandomValues(key);
crypto.getRandomValues(iv);

// Encrypt IN-PLACE (modifies the buffer)
const data = new Uint8Array([1, 2, 3, 4, 5]);
encryptBytes(data, key, iv);
// data is now encrypted

// Decrypt IN-PLACE
decryptBytes(data, key, iv);
// data is back to original
</code></pre>
<h3>Hash Functions</h3>
<pre><code class="language-javascript">import { sha256, hkdf } from &#39;flatc-wasm&#39;;

// SHA-256
const hash = sha256(new TextEncoder().encode(&#39;Hello&#39;));
// hash: Uint8Array(32)

// HKDF-SHA256
const derivedKey = hkdf(
  sharedSecret,           // Input key material
  null,                   // Salt (optional, can be null)
  new TextEncoder().encode(&#39;my-app-v1&#39;),  // Info
  32                      // Output length
);
// derivedKey: Uint8Array(32)
</code></pre>
<h3>X25519 Key Exchange</h3>
<pre><code class="language-javascript">import { x25519GenerateKeyPair, x25519SharedSecret } from &#39;flatc-wasm&#39;;

// Generate key pair
const alice = x25519GenerateKeyPair();
// alice.privateKey: Uint8Array(32)
// alice.publicKey: Uint8Array(32)

const bob = x25519GenerateKeyPair();

// Compute shared secret
const aliceShared = x25519SharedSecret(alice.privateKey, bob.publicKey);
const bobShared = x25519SharedSecret(bob.privateKey, alice.publicKey);
// aliceShared === bobShared (32 bytes)
</code></pre>
<h3>secp256k1 (Bitcoin/Ethereum)</h3>
<pre><code class="language-javascript">import {
  secp256k1GenerateKeyPair,
  secp256k1SharedSecret,
  secp256k1Sign,
  secp256k1Verify,
  sha256
} from &#39;flatc-wasm&#39;;

// Generate key pair
const keypair = secp256k1GenerateKeyPair();
// keypair.privateKey: Uint8Array(32)
// keypair.publicKey: Uint8Array(33) - compressed

// ECDH shared secret
const shared = secp256k1SharedSecret(myPrivateKey, theirPublicKey);
// shared: Uint8Array(32)

// Sign (usually a hash)
const messageHash = sha256(message);
const signature = secp256k1Sign(keypair.privateKey, messageHash);
// signature: Uint8Array(70-72) - DER encoded

// Verify
const isValid = secp256k1Verify(keypair.publicKey, messageHash, signature);
// isValid: boolean
</code></pre>
<h3>P-256 (NIST)</h3>
<pre><code class="language-javascript">import {
  p256GenerateKeyPair,
  p256SharedSecret,
  p256Sign,
  p256Verify
} from &#39;flatc-wasm&#39;;

// Same API as secp256k1
const keypair = p256GenerateKeyPair();
const shared = p256SharedSecret(myPrivateKey, theirPublicKey);
const signature = p256Sign(keypair.privateKey, messageHash);
const isValid = p256Verify(keypair.publicKey, messageHash, signature);
</code></pre>
<h3>Ed25519 Signatures</h3>
<pre><code class="language-javascript">import {
  ed25519GenerateKeyPair,
  ed25519Sign,
  ed25519Verify
} from &#39;flatc-wasm&#39;;

// Generate key pair
const keypair = ed25519GenerateKeyPair();
// keypair.privateKey: Uint8Array(64) - seed + public key
// keypair.publicKey: Uint8Array(32)

// Sign (entire message, not hash)
const message = new TextEncoder().encode(&#39;Sign this&#39;);
const signature = ed25519Sign(keypair.privateKey, message);
// signature: Uint8Array(64)

// Verify
const isValid = ed25519Verify(keypair.publicKey, message, signature);
// isValid: boolean
</code></pre>
<h2>Complete Example: End-to-End Encryption</h2>
<pre><code class="language-javascript">import { FlatcRunner } from &#39;flatc-wasm&#39;;
import {
  x25519GenerateKeyPair,
  x25519SharedSecret,
  hkdf,
  encryptBytes,
  decryptBytes,
  KEY_SIZE,
  IV_SIZE
} from &#39;flatc-wasm&#39;;
import { randomBytes } from &#39;crypto&#39;;

// Initialize FlatcRunner
const flatc = await FlatcRunner.init();

// Define schema
const schema = {
  entry: &#39;/message.fbs&#39;,
  files: {
    &#39;/message.fbs&#39;: `
      table SecureMessage {
        sender_public_key: [ubyte];
        iv: [ubyte];
        ciphertext: [ubyte];
      }
      root_type SecureMessage;
    `
  }
};

// === Sender Side ===

// Generate ephemeral keypair
const sender = x25519GenerateKeyPair();

// Recipient&#39;s public key (received earlier)
const recipientPublicKey = /* ... */;

// Compute shared secret
const sharedSecret = x25519SharedSecret(sender.privateKey, recipientPublicKey);

// Derive encryption key
const encryptionKey = hkdf(
  sharedSecret,
  null,
  new TextEncoder().encode(&#39;message-encryption-v1&#39;),
  KEY_SIZE
);

// Create the message FlatBuffer
const messageJson = JSON.stringify({ text: &#39;Hello, secure world!&#39; });
const messageBinary = flatc.generateBinary({
  entry: &#39;/content.fbs&#39;,
  files: {
    &#39;/content.fbs&#39;: `
      table Content { text: string; }
      root_type Content;
    `
  }
}, messageJson);

// Encrypt the FlatBuffer
const iv = new Uint8Array(randomBytes(IV_SIZE));
const ciphertext = new Uint8Array(messageBinary);
encryptBytes(ciphertext, encryptionKey, iv);

// Package into SecureMessage
const secureMessageJson = JSON.stringify({
  sender_public_key: Array.from(sender.publicKey),
  iv: Array.from(iv),
  ciphertext: Array.from(ciphertext)
});
const secureMessageBinary = flatc.generateBinary(schema, secureMessageJson);

// === Recipient Side ===

// Parse SecureMessage
const receivedJson = JSON.parse(flatc.generateJSON(schema, {
  path: &#39;/received.bin&#39;,
  data: secureMessageBinary
}));

// Extract components
const senderPublicKey = new Uint8Array(receivedJson.sender_public_key);
const receivedIv = new Uint8Array(receivedJson.iv);
const receivedCiphertext = new Uint8Array(receivedJson.ciphertext);

// Compute shared secret (recipient&#39;s private key)
const recipientPrivateKey = /* ... */;
const recipientSharedSecret = x25519SharedSecret(recipientPrivateKey, senderPublicKey);

// Derive same encryption key
const decryptionKey = hkdf(
  recipientSharedSecret,
  null,
  new TextEncoder().encode(&#39;message-encryption-v1&#39;),
  KEY_SIZE
);

// Decrypt
const decrypted = new Uint8Array(receivedCiphertext);
decryptBytes(decrypted, decryptionKey, receivedIv);

// Parse decrypted content
const content = JSON.parse(flatc.generateJSON({
  entry: &#39;/content.fbs&#39;,
  files: {
    &#39;/content.fbs&#39;: `
      table Content { text: string; }
      root_type Content;
    `
  }
}, {
  path: &#39;/content.bin&#39;,
  data: decrypted
}));

console.log(&#39;Decrypted message:&#39;, content.text);
</code></pre>
<h2>TypeScript Support</h2>
<p>Full TypeScript definitions are included:</p>
<pre><code class="language-typescript">import {
  encryptBytes,
  decryptBytes,
  x25519GenerateKeyPair,
  KeyPair,
  KEY_SIZE,
  IV_SIZE
} from &#39;flatc-wasm&#39;;

// Types are inferred
const keypair: KeyPair = x25519GenerateKeyPair();

function encrypt(plaintext: Uint8Array, key: Uint8Array, iv: Uint8Array): Uint8Array {
  const data = new Uint8Array(plaintext);
  encryptBytes(data, key, iv);
  return data;
}
</code></pre>
<h2>CommonJS Support</h2>
<pre><code class="language-javascript">const { encryptBytes, x25519GenerateKeyPair } = require(&#39;flatc-wasm&#39;);

const keypair = x25519GenerateKeyPair();
console.log(&#39;Public key:&#39;, Buffer.from(keypair.publicKey).toString(&#39;hex&#39;));
</code></pre>
<h2>Performance Tips</h2>
<h3>1. Initialize Once</h3>
<pre><code class="language-javascript">// Good: Initialize at startup
import { initEncryption } from &#39;flatc-wasm&#39;;
await initEncryption();  // Loads WASM once

// Then use throughout your app
encryptBytes(data, key, iv);
</code></pre>
<h3>2. Reuse Buffers</h3>
<pre><code class="language-javascript">// Good: Reuse allocated buffers
const buffer = new Uint8Array(1024);
for (const chunk of chunks) {
  buffer.set(chunk);
  encryptBytes(buffer.subarray(0, chunk.length), key, iv);
}

// Less efficient: Allocate each time
for (const chunk of chunks) {
  const buffer = new Uint8Array(chunk);  // New allocation
  encryptBytes(buffer, key, iv);
}
</code></pre>
<h3>3. Use Worker Threads for Heavy Loads</h3>
<pre><code class="language-javascript">// worker.js
import { parentPort } from &#39;worker_threads&#39;;
import { encryptBytes } from &#39;flatc-wasm&#39;;

parentPort.on(&#39;message&#39;, ({ data, key, iv }) =&gt; {
  const buffer = new Uint8Array(data);
  encryptBytes(buffer, new Uint8Array(key), new Uint8Array(iv));
  parentPort.postMessage(buffer);
});
</code></pre>
<h2>Error Handling</h2>
<pre><code class="language-javascript">try {
  encryptBytes(data, key, iv);
} catch (error) {
  if (error.message.includes(&#39;key&#39;)) {
    console.error(&#39;Invalid key size&#39;);
  } else if (error.message.includes(&#39;iv&#39;)) {
    console.error(&#39;Invalid IV size&#39;);
  } else {
    throw error;
  }
}
</code></pre>
<h2>Security Notes</h2>
<ol>
<li><strong>Use crypto.randomBytes for keys</strong> - Not Math.random()</li>
<li><strong>Never reuse IVs</strong> - Generate fresh IV for each encryption</li>
<li><strong>Clear sensitive data</strong> - Zero out keys after use</li>
<li><strong>Use HKDF</strong> - Never use raw ECDH output as encryption key</li>
</ol>
<pre><code class="language-javascript">import { randomBytes } from &#39;crypto&#39;;

// Good: Cryptographically secure
const key = randomBytes(32);

// Bad: Predictable
const badKey = new Uint8Array(32);
for (let i = 0; i &lt; 32; i++) {
  badKey[i] = Math.floor(Math.random() * 256);  // NOT SECURE!
}
</code></pre>
<h2>Troubleshooting</h2>
<h3>&quot;Module not found&quot;</h3>
<p>Ensure you&#39;re importing from the correct path:</p>
<pre><code class="language-javascript">import { encryptBytes } from &#39;flatc-wasm&#39;;
</code></pre>
<h3>&quot;Invalid key/IV size&quot;</h3>
<p>Check your buffer sizes:</p>
<pre><code class="language-javascript">console.log(&#39;Key size:&#39;, key.length);  // Should be 32
console.log(&#39;IV size:&#39;, iv.length);    // Should be 16
</code></pre>
<h3>&quot;WASM module not initialized&quot;</h3>
<p>Call init before using:</p>
<pre><code class="language-javascript">import { initEncryption, encryptBytes } from &#39;flatc-wasm&#39;;

await initEncryption();  // Must call first!
encryptBytes(data, key, iv);
</code></pre>
<h2>See Also</h2>
<ul>
<li><a href="https://www.npmjs.com/package/flatc-wasm">npm package</a></li>
<li><a href="README.md#api-reference">API Reference</a></li>
<li><a href="README.md#security-considerations">Security Considerations</a></li>
<li><a href="browser.html">Browser Integration</a> - Similar API for browsers</li>
</ul>
<hr>
<h2>Per-Field Encryption with <code>(encrypted)</code></h2>
<p>Fields marked with the <code>(encrypted)</code> attribute in your FlatBuffers schema are automatically encrypted and decrypted by the generated accessors when an <code>EncryptionContext</code> is provided. The per-field IV is derived using HKDF from the master key and the field name, ensuring deterministic and consistent behavior across all runtimes.</p>
<pre><code class="language-javascript">import { createDecipheriv } from 'node:crypto';

const decipher = createDecipheriv('aes-256-ctr', key, iv);
const plaintext = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
</code></pre>
</article>
  </div>
</body>
</html>