# automatically generated by the FlatBuffers compiler, do not modify

"""FlatBuffers field-level encryption support using AES-256-CTR."""

import struct
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

class FlatbuffersEncryption:
    """Handles decryption of encrypted FlatBuffer fields."""

    @staticmethod
    def _derive_nonce(ctx: bytes, field_offset: int) -> bytes:
        """Derive a 16-byte nonce from encryption context and field offset."""
        # Use first 12 bytes of context + 4-byte field offset as nonce
        if ctx is None or len(ctx) < 12:
            raise ValueError("Encryption context must be at least 12 bytes")
        return ctx[:12] + struct.pack('<I', field_offset)

    @staticmethod
    def _decrypt_bytes(data: bytes, ctx: bytes, field_offset: int) -> bytes:
        """Decrypt bytes using AES-256-CTR."""
        if ctx is None:
            raise ValueError("Encryption context required for encrypted field")
        if len(ctx) < 32:
            raise ValueError("Encryption context must be at least 32 bytes (256-bit key)")
        key = ctx[:32]
        nonce = FlatbuffersEncryption._derive_nonce(ctx, field_offset)
        cipher = Cipher(algorithms.AES(key), modes.CTR(nonce))
        decryptor = cipher.decryptor()
        return decryptor.update(data) + decryptor.finalize()

    @staticmethod
    def decrypt_scalar(value, ctx: bytes, field_offset: int):
        """Decrypt a scalar value (int, float, etc.).

        For AES-CTR, we encrypt the bytes representation of the scalar.
        This preserves the length and allows in-place decryption.
        """
        if ctx is None:
            return value  # No encryption context, return as-is
        # Determine the byte representation based on type
        if isinstance(value, float):
            # Float32 - 4 bytes
            data = struct.pack('<f', value)
            decrypted = FlatbuffersEncryption._decrypt_bytes(data, ctx, field_offset)
            return struct.unpack('<f', decrypted)[0]
        elif isinstance(value, int):
            # Determine size based on value range (assume 4 bytes for now)
            data = struct.pack('<i', value)
            decrypted = FlatbuffersEncryption._decrypt_bytes(data, ctx, field_offset)
            return struct.unpack('<i', decrypted)[0]
        return value

    @staticmethod
    def decrypt_string(data: bytes, ctx: bytes, field_offset: int) -> bytes:
        """Decrypt a string/byte vector field."""
        if ctx is None or data is None:
            return data  # No encryption context, return as-is
        return FlatbuffersEncryption._decrypt_bytes(data, ctx, field_offset)
