// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

// FlatBuffers field-level encryption support using AES-256-CTR.
// NOTE: This is a placeholder implementation. In production,
// you should use a proper AES library binding for Lobster.

class flatbuffers_encryption_ctx:
    key:string  // 32 bytes
    nonce_prefix:string  // 12 bytes

// Derive a 16-byte nonce from encryption context and field offset.
def flatbuffers_encryption_derive_nonce(ctx:flatbuffers_encryption_ctx, field_offset:int) -> string:
    // nonce = first 12 bytes of ctx.nonce_prefix + 4 bytes little-endian field_offset
    return ctx.nonce_prefix.substring(0, 12) +
           string_from_utf32([field_offset & 0xFF,
                              (field_offset >> 8) & 0xFF,
                              (field_offset >> 16) & 0xFF,
                              (field_offset >> 24) & 0xFF])

// XOR two strings of equal length.
def flatbuffers_xor_strings(a:string, b:string) -> string:
    assert a.length == b.length
    return string_from_utf32(map(a.length) i: a[i] ^^ b[i])

// Placeholder AES-256-CTR decryption (you must implement or bind a real AES library).
// This placeholder simply returns the input unchanged.
// IMPORTANT: Replace this with actual AES-256-CTR implementation!
def flatbuffers_aes256_ctr_decrypt(data:string, key:string, nonce:string) -> string:
    // TODO: Implement actual AES-256-CTR decryption here
    // For testing, this returns data unchanged (NOT SECURE!)
    return data

// Decrypt bytes using AES-256-CTR.
def flatbuffers_encryption_decrypt_bytes(data:string, ctx:flatbuffers_encryption_ctx?, field_offset:int) -> string:
    if not ctx: return data
    let nonce = flatbuffers_encryption_derive_nonce(ctx, field_offset)
    return flatbuffers_aes256_ctr_decrypt(data, ctx.key, nonce)

// Decrypt a scalar value.
def flatbuffers_encryption_decrypt_scalar(value, ctx:flatbuffers_encryption_ctx?, field_offset:int):
    // For scalars, we need to encrypt/decrypt the raw bytes
    // This is a placeholder - in practice you'd need type-specific handling
    if not ctx: return value
    return value  // Placeholder: returns value unchanged

// Decrypt a string value.
def flatbuffers_encryption_decrypt_string(value:string, ctx:flatbuffers_encryption_ctx?, field_offset:int) -> string:
    if not ctx: return value
    return flatbuffers_encryption_decrypt_bytes(value, ctx, field_offset)

namespace EncryptionTest

class Coordinates

class PublicData

class SensorReading

class UserRecord

class ScalarTest

class Coordinates : flatbuffers.handle
    def lat() -> float:
        return buf_.read_float64_le(pos_ + 0)
    def lon() -> float:
        return buf_.read_float64_le(pos_ + 8)

def CreateCoordinates(b_:flatbuffers.builder, lat:float, lon:float):
    b_.Prep(8, 16)
    b_.PrependFloat64(lon)
    b_.PrependFloat64(lat)
    return b_.Offset()

class PublicData : flatbuffers.handle
    def id() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 4, 0)
    def label() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)

def GetRootAsPublicData(buf:string): return PublicData { buf, flatbuffers.indirect(buf, 0) }

struct PublicDataBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(2)
        return this
    def add_id(id:int):
        b_.PrependUint64Slot(0, id, 0)
        return this
    def add_label(label:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, label)
        return this
    def end():
        return b_.EndObject()

class SensorReading : flatbuffers.handle
    encryption_ctx:flatbuffers_encryption_ctx? = nil
    def device_id() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    def timestamp() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 6, 0)
    def public_data() -> EncryptionTest.PublicData?:
        let o = flatbuffers.field_table(buf_, pos_, 8)
        return if o: EncryptionTest.PublicData { buf_, o } else: nil
    def location() -> EncryptionTest.Coordinates?:
        let o = flatbuffers.field_struct(buf_, pos_, 10)
        return if o: EncryptionTest.Coordinates { buf_, o } else: nil
    def temperature() -> float:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_float32(buf_, pos_, 12, 0.0), encryption_ctx, 12)
    def raw_data(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 14) + i * 1)
    def raw_data_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    def secret_message() -> string:
        return flatbuffers_encryption_decrypt_string(flatbuffers.field_string(buf_, pos_, 16), encryption_ctx, 16)
    def readings(i:int) -> float:
        return read_float32_le(buf_, buf_.flatbuffers.field_vector(pos_, 18) + i * 4)
    def readings_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 18)

def GetRootAsSensorReading(buf:string): return SensorReading { buf, flatbuffers.indirect(buf, 0) }
def GetRootAsSensorReadingWithEncryption(buf:string, ctx:flatbuffers_encryption_ctx):
    let obj = SensorReading { buf, flatbuffers.indirect(buf, 0) }
    obj.encryption_ctx = ctx
    return obj

struct SensorReadingBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(8)
        return this
    def add_device_id(device_id:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, device_id)
        return this
    def add_timestamp(timestamp:int):
        b_.PrependUint64Slot(1, timestamp, 0)
        return this
    def add_public_data(public_data:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, public_data)
        return this
    def add_location(location:flatbuffers.offset):
        b_.PrependStructSlot(3, location)
        return this
    def add_temperature(temperature:float):
        b_.PrependFloat32Slot(4, temperature, 0.0)
        return this
    def add_raw_data(raw_data:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, raw_data)
        return this
    def add_secret_message(secret_message:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, secret_message)
        return this
    def add_readings(readings:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, readings)
        return this
    def end():
        return b_.EndObject()

def SensorReadingStartRawDataVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def SensorReadingCreateRawDataVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

def SensorReadingStartReadingsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def SensorReadingCreateReadingsVector(b_:flatbuffers.builder, v_:[float]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependFloat32(e_)
    return b_.EndVector(v_.length)

class UserRecord : flatbuffers.handle
    encryption_ctx:flatbuffers_encryption_ctx? = nil
    def user_id() -> int:
        return flatbuffers.field_uint64(buf_, pos_, 4, 0)
    def username() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    def password_hash() -> string:
        return flatbuffers_encryption_decrypt_string(flatbuffers.field_string(buf_, pos_, 8), encryption_ctx, 8)
    def private_key(i:int) -> int:
        return read_uint8_le(buf_, buf_.flatbuffers.field_vector(pos_, 10) + i * 1)
    def private_key_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    def ssn() -> string:
        return flatbuffers_encryption_decrypt_string(flatbuffers.field_string(buf_, pos_, 12), encryption_ctx, 12)
    def balance() -> float:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_float64(buf_, pos_, 14, 0.0), encryption_ctx, 14)

def GetRootAsUserRecord(buf:string): return UserRecord { buf, flatbuffers.indirect(buf, 0) }
def GetRootAsUserRecordWithEncryption(buf:string, ctx:flatbuffers_encryption_ctx):
    let obj = UserRecord { buf, flatbuffers.indirect(buf, 0) }
    obj.encryption_ctx = ctx
    return obj

struct UserRecordBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(6)
        return this
    def add_user_id(user_id:int):
        b_.PrependUint64Slot(0, user_id, 0)
        return this
    def add_username(username:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, username)
        return this
    def add_password_hash(password_hash:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, password_hash)
        return this
    def add_private_key(private_key:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, private_key)
        return this
    def add_ssn(ssn:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, ssn)
        return this
    def add_balance(balance:float):
        b_.PrependFloat64Slot(5, balance, 0.0)
        return this
    def end():
        return b_.EndObject()

def UserRecordStartPrivateKeyVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(1, n_, 1)
def UserRecordCreatePrivateKeyVector(b_:flatbuffers.builder, v_:[int]):
    b_.StartVector(1, v_.length, 1)
    reverse(v_) e_: b_.PrependUint8(e_)
    return b_.EndVector(v_.length)

class ScalarTest : flatbuffers.handle
    encryption_ctx:flatbuffers_encryption_ctx? = nil
    def encrypted_bool() -> bool:
        return flatbuffers_encryption_decrypt_scalar(bool(flatbuffers.field_int8(buf_, pos_, 4, 0)), encryption_ctx, 4)
    def encrypted_byte() -> int:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_int8(buf_, pos_, 6, 0), encryption_ctx, 6)
    def encrypted_ubyte() -> int:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_uint8(buf_, pos_, 8, 0), encryption_ctx, 8)
    def encrypted_short() -> int:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_int16(buf_, pos_, 10, 0), encryption_ctx, 10)
    def encrypted_ushort() -> int:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_uint16(buf_, pos_, 12, 0), encryption_ctx, 12)
    def encrypted_int() -> int:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_int32(buf_, pos_, 14, 0), encryption_ctx, 14)
    def encrypted_uint() -> int:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_uint32(buf_, pos_, 16, 0), encryption_ctx, 16)
    def encrypted_long() -> int:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_int64(buf_, pos_, 18, 0), encryption_ctx, 18)
    def encrypted_ulong() -> int:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_uint64(buf_, pos_, 20, 0), encryption_ctx, 20)
    def encrypted_float() -> float:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_float32(buf_, pos_, 22, 0.0), encryption_ctx, 22)
    def encrypted_double() -> float:
        return flatbuffers_encryption_decrypt_scalar(flatbuffers.field_float64(buf_, pos_, 24, 0.0), encryption_ctx, 24)

def GetRootAsScalarTest(buf:string): return ScalarTest { buf, flatbuffers.indirect(buf, 0) }
def GetRootAsScalarTestWithEncryption(buf:string, ctx:flatbuffers_encryption_ctx):
    let obj = ScalarTest { buf, flatbuffers.indirect(buf, 0) }
    obj.encryption_ctx = ctx
    return obj

struct ScalarTestBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(11)
        return this
    def add_encrypted_bool(encrypted_bool:bool):
        b_.PrependBoolSlot(0, encrypted_bool, 0)
        return this
    def add_encrypted_byte(encrypted_byte:int):
        b_.PrependInt8Slot(1, encrypted_byte, 0)
        return this
    def add_encrypted_ubyte(encrypted_ubyte:int):
        b_.PrependUint8Slot(2, encrypted_ubyte, 0)
        return this
    def add_encrypted_short(encrypted_short:int):
        b_.PrependInt16Slot(3, encrypted_short, 0)
        return this
    def add_encrypted_ushort(encrypted_ushort:int):
        b_.PrependUint16Slot(4, encrypted_ushort, 0)
        return this
    def add_encrypted_int(encrypted_int:int):
        b_.PrependInt32Slot(5, encrypted_int, 0)
        return this
    def add_encrypted_uint(encrypted_uint:int):
        b_.PrependUint32Slot(6, encrypted_uint, 0)
        return this
    def add_encrypted_long(encrypted_long:int):
        b_.PrependInt64Slot(7, encrypted_long, 0)
        return this
    def add_encrypted_ulong(encrypted_ulong:int):
        b_.PrependUint64Slot(8, encrypted_ulong, 0)
        return this
    def add_encrypted_float(encrypted_float:float):
        b_.PrependFloat32Slot(9, encrypted_float, 0.0)
        return this
    def add_encrypted_double(encrypted_double:float):
        b_.PrependFloat64Slot(10, encrypted_double, 0.0)
        return this
    def end():
        return b_.EndObject()

