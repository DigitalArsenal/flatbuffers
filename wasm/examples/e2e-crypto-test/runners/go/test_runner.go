// Package main implements the Go E2E test runner for FlatBuffers cross-language encryption.
//
// This test runner:
// 1. Loads test vectors and encryption keys
// 2. Reads binary files generated by Node.js
// 3. Decrypts using the WASM encryption module
// 4. Verifies decryption produces expected values
// 5. Generates its own encrypted binaries for other languages to verify
package main

import (
	"context"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
	"github.com/tetratelabs/wazero/experimental/table"
	"github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1"
)

// WasmPath is the path to the encryption WASM module
const WasmPath = "../../../../build/wasm/wasm/flatc-encryption.wasm"

// EncryptionKeys holds the derived encryption keys for each chain
type EncryptionKeys map[string]struct {
	KeyHex    string `json:"key_hex"`
	IVHex     string `json:"iv_hex"`
	KeyBase64 string `json:"key_base64"`
	IVBase64  string `json:"iv_base64"`
}

// CryptoKey holds the crypto key material for a chain
type CryptoKey struct {
	PrivateKeyHex string `json:"private_key_hex"`
	PublicKeyHex  string `json:"public_key_hex"`
	Address       string `json:"address"`
	Scheme        string `json:"scheme"`
}

// TestResult tracks test outcomes
type TestResult struct {
	Name    string
	Passed  int
	Failed  int
	Errors  []string
}

func (r *TestResult) Pass(msg string) {
	r.Passed++
	fmt.Printf("  ✓ %s\n", msg)
}

func (r *TestResult) Fail(msg string, err error) {
	r.Failed++
	errMsg := msg
	if err != nil {
		errMsg = fmt.Sprintf("%s: %v", msg, err)
	}
	r.Errors = append(r.Errors, errMsg)
	fmt.Printf("  ✗ %s\n", errMsg)
}

func (r *TestResult) Summary() bool {
	total := r.Passed + r.Failed
	status := "✓"
	if r.Failed > 0 {
		status = "✗"
	}
	fmt.Printf("\n%s %s: %d/%d passed\n", status, r.Name, r.Passed, total)
	return r.Failed == 0
}

// EncryptionModule wraps the WASM encryption module
type EncryptionModule struct {
	runtime wazero.Runtime
	module  api.Module
	ctx     context.Context

	malloc       api.Function
	free         api.Function
	encryptBytes api.Function
	decryptBytes api.Function
	sha256       api.Function
	getVersion   api.Function
	hasCryptopp  api.Function
}

var wasmModule api.Module

func NewEncryptionModule(ctx context.Context, wasmBytes []byte) (*EncryptionModule, error) {
	r := wazero.NewRuntime(ctx)

	// Instantiate WASI
	wasi_snapshot_preview1.MustInstantiate(ctx, r)

	// Create env module with invoke_* trampolines
	i32 := api.ValueTypeI32

	setException := func(ctx context.Context) {
		if wasmModule != nil {
			if setThrew := wasmModule.ExportedFunction("setThrew"); setThrew != nil {
				setThrew.Call(ctx, 1, 0)
			}
		}
	}

	_, err := r.NewHostModuleBuilder("env").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, nil, nil)
			f.Call(ctx)
		}).Export("invoke_v").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32}, nil)
			f.Call(ctx, uint64(a))
		}).Export("invoke_vi").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b))
		}).Export("invoke_vii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c))
		}).Export("invoke_viii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d))
		}).Export("invoke_viiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e))
		}).Export("invoke_viiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff))
		}).Export("invoke_viiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g))
		}).Export("invoke_viiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g, h, ii uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g), uint64(h), uint64(ii))
		}).Export("invoke_viiiiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, nil, []api.ValueType{i32})
			res, _ := f.Call(ctx)
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_i").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_ii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g, h, ii uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g), uint64(h), uint64(ii))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module) uint32 { return 0 }).Export("__cxa_find_matching_catch_2").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) uint32 { return 0 }).Export("__cxa_find_matching_catch_3").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) {}).Export("__resumeException").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) uint32 { return 0 }).Export("__cxa_begin_catch").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module) {}).Export("__cxa_end_catch").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) uint32 { return 0 }).Export("llvm_eh_typeid_for").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a, b, c uint32) {}).Export("__cxa_throw").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module) uint32 { return 0 }).Export("__cxa_uncaught_exceptions").
		Instantiate(ctx)
	if err != nil {
		r.Close(ctx)
		return nil, fmt.Errorf("failed to instantiate env module: %w", err)
	}

	// Compile and instantiate the WASM module
	compiled, err := r.CompileModule(ctx, wasmBytes)
	if err != nil {
		r.Close(ctx)
		return nil, fmt.Errorf("failed to compile module: %w", err)
	}

	config := wazero.NewModuleConfig().WithName("flatc-encryption")
	mod, err := r.InstantiateModule(ctx, compiled, config)
	if err != nil {
		r.Close(ctx)
		return nil, fmt.Errorf("failed to instantiate module: %w", err)
	}

	wasmModule = mod

	return &EncryptionModule{
		runtime:      r,
		module:       mod,
		ctx:          ctx,
		malloc:       mod.ExportedFunction("malloc"),
		free:         mod.ExportedFunction("free"),
		encryptBytes: mod.ExportedFunction("encrypt_bytes"),
		decryptBytes: mod.ExportedFunction("decrypt_bytes"),
		sha256:       mod.ExportedFunction("sha256"),
		getVersion:   mod.ExportedFunction("get_version"),
		hasCryptopp:  mod.ExportedFunction("has_cryptopp"),
	}, nil
}

func (em *EncryptionModule) Close() {
	em.runtime.Close(em.ctx)
}

func (em *EncryptionModule) memory() api.Memory {
	return em.module.Memory()
}

func (em *EncryptionModule) Version() string {
	res, _ := em.getVersion.Call(em.ctx)
	if len(res) == 0 || res[0] == 0 {
		return "unknown"
	}
	ptr := uint32(res[0])
	mem := em.memory()
	var result []byte
	for i := uint32(0); ; i++ {
		b, ok := mem.ReadByte(ptr + i)
		if !ok || b == 0 {
			break
		}
		result = append(result, b)
	}
	return string(result)
}

func (em *EncryptionModule) HasCryptopp() bool {
	res, _ := em.hasCryptopp.Call(em.ctx)
	return len(res) > 0 && res[0] != 0
}

func (em *EncryptionModule) EncryptBytes(key, iv, data []byte) error {
	keyPtr := em.alloc(32)
	ivPtr := em.alloc(16)
	dataPtr := em.alloc(uint32(len(data)))

	defer func() {
		em.dealloc(keyPtr)
		em.dealloc(ivPtr)
		em.dealloc(dataPtr)
	}()

	em.memory().Write(keyPtr, key)
	em.memory().Write(ivPtr, iv)
	em.memory().Write(dataPtr, data)

	_, err := em.encryptBytes.Call(em.ctx, uint64(keyPtr), uint64(ivPtr), uint64(dataPtr), uint64(len(data)))
	if err != nil {
		return err
	}

	// Read encrypted data back
	encrypted, ok := em.memory().Read(dataPtr, uint32(len(data)))
	if !ok {
		return fmt.Errorf("failed to read encrypted data")
	}
	copy(data, encrypted)
	return nil
}

func (em *EncryptionModule) DecryptBytes(key, iv, data []byte) error {
	return em.EncryptBytes(key, iv, data) // CTR mode is symmetric
}

func (em *EncryptionModule) SHA256(data []byte) ([]byte, error) {
	dataPtr := em.alloc(uint32(max(len(data), 1)))
	hashPtr := em.alloc(32)

	defer func() {
		em.dealloc(dataPtr)
		em.dealloc(hashPtr)
	}()

	if len(data) > 0 {
		em.memory().Write(dataPtr, data)
	}

	_, err := em.sha256.Call(em.ctx, uint64(dataPtr), uint64(len(data)), uint64(hashPtr))
	if err != nil {
		return nil, err
	}

	hash, ok := em.memory().Read(hashPtr, 32)
	if !ok {
		return nil, fmt.Errorf("failed to read hash")
	}
	return hash, nil
}

func (em *EncryptionModule) alloc(size uint32) uint32 {
	res, _ := em.malloc.Call(em.ctx, uint64(size))
	return uint32(res[0])
}

func (em *EncryptionModule) dealloc(ptr uint32) {
	em.free.Call(em.ctx, uint64(ptr))
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	fmt.Println(string(make([]byte, 60, 60)))
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()
	fmt.Println("FlatBuffers Cross-Language Encryption E2E Tests - Go")
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()
	fmt.Println()
	fmt.Println("Mode: TRANSPARENT ENCRYPTION")
	fmt.Println("Schema: tests/monster_test.fbs (upstream)")
	fmt.Println()

	ctx := context.Background()

	// Load WASM module
	wasmPath := WasmPath
	wasmBytes, err := os.ReadFile(wasmPath)
	if err != nil {
		fmt.Printf("Failed to load WASM module: %v\n", err)
		fmt.Println("Build the WASM module first:")
		fmt.Println("  cmake --build build/wasm --target flatc_wasm_wasi")
		os.Exit(1)
	}

	em, err := NewEncryptionModule(ctx, wasmBytes)
	if err != nil {
		fmt.Printf("Failed to initialize encryption module: %v\n", err)
		os.Exit(1)
	}
	defer em.Close()

	fmt.Printf("Encryption module version: %s\n", em.Version())
	fmt.Printf("Crypto++ available: %v\n", em.HasCryptopp())
	fmt.Println()

	// Load encryption keys
	keysPath := filepath.Join("..", "..", "vectors", "encryption_keys.json")
	keysData, err := os.ReadFile(keysPath)
	if err != nil {
		fmt.Printf("Failed to load encryption keys: %v\n", err)
		fmt.Println("Run the vector generator first: node generate_vectors.mjs")
		os.Exit(1)
	}

	var encryptionKeys EncryptionKeys
	if err := json.Unmarshal(keysData, &encryptionKeys); err != nil {
		fmt.Printf("Failed to parse encryption keys: %v\n", err)
		os.Exit(1)
	}

	results := []bool{}

	// Test 1: SHA-256
	fmt.Println("Test 1: SHA-256 Hash")
	fmt.Println("----------------------------------------")
	{
		result := &TestResult{Name: "SHA-256"}

		hash, err := em.SHA256([]byte("hello"))
		if err != nil {
			result.Fail("SHA-256 computation", err)
		} else {
			hashHex := hex.EncodeToString(hash)
			expected := "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
			if hashHex == expected {
				result.Pass("SHA-256('hello') matches expected")
			} else {
				result.Fail(fmt.Sprintf("SHA-256 mismatch: got %s", hashHex), nil)
			}
		}

		results = append(results, result.Summary())
	}

	// Test 2: Encryption/Decryption with each chain key
	fmt.Println("\nTest 2: Encryption/Decryption (per-chain keys)")
	fmt.Println("----------------------------------------")

	for chain, keys := range encryptionKeys {
		result := &TestResult{Name: fmt.Sprintf("Encryption with %s", chain)}

		key, err := hex.DecodeString(keys.KeyHex)
		if err != nil {
			result.Fail("Decode key", err)
			results = append(results, result.Summary())
			continue
		}

		iv, err := hex.DecodeString(keys.IVHex)
		if err != nil {
			result.Fail("Decode IV", err)
			results = append(results, result.Summary())
			continue
		}

		// Test data
		plaintext := []byte("Hello, FlatBuffers encryption test from Go!")
		originalHex := hex.EncodeToString(plaintext)

		// Encrypt
		data := make([]byte, len(plaintext))
		copy(data, plaintext)

		if err := em.EncryptBytes(key, iv, data); err != nil {
			result.Fail("Encryption", err)
			results = append(results, result.Summary())
			continue
		}

		encryptedHex := hex.EncodeToString(data)
		if encryptedHex != originalHex {
			result.Pass("Data encrypted (changed from original)")
		} else {
			result.Fail("Data unchanged after encryption", nil)
		}

		// Decrypt
		if err := em.DecryptBytes(key, iv, data); err != nil {
			result.Fail("Decryption", err)
			results = append(results, result.Summary())
			continue
		}

		decryptedHex := hex.EncodeToString(data)
		if decryptedHex == originalHex {
			result.Pass("Decryption restored original data")
		} else {
			result.Fail("Decryption mismatch", nil)
		}

		if string(data) == string(plaintext) {
			result.Pass("Plaintext matches after round-trip")
		} else {
			result.Fail("Plaintext mismatch after round-trip", nil)
		}

		results = append(results, result.Summary())
	}

	// Test 3: Read Node.js generated binaries (if available)
	fmt.Println("\nTest 3: Cross-Language Binary Verification")
	fmt.Println("----------------------------------------")
	{
		result := &TestResult{Name: "Cross-Language Verification"}

		binaryDir := filepath.Join("..", "..", "vectors", "binary")
		unencryptedPath := filepath.Join(binaryDir, "monster_unencrypted.bin")

		if _, err := os.Stat(unencryptedPath); os.IsNotExist(err) {
			result.Fail("Node.js binaries not found. Run Node.js test first.", nil)
		} else {
			unencryptedData, err := os.ReadFile(unencryptedPath)
			if err != nil {
				result.Fail("Read unencrypted binary", err)
			} else {
				result.Pass(fmt.Sprintf("Read unencrypted binary: %d bytes", len(unencryptedData)))

				// Try reading an encrypted binary
				for chain := range encryptionKeys {
					encryptedPath := filepath.Join(binaryDir, fmt.Sprintf("monster_encrypted_%s.bin", chain))
					if _, err := os.Stat(encryptedPath); err == nil {
						encryptedData, err := os.ReadFile(encryptedPath)
						if err != nil {
							result.Fail(fmt.Sprintf("Read %s encrypted binary", chain), err)
						} else {
							result.Pass(fmt.Sprintf("Read %s encrypted binary: %d bytes", chain, len(encryptedData)))
						}
						break
					}
				}
			}
		}

		results = append(results, result.Summary())
	}

	// Summary
	fmt.Println()
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()
	fmt.Println("Summary")
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()

	passed := 0
	for _, r := range results {
		if r {
			passed++
		}
	}

	fmt.Printf("\nTotal: %d/%d test suites passed\n", passed, len(results))

	if passed == len(results) {
		fmt.Println("\n✓ All tests passed!")
		os.Exit(0)
	} else {
		fmt.Println("\n✗ Some tests failed")
		os.Exit(1)
	}
}
