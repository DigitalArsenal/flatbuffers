<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Swift - DA FlatBuffers</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --black: #000000;
      --white: #F5F5F7;
      --white-90: rgba(255, 255, 255, 0.9);
      --white-80: rgba(255, 255, 255, 0.8);
      --white-60: rgba(255, 255, 255, 0.6);
      --white-40: rgba(255, 255, 255, 0.4);
      --white-20: rgba(255, 255, 255, 0.2);
      --white-10: rgba(255, 255, 255, 0.1);
      --white-05: rgba(255, 255, 255, 0.05);
      --muted: rgba(134, 134, 139, 1.0);
      --glass-bg: rgba(42, 42, 45, 0.72);
      --glass-hover: rgba(66, 66, 69, 0.72);
      --glass-border: rgba(255, 255, 255, 0.1);
      --glass-blur: blur(20px);
      --radius: 28px;
      --radius-sm: 14px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--black);
      color: var(--white);
      line-height: 1.6;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Video Background */
    .video-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      overflow: hidden;
    }

    .video-background video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.3;
    }

    .video-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        to bottom,
        rgba(0, 0, 0, 0.4) 0%,
        rgba(0, 0, 0, 0.6) 50%,
        rgba(0, 0, 0, 0.85) 100%
      );
    }

    .page-container {
      position: relative;
      z-index: 1;
      max-width: 900px;
      margin: 0 auto;
      padding: 60px 24px 80px;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      margin-bottom: 40px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      color: var(--white);
      text-decoration: none;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .back-link:hover {
      background: var(--glass-hover);
      transform: translateY(-2px);
    }

    .markdown-body {
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      padding: 64px;
    }

    .markdown-body h1 {
      color: var(--white);
      font-size: 56px;
      font-weight: 600;
      line-height: 1.1;
      margin-bottom: 32px;
      letter-spacing: -0.02em;
    }

    .markdown-body h2 {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--white);
      font-size: 28px;
      font-weight: 600;
      line-height: 1.15;
      margin-top: 56px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--glass-border);
    }

    .markdown-body h2::before {
      content: '';
      display: inline-flex;
      width: 24px;
      height: 24px;
      background: var(--white);
      -webkit-mask-size: contain;
      mask-size: contain;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
      flex-shrink: 0;
    }

    /* Icon mappings for h2 headers based on content */
    .markdown-body h2[id*="why"]::before,
    .markdown-body h2:has(+ p:first-of-type)::before {
      -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
      mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
    }

    .markdown-body h3,
    .markdown-body h4 {
      color: var(--white);
      font-weight: 600;
      margin-top: 32px;
      margin-bottom: 16px;
    }

    .markdown-body h3 {
      font-size: 22px;
    }

    .markdown-body h4 {
      font-size: 18px;
      color: var(--white-90);
    }

    .markdown-body p {
      color: var(--white-80);
      font-size: 18px;
      line-height: 1.7;
      margin-bottom: 20px;
    }

    .markdown-body a {
      color: var(--white);
      text-decoration: underline;
      text-underline-offset: 3px;
      transition: opacity 0.2s;
    }

    .markdown-body a:hover {
      opacity: 0.7;
    }

    .markdown-body strong {
      color: var(--white);
      font-weight: 600;
    }

    .markdown-body code {
      background: var(--glass-hover);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      padding: 3px 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9em;
      color: var(--white);
    }

    .markdown-body pre {
      background: var(--black) !important;
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      padding: 24px;
      overflow-x: auto;
      margin: 24px 0;
    }

    .markdown-body pre code {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 14px;
      line-height: 1.7;
      color: var(--white-90);
    }

    .markdown-body ul, .markdown-body ol {
      padding-left: 24px;
      margin-bottom: 20px;
    }

    .markdown-body li {
      margin: 12px 0;
      color: var(--white-80);
      font-size: 18px;
    }

    .markdown-body li strong {
      color: var(--white);
    }

    .markdown-body table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      border-radius: var(--radius-sm);
      overflow: hidden;
    }

    .markdown-body table th,
    .markdown-body table td {
      border: 1px solid var(--glass-border);
      padding: 14px 18px;
      text-align: left;
    }

    .markdown-body table th {
      background: var(--glass-hover);
      font-weight: 600;
      color: var(--white);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .markdown-body table td {
      background: var(--white-05);
      color: var(--white-80);
    }

    .markdown-body table tr:nth-child(even) td {
      background: var(--white-10);
    }

    .markdown-body blockquote {
      border-left: 4px solid var(--white-40);
      background: var(--white-05);
      padding: 20px 24px;
      margin: 24px 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    }

    .markdown-body blockquote p {
      margin: 0;
      color: var(--white-80);
    }

    .markdown-body hr {
      border: none;
      height: 1px;
      background: var(--glass-border);
      margin: 48px 0;
    }

    /* Section header icons */
    .section-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: var(--white-10);
      border-radius: 8px;
      margin-right: 12px;
      flex-shrink: 0;
    }

    .section-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--white);
      fill: none;
      stroke-width: 2;
    }

    @media (max-width: 768px) {
      .page-container {
        padding: 40px 16px 60px;
      }
      .markdown-body {
        padding: 32px 24px;
        border-radius: 20px;
      }
      .markdown-body h1 {
        font-size: 36px;
      }
      .markdown-body h2 {
        font-size: 24px;
      }
      .markdown-body p,
      .markdown-body li {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <!-- Video Background -->
  <div class="video-background">
    <video autoplay loop muted playsinline id="bg-video">
      <source src="" type="application/x-mpegURL">
    </video>
    <div class="video-overlay"></div>
  </div>

  <div class="page-container">
    <a href="../index.html" class="back-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
      Back to DA FlatBuffers
    </a>
    <article class="markdown-body"><h1>Swift Integration Guide</h1>
<p>Integrate the FlatBuffers encryption WASM module into Swift applications using <a href="https://github.com/AO/WasmKit">WasmKit</a>, a pure Swift WebAssembly runtime.</p>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg></span>Why WasmKit?</h2>
<ul>
<li><strong>Pure Swift</strong> - No C dependencies, native Swift types</li>
<li><strong>Swift Package Manager</strong> - Easy integration</li>
<li><strong>Cross-platform</strong> - iOS, macOS, Linux</li>
<li><strong>Modern API</strong> - Swift concurrency support</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>Prerequisites</h2>
<ul>
<li>Swift 5.9 or later</li>
<li>macOS 13+ or iOS 16+</li>
<li><code>flatc-encryption.wasm</code> binary</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></span>Installation</h2>
<p>Add to <code>Package.swift</code>:</p>
<pre><code class="language-swift">dependencies: [
    .package(url: &quot;https://github.com/AO/WasmKit.git&quot;, from: &quot;0.0.5&quot;)
]
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>Quick Start</h2>
<pre><code class="language-swift">import WasmKit
import Foundation

// Load WASM module
let wasmData = try Data(contentsOf: URL(fileURLWithPath: &quot;flatc-encryption.wasm&quot;))
let module = try WasmKit.parseWasm(bytes: Array(wasmData))

// Create runtime
let runtime = Runtime()
let moduleInstance = try runtime.instantiate(module: module)

// Get exports
let memory = try runtime.getExport(moduleInstance, name: &quot;memory&quot;) as! Memory
let malloc = try runtime.getExport(moduleInstance, name: &quot;malloc&quot;) as! Function
let free = try runtime.getExport(moduleInstance, name: &quot;free&quot;) as! Function
let encrypt = try runtime.getExport(moduleInstance, name: &quot;wasi_encrypt_bytes&quot;) as! Function

// Generate key and IV
var key = [UInt8](repeating: 0, count: 32)
var iv = [UInt8](repeating: 0, count: 16)
_ = SecRandomCopyBytes(kSecRandomDefault, key.count, &amp;key)
_ = SecRandomCopyBytes(kSecRandomDefault, iv.count, &amp;iv)

let plaintext = Array(&quot;Hello, FlatBuffers!&quot;.utf8)

// Allocate WASM memory
let keyPtr = try malloc.invoke([.i32(Int32(32))]).first!.i32
let ivPtr = try malloc.invoke([.i32(Int32(16))]).first!.i32
let dataPtr = try malloc.invoke([.i32(Int32(plaintext.count))]).first!.i32

// Write to memory
try memory.write(offset: Int(keyPtr), bytes: key)
try memory.write(offset: Int(ivPtr), bytes: iv)
try memory.write(offset: Int(dataPtr), bytes: plaintext)

// Encrypt
_ = try encrypt.invoke([
    .i32(keyPtr),
    .i32(ivPtr),
    .i32(dataPtr),
    .i32(Int32(plaintext.count))
])

// Read encrypted data
let ciphertext = try memory.read(offset: Int(dataPtr), count: plaintext.count)
print(&quot;Encrypted: \(ciphertext.map { String(format: &quot;%02x&quot;, $0) }.joined())&quot;)

// Clean up
_ = try free.invoke([.i32(keyPtr)])
_ = try free.invoke([.i32(ivPtr)])
_ = try free.invoke([.i32(dataPtr)])
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></span>Complete Module Wrapper</h2>
<pre><code class="language-swift">import WasmKit
import Foundation
import Security

/// Key and signature sizes
public enum CryptoConstants {
    public static let aesKeySize = 32
    public static let aesIVSize = 16
    public static let sha256Size = 32

    public static let x25519PrivateKeySize = 32
    public static let x25519PublicKeySize = 32

    public static let secp256k1PrivateKeySize = 32
    public static let secp256k1PublicKeySize = 33
    public static let secp256k1SignatureMaxSize = 72

    public static let ed25519PrivateKeySize = 64
    public static let ed25519PublicKeySize = 32
    public static let ed25519SignatureSize = 64
}

/// Encryption errors
public enum EncryptionError: Error, LocalizedError {
    case moduleLoadFailed(String)
    case exportNotFound(String)
    case allocationFailed
    case encryptionFailed
    case decryptionFailed
    case keyGenerationFailed
    case signatureFailed
    case verificationFailed
    case invalidKeySize(expected: Int, actual: Int)

    public var errorDescription: String? {
        switch self {
        case .moduleLoadFailed(let msg): return &quot;Module load failed: \(msg)&quot;
        case .exportNotFound(let name): return &quot;Export not found: \(name)&quot;
        case .allocationFailed: return &quot;Memory allocation failed&quot;
        case .encryptionFailed: return &quot;Encryption operation failed&quot;
        case .decryptionFailed: return &quot;Decryption operation failed&quot;
        case .keyGenerationFailed: return &quot;Key generation failed&quot;
        case .signatureFailed: return &quot;Signature operation failed&quot;
        case .verificationFailed: return &quot;Verification operation failed&quot;
        case .invalidKeySize(let expected, let actual):
            return &quot;Invalid key size: expected \(expected), got \(actual)&quot;
        }
    }
}

/// X25519 key pair
public struct X25519KeyPair {
    public let privateKey: [UInt8]  // 32 bytes
    public let publicKey: [UInt8]   // 32 bytes
}

/// Ed25519 key pair
public struct Ed25519KeyPair {
    public let privateKey: [UInt8]  // 64 bytes (seed + public key)
    public let publicKey: [UInt8]   // 32 bytes
}

/// secp256k1 key pair
public struct Secp256k1KeyPair {
    public let privateKey: [UInt8]  // 32 bytes
    public let publicKey: [UInt8]   // 33 bytes (compressed)
}

/// FlatBuffers Encryption Module for Swift
public final class EncryptionModule {
    private let runtime: Runtime
    private let moduleInstance: ModuleInstance
    private let memory: Memory

    private let mallocFn: Function
    private let freeFn: Function

    private let encryptFn: Function
    private let decryptFn: Function
    private let sha256Fn: Function
    private let hkdfFn: Function

    private let x25519GenerateFn: Function
    private let x25519SharedFn: Function

    private let secp256k1GenerateFn: Function
    private let secp256k1SharedFn: Function
    private let secp256k1SignFn: Function
    private let secp256k1VerifyFn: Function

    private let ed25519GenerateFn: Function
    private let ed25519SignFn: Function
    private let ed25519VerifyFn: Function

    /// Initialize from file path
    public convenience init(path: String) throws {
        let data = try Data(contentsOf: URL(fileURLWithPath: path))
        try self.init(wasmData: data)
    }

    /// Initialize from data
    public init(wasmData: Data) throws {
        let module = try WasmKit.parseWasm(bytes: Array(wasmData))

        runtime = Runtime()

        // Register WASI stubs
        try registerWasiStubs(runtime: runtime)
        try registerEnvStubs(runtime: runtime)

        moduleInstance = try runtime.instantiate(module: module)
        memory = try getExport(&quot;memory&quot;)

        mallocFn = try getExport(&quot;malloc&quot;)
        freeFn = try getExport(&quot;free&quot;)

        encryptFn = try getExport(&quot;wasi_encrypt_bytes&quot;)
        decryptFn = try getExport(&quot;wasi_decrypt_bytes&quot;)
        sha256Fn = try getExport(&quot;wasi_sha256&quot;)
        hkdfFn = try getExport(&quot;wasi_hkdf&quot;)

        x25519GenerateFn = try getExport(&quot;wasi_x25519_generate_keypair&quot;)
        x25519SharedFn = try getExport(&quot;wasi_x25519_shared_secret&quot;)

        secp256k1GenerateFn = try getExport(&quot;wasi_secp256k1_generate_keypair&quot;)
        secp256k1SharedFn = try getExport(&quot;wasi_secp256k1_shared_secret&quot;)
        secp256k1SignFn = try getExport(&quot;wasi_secp256k1_sign&quot;)
        secp256k1VerifyFn = try getExport(&quot;wasi_secp256k1_verify&quot;)

        ed25519GenerateFn = try getExport(&quot;wasi_ed25519_generate_keypair&quot;)
        ed25519SignFn = try getExport(&quot;wasi_ed25519_sign&quot;)
        ed25519VerifyFn = try getExport(&quot;wasi_ed25519_verify&quot;)
    }

    private func getExport&lt;T&gt;(_ name: String) throws -&gt; T {
        guard let export = try runtime.getExport(moduleInstance, name: name) as? T else {
            throw EncryptionError.exportNotFound(name)
        }
        return export
    }

    // MARK: - Memory Management

    private func allocate(_ size: Int) throws -&gt; Int32 {
        let result = try mallocFn.invoke([.i32(Int32(size))])
        let ptr = result.first!.i32
        if ptr == 0 {
            throw EncryptionError.allocationFailed
        }
        return ptr
    }

    private func free(_ ptr: Int32) throws {
        _ = try freeFn.invoke([.i32(ptr)])
    }

    private func writeBytes(_ ptr: Int32, _ data: [UInt8]) throws {
        try memory.write(offset: Int(ptr), bytes: data)
    }

    private func readBytes(_ ptr: Int32, _ length: Int) throws -&gt; [UInt8] {
        return try memory.read(offset: Int(ptr), count: length)
    }

    // MARK: - Symmetric Encryption

    /// Encrypt data using AES-256-CTR
    public func encrypt(key: [UInt8], iv: [UInt8], data: [UInt8]) throws -&gt; [UInt8] {
        guard key.count == CryptoConstants.aesKeySize else {
            throw EncryptionError.invalidKeySize(
                expected: CryptoConstants.aesKeySize,
                actual: key.count
            )
        }
        guard iv.count == CryptoConstants.aesIVSize else {
            throw EncryptionError.invalidKeySize(
                expected: CryptoConstants.aesIVSize,
                actual: iv.count
            )
        }

        let keyPtr = try allocate(key.count)
        let ivPtr = try allocate(iv.count)
        let dataPtr = try allocate(data.count)

        defer {
            try? free(keyPtr)
            try? free(ivPtr)
            try? free(dataPtr)
        }

        try writeBytes(keyPtr, key)
        try writeBytes(ivPtr, iv)
        try writeBytes(dataPtr, data)

        let result = try encryptFn.invoke([
            .i32(keyPtr),
            .i32(ivPtr),
            .i32(dataPtr),
            .i32(Int32(data.count))
        ])

        if result.first?.i32 != 0 {
            throw EncryptionError.encryptionFailed
        }

        return try readBytes(dataPtr, data.count)
    }

    /// Decrypt data using AES-256-CTR
    public func decrypt(key: [UInt8], iv: [UInt8], data: [UInt8]) throws -&gt; [UInt8] {
        // CTR mode is symmetric
        return try encrypt(key: key, iv: iv, data: data)
    }

    // MARK: - Hash Functions

    /// Compute SHA-256 hash
    public func sha256(_ data: [UInt8]) throws -&gt; [UInt8] {
        let dataPtr = try allocate(data.count)
        let outPtr = try allocate(CryptoConstants.sha256Size)

        defer {
            try? free(dataPtr)
            try? free(outPtr)
        }

        try writeBytes(dataPtr, data)
        _ = try sha256Fn.invoke([
            .i32(dataPtr),
            .i32(Int32(data.count)),
            .i32(outPtr)
        ])

        return try readBytes(outPtr, CryptoConstants.sha256Size)
    }

    /// Derive key using HKDF-SHA256
    public func hkdf(ikm: [UInt8], salt: [UInt8]?, info: [UInt8], length: Int) throws -&gt; [UInt8] {
        let ikmPtr = try allocate(ikm.count)
        try writeBytes(ikmPtr, ikm)

        var saltPtr: Int32 = 0
        var saltLen = 0
        if let salt = salt, !salt.isEmpty {
            saltPtr = try allocate(salt.count)
            try writeBytes(saltPtr, salt)
            saltLen = salt.count
        }

        let infoPtr = try allocate(info.count)
        try writeBytes(infoPtr, info)

        let outPtr = try allocate(length)

        defer {
            try? free(ikmPtr)
            if saltPtr != 0 { try? free(saltPtr) }
            try? free(infoPtr)
            try? free(outPtr)
        }

        _ = try hkdfFn.invoke([
            .i32(ikmPtr), .i32(Int32(ikm.count)),
            .i32(saltPtr), .i32(Int32(saltLen)),
            .i32(infoPtr), .i32(Int32(info.count)),
            .i32(outPtr), .i32(Int32(length))
        ])

        return try readBytes(outPtr, length)
    }

    // MARK: - X25519 Key Exchange

    /// Generate X25519 key pair
    public func x25519GenerateKeyPair() throws -&gt; X25519KeyPair {
        let privPtr = try allocate(CryptoConstants.x25519PrivateKeySize)
        let pubPtr = try allocate(CryptoConstants.x25519PublicKeySize)

        defer {
            try? free(privPtr)
            try? free(pubPtr)
        }

        let result = try x25519GenerateFn.invoke([.i32(privPtr), .i32(pubPtr)])

        if result.first?.i32 != 0 {
            throw EncryptionError.keyGenerationFailed
        }

        return X25519KeyPair(
            privateKey: try readBytes(privPtr, CryptoConstants.x25519PrivateKeySize),
            publicKey: try readBytes(pubPtr, CryptoConstants.x25519PublicKeySize)
        )
    }

    /// Compute X25519 shared secret
    public func x25519SharedSecret(privateKey: [UInt8], publicKey: [UInt8]) throws -&gt; [UInt8] {
        let privPtr = try allocate(privateKey.count)
        let pubPtr = try allocate(publicKey.count)
        let outPtr = try allocate(32)

        defer {
            try? free(privPtr)
            try? free(pubPtr)
            try? free(outPtr)
        }

        try writeBytes(privPtr, privateKey)
        try writeBytes(pubPtr, publicKey)

        let result = try x25519SharedFn.invoke([
            .i32(privPtr),
            .i32(pubPtr),
            .i32(outPtr)
        ])

        if result.first?.i32 != 0 {
            throw EncryptionError.encryptionFailed
        }

        return try readBytes(outPtr, 32)
    }

    // MARK: - Ed25519 Signatures

    /// Generate Ed25519 key pair
    public func ed25519GenerateKeyPair() throws -&gt; Ed25519KeyPair {
        let privPtr = try allocate(CryptoConstants.ed25519PrivateKeySize)
        let pubPtr = try allocate(CryptoConstants.ed25519PublicKeySize)

        defer {
            try? free(privPtr)
            try? free(pubPtr)
        }

        let result = try ed25519GenerateFn.invoke([.i32(privPtr), .i32(pubPtr)])

        if result.first?.i32 != 0 {
            throw EncryptionError.keyGenerationFailed
        }

        return Ed25519KeyPair(
            privateKey: try readBytes(privPtr, CryptoConstants.ed25519PrivateKeySize),
            publicKey: try readBytes(pubPtr, CryptoConstants.ed25519PublicKeySize)
        )
    }

    /// Sign with Ed25519
    public func ed25519Sign(privateKey: [UInt8], message: [UInt8]) throws -&gt; [UInt8] {
        let privPtr = try allocate(privateKey.count)
        let msgPtr = try allocate(message.count)
        let sigPtr = try allocate(CryptoConstants.ed25519SignatureSize)

        defer {
            try? free(privPtr)
            try? free(msgPtr)
            try? free(sigPtr)
        }

        try writeBytes(privPtr, privateKey)
        try writeBytes(msgPtr, message)

        let result = try ed25519SignFn.invoke([
            .i32(privPtr),
            .i32(msgPtr),
            .i32(Int32(message.count)),
            .i32(sigPtr)
        ])

        if result.first?.i32 != 0 {
            throw EncryptionError.signatureFailed
        }

        return try readBytes(sigPtr, CryptoConstants.ed25519SignatureSize)
    }

    /// Verify Ed25519 signature
    public func ed25519Verify(publicKey: [UInt8], message: [UInt8], signature: [UInt8]) throws -&gt; Bool {
        let pubPtr = try allocate(publicKey.count)
        let msgPtr = try allocate(message.count)
        let sigPtr = try allocate(signature.count)

        defer {
            try? free(pubPtr)
            try? free(msgPtr)
            try? free(sigPtr)
        }

        try writeBytes(pubPtr, publicKey)
        try writeBytes(msgPtr, message)
        try writeBytes(sigPtr, signature)

        let result = try ed25519VerifyFn.invoke([
            .i32(pubPtr),
            .i32(msgPtr),
            .i32(Int32(message.count)),
            .i32(sigPtr)
        ])

        return result.first?.i32 == 0
    }
}

// MARK: - WASI Stubs

private func registerWasiStubs(runtime: Runtime) throws {
    try runtime.defineHostFunction(
        module: &quot;wasi_snapshot_preview1&quot;,
        name: &quot;fd_close&quot;,
        paramTypes: [.i32],
        resultTypes: [.i32]
    ) { _ in [.i32(0)] }

    try runtime.defineHostFunction(
        module: &quot;wasi_snapshot_preview1&quot;,
        name: &quot;clock_time_get&quot;,
        paramTypes: [.i32, .i64, .i32],
        resultTypes: [.i32]
    ) { _ in [.i32(0)] }

    // Add other WASI stubs as needed...
}

private func registerEnvStubs(runtime: Runtime) throws {
    try runtime.defineHostFunction(
        module: &quot;env&quot;,
        name: &quot;invoke_v&quot;,
        paramTypes: [.i32],
        resultTypes: []
    ) { _ in [] }

    try runtime.defineHostFunction(
        module: &quot;env&quot;,
        name: &quot;invoke_vi&quot;,
        paramTypes: [.i32, .i32],
        resultTypes: []
    ) { _ in [] }

    // Add other invoke_* stubs as needed...
}
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>Template Project Structure</h2>
<pre><code>MyProject/
├── Package.swift
├── Sources/
│   └── MyProject/
│       ├── main.swift
│       └── Encryption/
│           └── EncryptionModule.swift
├── Resources/
│   └── flatc-encryption.wasm
└── Tests/
    └── MyProjectTests/
        └── EncryptionTests.swift
</code></pre>
<p><strong>Package.swift:</strong></p>
<pre><code class="language-swift">// swift-tools-version: 5.9
import PackageDescription

let package = Package(
    name: &quot;MyProject&quot;,
    platforms: [.macOS(.v13), .iOS(.v16)],
    dependencies: [
        .package(url: &quot;https://github.com/AO/WasmKit.git&quot;, from: &quot;0.0.5&quot;)
    ],
    targets: [
        .executableTarget(
            name: &quot;MyProject&quot;,
            dependencies: [&quot;WasmKit&quot;],
            resources: [.copy(&quot;Resources/flatc-encryption.wasm&quot;)]
        ),
        .testTarget(
            name: &quot;MyProjectTests&quot;,
            dependencies: [&quot;MyProject&quot;]
        )
    ]
)
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Usage Examples</h2>
<h3>Basic Encryption</h3>
<pre><code class="language-swift">let module = try EncryptionModule(path: &quot;flatc-encryption.wasm&quot;)

var key = [UInt8](repeating: 0, count: 32)
var iv = [UInt8](repeating: 0, count: 16)
_ = SecRandomCopyBytes(kSecRandomDefault, key.count, &amp;key)
_ = SecRandomCopyBytes(kSecRandomDefault, iv.count, &amp;iv)

let plaintext = Array(&quot;Secret message&quot;.utf8)
let ciphertext = try module.encrypt(key: key, iv: iv, data: plaintext)
let decrypted = try module.decrypt(key: key, iv: iv, data: ciphertext)

assert(plaintext == decrypted)
</code></pre>
<h3>End-to-End Encryption</h3>
<pre><code class="language-swift">let module = try EncryptionModule(path: &quot;flatc-encryption.wasm&quot;)

// Generate key pairs
let alice = try module.x25519GenerateKeyPair()
let bob = try module.x25519GenerateKeyPair()

// Compute shared secrets
let aliceShared = try module.x25519SharedSecret(
    privateKey: alice.privateKey,
    publicKey: bob.publicKey
)
let bobShared = try module.x25519SharedSecret(
    privateKey: bob.privateKey,
    publicKey: alice.publicKey
)

assert(aliceShared == bobShared)

// Derive encryption key
let encryptionKey = try module.hkdf(
    ikm: aliceShared,
    salt: nil,
    info: Array(&quot;encryption-v1&quot;.utf8),
    length: 32
)

// Encrypt
var iv = [UInt8](repeating: 0, count: 16)
_ = SecRandomCopyBytes(kSecRandomDefault, iv.count, &amp;iv)
let ciphertext = try module.encrypt(key: encryptionKey, iv: iv, data: Array(&quot;Hello Bob!&quot;.utf8))

// Decrypt
let decrypted = try module.decrypt(key: encryptionKey, iv: iv, data: ciphertext)
print(String(bytes: decrypted, encoding: .utf8)!) // &quot;Hello Bob!&quot;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>Performance Tips</h2>
<ol>
<li><strong>Reuse module instances</strong> - Module loading is expensive</li>
<li><strong>Use async/await</strong> - For non-blocking operations in SwiftUI</li>
<li><strong>Batch allocations</strong> - Minimize malloc/free calls</li>
</ol>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg></span>Troubleshooting</h2>
<h3>"Export not found"</h3>
<p>Ensure WASI and env stubs are registered before instantiation.</p>
<h3>"Memory access out of bounds"</h3>
<p>Check allocation succeeded and sizes are correct.</p>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg></span>See Also</h2>
<ul>
<li><a href="https://github.com/AO/WasmKit">WasmKit Documentation</a></li>
<li><a href="README.html">API Reference</a></li>
<li><a href="README.html#security-considerations">Security Considerations</a></li>
</ul>
</article>
  </div>

  <script>
    // Initialize HLS video with random selection
    const videoUrls = [
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/90bb1b34646b81b3b63e5a854ea00da3/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/df176a2fb2ea2b64bd21ae1c10d3af6a/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/12a9780eeb1ea015801a5f55cf2e9d3d/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/964cb3eddff1a67e3772aac9a7aceea2/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/dd17599dfa77f41517133fa7a4967535/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/408ad52e3f15bc8f01ae69d194a8cf3a/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/e923e67d71fed3e0853ec57f0348451e/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/136a8a211c6c3b1cc1fd7b1c7d836c58/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/c9ddd33ac3d964e5d33b31ce849e8f95/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/257c7359efd4b4aaebcc03aa8fc78a36/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/697945ca6b876878dba3b23fbd2f1561/manifest/video.m3u8"
    ];

    const video = document.getElementById('bg-video');
    const randomUrl = videoUrls[Math.floor(Math.random() * videoUrls.length)];

    if (Hls.isSupported()) {
      const hls = new Hls();
      hls.loadSource(randomUrl);
      hls.attachMedia(video);
    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
      video.src = randomUrl;
    }
  </script>
</body>
</html>
