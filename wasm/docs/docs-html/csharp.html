<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Csharp - DA FlatBuffers</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --black: #000000;
      --white: #F5F5F7;
      --white-90: rgba(255, 255, 255, 0.9);
      --white-80: rgba(255, 255, 255, 0.8);
      --white-60: rgba(255, 255, 255, 0.6);
      --white-40: rgba(255, 255, 255, 0.4);
      --white-20: rgba(255, 255, 255, 0.2);
      --white-10: rgba(255, 255, 255, 0.1);
      --white-05: rgba(255, 255, 255, 0.05);
      --muted: rgba(134, 134, 139, 1.0);
      --glass-bg: rgba(42, 42, 45, 0.72);
      --glass-hover: rgba(66, 66, 69, 0.72);
      --glass-border: rgba(255, 255, 255, 0.1);
      --glass-blur: blur(20px);
      --radius: 28px;
      --radius-sm: 14px;

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;

    html {
      scroll-behavior: smooth;

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--black);
      color: var(--white);
      line-height: 1.6;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;

    /* Video Background */
    .video-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      overflow: hidden;

    .video-background video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.3;

    .video-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        to bottom,
        rgba(0, 0, 0, 0.4) 0%,
        rgba(0, 0, 0, 0.6) 50%,
        rgba(0, 0, 0, 0.85) 100%
      );

    .page-container {
      position: relative;
      z-index: 1;
      max-width: 900px;
      margin: 0 auto;
      padding: 60px 24px 80px;

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      margin-bottom: 40px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      color: var(--white);
      text-decoration: none;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.3s ease;

    .back-link:hover {
      background: var(--glass-hover);
      transform: translateY(-2px);

    .markdown-body {
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      padding: 64px;

    .markdown-body h1 {
      color: var(--white);
      font-size: 56px;
      font-weight: 600;
      line-height: 1.1;
      margin-bottom: 32px;
      letter-spacing: -0.02em;

    .markdown-body h2 {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--white);
      font-size: 28px;
      font-weight: 600;
      line-height: 1.15;
      margin-top: 56px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--glass-border);

    .markdown-body h2::before {
      content: '';
      display: inline-flex;
      width: 24px;
      height: 24px;
      background: var(--white);
      -webkit-mask-size: contain;
      mask-size: contain;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
      flex-shrink: 0;

    /* Icon mappings for h2 headers based on content */
    .markdown-body h2[id*="why"]::before,
    .markdown-body h2:has(+ p:first-of-type)::before {
      -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
      mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");

    .markdown-body h3,
    .markdown-body h4 {
      color: var(--white);
      font-weight: 600;
      margin-top: 32px;
      margin-bottom: 16px;

    .markdown-body h3 {
      font-size: 22px;

    .markdown-body h4 {
      font-size: 18px;
      color: var(--white-90);

    .markdown-body p {
      color: var(--white-80);
      font-size: 18px;
      line-height: 1.7;
      margin-bottom: 20px;

    .markdown-body a {
      color: var(--white);
      text-decoration: underline;
      text-underline-offset: 3px;
      transition: opacity 0.2s;

    .markdown-body a:hover {
      opacity: 0.7;

    .markdown-body strong {
      color: var(--white);
      font-weight: 600;

    .markdown-body code {
      background: var(--glass-hover);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      padding: 3px 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9em;
      color: var(--white);

    .markdown-body pre {
      background: var(--black) !important;
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      padding: 24px;
      overflow-x: auto;
      margin: 24px 0;

    .markdown-body pre code {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 14px;
      line-height: 1.7;
      color: var(--white-90);

    .markdown-body ul, .markdown-body ol {
      padding-left: 24px;
      margin-bottom: 20px;

    .markdown-body li {
      margin: 12px 0;
      color: var(--white-80);
      font-size: 18px;

    .markdown-body li strong {
      color: var(--white);

    .markdown-body table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      border-radius: var(--radius-sm);
      overflow: hidden;

    .markdown-body table th,
    .markdown-body table td {
      border: 1px solid var(--glass-border);
      padding: 14px 18px;
      text-align: left;

    .markdown-body table th {
      background: var(--glass-hover);
      font-weight: 600;
      color: var(--white);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;

    .markdown-body table td {
      background: var(--white-05);
      color: var(--white-80);

    .markdown-body table tr:nth-child(even) td {
      background: var(--white-10);

    .markdown-body blockquote {
      border-left: 4px solid var(--white-40);
      background: var(--white-05);
      padding: 20px 24px;
      margin: 24px 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;

    .markdown-body blockquote p {
      margin: 0;
      color: var(--white-80);

    .markdown-body hr {
      border: none;
      height: 1px;
      background: var(--glass-border);
      margin: 48px 0;

    /* Section header icons */
    .section-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: var(--white-10);
      border-radius: 8px;
      margin-right: 12px;
      flex-shrink: 0;

    .section-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--white);
      fill: none;
      stroke-width: 2;

    @media (max-width: 768px) {
      .page-container {
        padding: 40px 16px 60px;
      .markdown-body {
        padding: 32px 24px;
        border-radius: 20px;
      .markdown-body h1 {
        font-size: 36px;
      .markdown-body h2 {
        font-size: 24px;
      .markdown-body p,
      .markdown-body li {
        font-size: 16px;
  </style>
</head>
<body>
  <!-- Video Background -->
  <div class="video-background">
    <video autoplay loop muted playsinline id="bg-video">
      <source src="" type="application/x-mpegURL">
    </video>
    <div class="video-overlay"></div>
  </div>

  <div class="page-container">
    <a href="../index.html" class="back-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
      Back to DA FlatBuffers
    </a>
    <article class="markdown-body"><h1>C# Integration Guide</h1>
<p>Integrate the FlatBuffers encryption WASM module into .NET applications using <a href="https://wasmtime.dev/">Wasmtime</a>, a fast and secure WebAssembly runtime.</p>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg></span>Why Wasmtime?</h2>
<ul>
<li><strong>Production ready</strong> - Used by Fastly, Shopify, and others</li>
<li><strong>Fast</strong> - Optimizing compiler with excellent performance</li>
<li><strong>.NET 6+ support</strong> - Modern .NET integration</li>
<li><strong>NuGet package</strong> - Easy installation</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>Prerequisites</h2>
<ul>
<li>.NET 6.0 or later</li>
<li><code>flatc-encryption.wasm</code> binary</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></span>Installation</h2>
<pre><code class="language-bash">dotnet add package Wasmtime
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>Quick Start</h2>
<pre><code class="language-csharp">using Wasmtime;

var engine = new Engine();
using var linker = new Linker(engine);
using var store = new Store(engine);

// Add WASI stubs
linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;fd_close&quot;, (int fd) =&gt; 0);
linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;clock_time_get&quot;,
    (Caller caller, int clockId, long precision, int time) =&gt; 0);
// Add other WASI functions as needed...

// Load module
using var module = Module.FromFile(engine, &quot;flatc-encryption.wasm&quot;);
var instance = linker.Instantiate(store, module);

// Get exports
var memory = instance.GetMemory(&quot;memory&quot;)!;
var malloc = instance.GetFunction(&quot;malloc&quot;)!;
var free = instance.GetFunction(&quot;free&quot;)!;
var encrypt = instance.GetFunction(&quot;wasi_encrypt_bytes&quot;)!;

// Encrypt data
var key = new byte[32];
var iv = new byte[16];
Random.Shared.NextBytes(key);
Random.Shared.NextBytes(iv);

var plaintext = System.Text.Encoding.UTF8.GetBytes(&quot;Hello, FlatBuffers!&quot;);

// Allocate WASM memory
var keyPtr = (int)malloc.Invoke(32)!;
var ivPtr = (int)malloc.Invoke(16)!;
var dataPtr = (int)malloc.Invoke(plaintext.Length)!;

// Write to memory
memory.WriteBytes(keyPtr, key);
memory.WriteBytes(ivPtr, iv);
memory.WriteBytes(dataPtr, plaintext);

// Encrypt
encrypt.Invoke(keyPtr, ivPtr, dataPtr, plaintext.Length);

// Read encrypted data
var ciphertext = memory.ReadBytes(dataPtr, plaintext.Length);
Console.WriteLine($&quot;Encrypted: {Convert.ToHexString(ciphertext)}&quot;);

// Clean up
free.Invoke(keyPtr);
free.Invoke(ivPtr);
free.Invoke(dataPtr);
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></span>Complete Module Wrapper</h2>
<pre><code class="language-csharp">using Wasmtime;
using System.Security.Cryptography;
using System.Text;

namespace FlatBuffers.Encryption;

/// &lt;summary&gt;
/// FlatBuffers Encryption Module for .NET.
///
/// Provides cryptographic operations via the Crypto++ WASM module:
/// - AES-256-CTR symmetric encryption
/// - X25519 ECDH key exchange
/// - secp256k1 ECDH and ECDSA signatures
/// - P-256 ECDH and ECDSA signatures
/// - Ed25519 signatures
/// &lt;/summary&gt;
public sealed class EncryptionModule : IDisposable
{
    // Key and signature sizes
    public const int AesKeySize = 32;
    public const int AesIvSize = 16;
    public const int Sha256Size = 32;

    public const int X25519PrivateKeySize = 32;
    public const int X25519PublicKeySize = 32;

    public const int Secp256k1PrivateKeySize = 32;
    public const int Secp256k1PublicKeySize = 33;
    public const int Secp256k1SignatureMaxSize = 72;

    public const int Ed25519PrivateKeySize = 64;
    public const int Ed25519PublicKeySize = 32;
    public const int Ed25519SignatureSize = 64;

    private readonly Engine _engine;
    private readonly Store _store;
    private readonly Linker _linker;
    private readonly Instance _instance;
    private readonly Memory _memory;

    private readonly Func&lt;int, int&gt; _malloc;
    private readonly Action&lt;int&gt; _free;

    private readonly Func&lt;int, int, int, int, int&gt; _encrypt;
    private readonly Func&lt;int, int, int, int, int&gt; _decrypt;
    private readonly Action&lt;int, int, int&gt; _sha256;
    private readonly Action&lt;int, int, int, int, int, int, int, int&gt; _hkdf;

    private readonly Func&lt;int, int, int&gt; _x25519Generate;
    private readonly Func&lt;int, int, int, int&gt; _x25519Shared;

    private readonly Func&lt;int, int, int&gt; _secp256k1Generate;
    private readonly Func&lt;int, int, int, int, int&gt; _secp256k1Shared;
    private readonly Func&lt;int, int, int, int, int, int&gt; _secp256k1Sign;
    private readonly Func&lt;int, int, int, int, int, int, int&gt; _secp256k1Verify;

    private readonly Func&lt;int, int, int&gt; _ed25519Generate;
    private readonly Func&lt;int, int, int, int, int&gt; _ed25519Sign;
    private readonly Func&lt;int, int, int, int, int&gt; _ed25519Verify;

    public EncryptionModule(string wasmPath)
    {
        _engine = new Engine();
        _store = new Store(_engine);
        _linker = new Linker(_engine);

        // Define WASI stubs
        DefineWasiStubs();
        DefineEnvStubs();

        // Load and instantiate module
        using var module = Module.FromFile(_engine, wasmPath);
        _instance = _linker.Instantiate(_store, module);

        // Get memory
        _memory = _instance.GetMemory(&quot;memory&quot;)
            ?? throw new InvalidOperationException(&quot;Memory export not found&quot;);

        // Get functions
        _malloc = _instance.GetFunction&lt;int, int&gt;(&quot;malloc&quot;)
            ?? throw new InvalidOperationException(&quot;malloc not found&quot;);
        _free = _instance.GetAction&lt;int&gt;(&quot;free&quot;)
            ?? throw new InvalidOperationException(&quot;free not found&quot;);

        _encrypt = _instance.GetFunction&lt;int, int, int, int, int&gt;(&quot;wasi_encrypt_bytes&quot;)!;
        _decrypt = _instance.GetFunction&lt;int, int, int, int, int&gt;(&quot;wasi_decrypt_bytes&quot;)!;
        _sha256 = _instance.GetAction&lt;int, int, int&gt;(&quot;wasi_sha256&quot;)!;
        _hkdf = _instance.GetAction&lt;int, int, int, int, int, int, int, int&gt;(&quot;wasi_hkdf&quot;)!;

        _x25519Generate = _instance.GetFunction&lt;int, int, int&gt;(&quot;wasi_x25519_generate_keypair&quot;)!;
        _x25519Shared = _instance.GetFunction&lt;int, int, int, int&gt;(&quot;wasi_x25519_shared_secret&quot;)!;

        _secp256k1Generate = _instance.GetFunction&lt;int, int, int&gt;(&quot;wasi_secp256k1_generate_keypair&quot;)!;
        _secp256k1Shared = _instance.GetFunction&lt;int, int, int, int, int&gt;(&quot;wasi_secp256k1_shared_secret&quot;)!;
        _secp256k1Sign = _instance.GetFunction&lt;int, int, int, int, int, int&gt;(&quot;wasi_secp256k1_sign&quot;)!;
        _secp256k1Verify = _instance.GetFunction&lt;int, int, int, int, int, int, int&gt;(&quot;wasi_secp256k1_verify&quot;)!;

        _ed25519Generate = _instance.GetFunction&lt;int, int, int&gt;(&quot;wasi_ed25519_generate_keypair&quot;)!;
        _ed25519Sign = _instance.GetFunction&lt;int, int, int, int, int&gt;(&quot;wasi_ed25519_sign&quot;)!;
        _ed25519Verify = _instance.GetFunction&lt;int, int, int, int, int&gt;(&quot;wasi_ed25519_verify&quot;)!;

    private void DefineWasiStubs()
    {
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;fd_close&quot;,
            (int fd) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;fd_seek&quot;,
            (Caller c, int fd, long offset, int whence, int newOffset) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;fd_write&quot;,
            (Caller c, int fd, int iovs, int iovsLen, int nwritten) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;fd_read&quot;,
            (Caller c, int fd, int iovs, int iovsLen, int nread) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;environ_sizes_get&quot;,
            (Caller c, int count, int size) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;environ_get&quot;,
            (Caller c, int environ, int environBuf) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;clock_time_get&quot;,
            (Caller c, int clockId, long precision, int time) =&gt; 0);
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;proc_exit&quot;,
            (int code) =&gt; { });
        _linker.DefineFunction(&quot;wasi_snapshot_preview1&quot;, &quot;random_get&quot;,
            (Caller c, int buf, int bufLen) =&gt; 0);

    private void DefineEnvStubs()
    {
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_v&quot;, (int idx) =&gt; { });
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_vi&quot;, (int idx, int a) =&gt; { });
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_vii&quot;, (int idx, int a, int b) =&gt; { });
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_viii&quot;, (int idx, int a, int b, int c) =&gt; { });
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_i&quot;, (int idx) =&gt; 0);
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_ii&quot;, (int idx, int a) =&gt; 0);
        _linker.DefineFunction(&quot;env&quot;, &quot;invoke_iii&quot;, (int idx, int a, int b) =&gt; 0);

    // Key pair records

    public record X25519KeyPair(byte[] PrivateKey, byte[] PublicKey);
    public record Ed25519KeyPair(byte[] PrivateKey, byte[] PublicKey);
    public record Secp256k1KeyPair(byte[] PrivateKey, byte[] PublicKey);

    // Memory helpers

    private void WriteBytes(int offset, ReadOnlySpan&lt;byte&gt; data)
    {
        var span = _memory.GetSpan&lt;byte&gt;(offset, data.Length);
        data.CopyTo(span);

    private byte[] ReadBytes(int offset, int length)
    {
        var span = _memory.GetSpan&lt;byte&gt;(offset, length);
        return span.ToArray();

    private int Allocate(int size)
    {
        var ptr = _malloc(size);
        if (ptr == 0)
            throw new OutOfMemoryException(&quot;WASM malloc returned null&quot;);
        return ptr;

    // Symmetric Encryption

    /// &lt;summary&gt;
    /// Encrypt data using AES-256-CTR.
    /// &lt;/summary&gt;
    public byte[] Encrypt(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; iv, ReadOnlySpan&lt;byte&gt; data)
    {
        if (key.Length != AesKeySize)
            throw new ArgumentException($&quot;Key must be {AesKeySize} bytes&quot;, nameof(key));
        if (iv.Length != AesIvSize)
            throw new ArgumentException($&quot;IV must be {AesIvSize} bytes&quot;, nameof(iv));

        var keyPtr = Allocate(key.Length);
        var ivPtr = Allocate(iv.Length);
        var dataPtr = Allocate(data.Length);

        try
        {
            WriteBytes(keyPtr, key);
            WriteBytes(ivPtr, iv);
            WriteBytes(dataPtr, data);

            var result = _encrypt(keyPtr, ivPtr, dataPtr, data.Length);
            if (result != 0)
                throw new CryptographicException(&quot;Encryption failed&quot;);

            return ReadBytes(dataPtr, data.Length);
        finally
        {
            _free(keyPtr);
            _free(ivPtr);
            _free(dataPtr);

    /// &lt;summary&gt;
    /// Decrypt data using AES-256-CTR.
    /// &lt;/summary&gt;
    public byte[] Decrypt(ReadOnlySpan&lt;byte&gt; key, ReadOnlySpan&lt;byte&gt; iv, ReadOnlySpan&lt;byte&gt; data)
    {
        // CTR mode is symmetric
        return Encrypt(key, iv, data);

    // Hash Functions

    /// &lt;summary&gt;
    /// Compute SHA-256 hash.
    /// &lt;/summary&gt;
    public byte[] Sha256(ReadOnlySpan&lt;byte&gt; data)
    {
        var dataPtr = Allocate(data.Length);
        var outPtr = Allocate(Sha256Size);

        try
        {
            WriteBytes(dataPtr, data);
            _sha256(dataPtr, data.Length, outPtr);
            return ReadBytes(outPtr, Sha256Size);
        finally
        {
            _free(dataPtr);
            _free(outPtr);

    /// &lt;summary&gt;
    /// Derive key using HKDF-SHA256.
    /// &lt;/summary&gt;
    public byte[] Hkdf(ReadOnlySpan&lt;byte&gt; ikm, ReadOnlySpan&lt;byte&gt; salt, ReadOnlySpan&lt;byte&gt; info, int length)
    {
        var ikmPtr = Allocate(ikm.Length);
        WriteBytes(ikmPtr, ikm);

        var saltPtr = 0;
        var saltLen = 0;
        if (!salt.IsEmpty)
        {
            saltPtr = Allocate(salt.Length);
            WriteBytes(saltPtr, salt);
            saltLen = salt.Length;

        var infoPtr = Allocate(info.Length);
        WriteBytes(infoPtr, info);

        var outPtr = Allocate(length);

        try
        {
            _hkdf(ikmPtr, ikm.Length, saltPtr, saltLen, infoPtr, info.Length, outPtr, length);
            return ReadBytes(outPtr, length);
        finally
        {
            _free(ikmPtr);
            if (saltPtr != 0) _free(saltPtr);
            _free(infoPtr);
            _free(outPtr);

    // X25519 Key Exchange

    /// &lt;summary&gt;
    /// Generate X25519 key pair.
    /// &lt;/summary&gt;
    public X25519KeyPair X25519GenerateKeyPair()
    {
        var privPtr = Allocate(X25519PrivateKeySize);
        var pubPtr = Allocate(X25519PublicKeySize);

        try
        {
            var result = _x25519Generate(privPtr, pubPtr);
            if (result != 0)
                throw new CryptographicException(&quot;Key generation failed&quot;);

            return new X25519KeyPair(
                ReadBytes(privPtr, X25519PrivateKeySize),
                ReadBytes(pubPtr, X25519PublicKeySize)
            );
        finally
        {
            _free(privPtr);
            _free(pubPtr);

    /// &lt;summary&gt;
    /// Compute X25519 shared secret.
    /// &lt;/summary&gt;
    public byte[] X25519SharedSecret(ReadOnlySpan&lt;byte&gt; privateKey, ReadOnlySpan&lt;byte&gt; publicKey)
    {
        var privPtr = Allocate(privateKey.Length);
        var pubPtr = Allocate(publicKey.Length);
        var outPtr = Allocate(32);

        try
        {
            WriteBytes(privPtr, privateKey);
            WriteBytes(pubPtr, publicKey);

            var result = _x25519Shared(privPtr, pubPtr, outPtr);
            if (result != 0)
                throw new CryptographicException(&quot;Shared secret computation failed&quot;);

            return ReadBytes(outPtr, 32);
        finally
        {
            _free(privPtr);
            _free(pubPtr);
            _free(outPtr);

    // Ed25519 Signatures

    /// &lt;summary&gt;
    /// Generate Ed25519 key pair.
    /// &lt;/summary&gt;
    public Ed25519KeyPair Ed25519GenerateKeyPair()
    {
        var privPtr = Allocate(Ed25519PrivateKeySize);
        var pubPtr = Allocate(Ed25519PublicKeySize);

        try
        {
            var result = _ed25519Generate(privPtr, pubPtr);
            if (result != 0)
                throw new CryptographicException(&quot;Key generation failed&quot;);

            return new Ed25519KeyPair(
                ReadBytes(privPtr, Ed25519PrivateKeySize),
                ReadBytes(pubPtr, Ed25519PublicKeySize)
            );
        finally
        {
            _free(privPtr);
            _free(pubPtr);

    /// &lt;summary&gt;
    /// Sign with Ed25519.
    /// &lt;/summary&gt;
    public byte[] Ed25519Sign(ReadOnlySpan&lt;byte&gt; privateKey, ReadOnlySpan&lt;byte&gt; message)
    {
        var privPtr = Allocate(privateKey.Length);
        var msgPtr = Allocate(message.Length);
        var sigPtr = Allocate(Ed25519SignatureSize);

        try
        {
            WriteBytes(privPtr, privateKey);
            WriteBytes(msgPtr, message);

            var result = _ed25519Sign(privPtr, msgPtr, message.Length, sigPtr);
            if (result != 0)
                throw new CryptographicException(&quot;Signing failed&quot;);

            return ReadBytes(sigPtr, Ed25519SignatureSize);
        finally
        {
            _free(privPtr);
            _free(msgPtr);
            _free(sigPtr);

    /// &lt;summary&gt;
    /// Verify Ed25519 signature.
    /// &lt;/summary&gt;
    public bool Ed25519Verify(ReadOnlySpan&lt;byte&gt; publicKey, ReadOnlySpan&lt;byte&gt; message, ReadOnlySpan&lt;byte&gt; signature)
    {
        var pubPtr = Allocate(publicKey.Length);
        var msgPtr = Allocate(message.Length);
        var sigPtr = Allocate(signature.Length);

        try
        {
            WriteBytes(pubPtr, publicKey);
            WriteBytes(msgPtr, message);
            WriteBytes(sigPtr, signature);

            var result = _ed25519Verify(pubPtr, msgPtr, message.Length, sigPtr);
            return result == 0;
        finally
        {
            _free(pubPtr);
            _free(msgPtr);
            _free(sigPtr);

    public void Dispose()
    {
        _store.Dispose();
        _linker.Dispose();
        _engine.Dispose();
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>Template Project Structure</h2>
<pre><code>MyProject/
├── MyProject.csproj
├── Program.cs
├── Encryption/
│   └── EncryptionModule.cs
├── wasm/
│   └── flatc-encryption.wasm
└── Tests/
    └── EncryptionTests.cs
</code></pre>
<p><strong>MyProject.csproj:</strong></p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;
  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;PackageReference Include=&quot;Wasmtime&quot; Version=&quot;18.0.0&quot; /&gt;
  &lt;/ItemGroup&gt;

  &lt;ItemGroup&gt;
    &lt;None Update=&quot;wasm\flatc-encryption.wasm&quot;&gt;
      &lt;CopyToOutputDirectory&gt;PreserveNewest&lt;/CopyToOutputDirectory&gt;
    &lt;/None&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Usage Examples</h2>
<h3>Basic Encryption</h3>
<pre><code class="language-csharp">using var module = new EncryptionModule(&quot;flatc-encryption.wasm&quot;);

var key = new byte[32];
var iv = new byte[16];
Random.Shared.NextBytes(key);
Random.Shared.NextBytes(iv);

var plaintext = Encoding.UTF8.GetBytes(&quot;Secret message&quot;);
var ciphertext = module.Encrypt(key, iv, plaintext);
var decrypted = module.Decrypt(key, iv, ciphertext);

Debug.Assert(plaintext.SequenceEqual(decrypted));
</code></pre>
<h3>End-to-End Encryption</h3>
<pre><code class="language-csharp">using var module = new EncryptionModule(&quot;flatc-encryption.wasm&quot;);

// Generate key pairs
var alice = module.X25519GenerateKeyPair();
var bob = module.X25519GenerateKeyPair();

// Compute shared secrets
var aliceShared = module.X25519SharedSecret(alice.PrivateKey, bob.PublicKey);
var bobShared = module.X25519SharedSecret(bob.PrivateKey, alice.PublicKey);

Debug.Assert(aliceShared.SequenceEqual(bobShared));

// Derive encryption key
var encryptionKey = module.Hkdf(aliceShared, default, &quot;encryption-v1&quot;u8, 32);

// Encrypt
var iv = new byte[16];
Random.Shared.NextBytes(iv);
var ciphertext = module.Encrypt(encryptionKey, iv, &quot;Hello Bob!&quot;u8);

// Decrypt
var decrypted = module.Decrypt(encryptionKey, iv, ciphertext);
Console.WriteLine(Encoding.UTF8.GetString(decrypted)); // &quot;Hello Bob!&quot;
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg></span>Performance Tips</h2>
<ol>
<li><strong>Reuse module instances</strong> - Module loading is expensive</li>
<li><strong>Use Span<byte></strong> - Avoid unnecessary allocations</li>
<li><strong>Consider object pooling</strong> - For high-throughput scenarios</li>
</ol>
<pre><code class="language-csharp">// Good: Reuse instance
using var module = new EncryptionModule(&quot;wasm&quot;);
foreach (var item in items)
{
    module.Encrypt(key, iv, item);

// Bad: Create new instance each time
foreach (var item in items)
{
    using var module = new EncryptionModule(&quot;wasm&quot;); // Slow!
    module.Encrypt(key, iv, item);
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg></span>Troubleshooting</h2>
<h3>"Function not found"</h3>
<p>Ensure WASI and env stubs are defined before instantiation.</p>
<h3>"Memory access out of bounds"</h3>
<p>Check allocation succeeded:</p>
<pre><code class="language-csharp">var ptr = _malloc(size);
if (ptr == 0)
    throw new OutOfMemoryException(&quot;Allocation failed&quot;);
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg></span>See Also</h2>
<ul>
<li><a href="https://docs.wasmtime.dev/">Wasmtime .NET Documentation</a></li>
<li><a href="README.html#api-reference">API Reference</a></li>
<li><a href="README.html#security-considerations">Security Considerations</a></li>
</ul>
</article>
  </div>

  <script>
    // Initialize video with random selection
    const videoUrls = [
      "../videos/bg-1.mp4",
      "../videos/bg-2.mp4",
      "../videos/bg-3.mp4",
      "../videos/bg-4.mp4",
      "../videos/bg-5.mp4",
      "../videos/bg-6.mp4",
      "../videos/bg-7.mp4",
      "../videos/bg-8.mp4",
      "../videos/bg-9.mp4",
      "../videos/bg-10.mp4",
      "../videos/bg-11.mp4"
    ];

    const video = document.getElementById('bg-video');
    video.src = videoUrls[Math.floor(Math.random() * videoUrls.length)];
  </script>
</body>
</html>