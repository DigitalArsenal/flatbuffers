/**
 * Cross-language verification test for Deno encryption implementation.
 *
 * This script loads test vectors generated by the JavaScript implementation
 * and verifies that Deno can correctly decrypt them.
 *
 * Usage: deno run --allow-read verify_deno.ts
 */

// Import the encryption module from the deno-encryption example
import { decryptBuffer, EncryptionContext } from "../deno-encryption/encryption.ts";

interface TestVector {
  name: string;
  schema: string;
  root_type: string;
  original_json: Record<string, unknown>;
  original_hex: string;
  encrypted_hex: string;
}

interface TestVectors {
  key_hex: string;
  flatc_version: string;
  vectors: TestVector[];
}

function fromHex(hex: string): Uint8Array {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
  }
  return bytes;
}

function toHex(bytes: Uint8Array): string {
  return Array.from(bytes)
    .map((b) => b.toString(16).padStart(2, "0"))
    .join("");
}

async function main() {
  // Try to find test_vectors.json
  const paths = [
    "./test_vectors.json",
    "./wasm/examples/cross-language-test/test_vectors.json",
    "../cross-language-test/test_vectors.json",
  ];

  let data: string | null = null;
  for (const path of paths) {
    try {
      data = await Deno.readTextFile(path);
      break;
    } catch {
      // Try next path
    }
  }

  if (!data) {
    console.error("Could not find test_vectors.json");
    console.error("Run this from the cross-language-test directory");
    Deno.exit(1);
  }

  const testData: TestVectors = JSON.parse(data);
  const key = fromHex(testData.key_hex);
  const ctx = new EncryptionContext(key);

  console.log(`Testing against ${testData.flatc_version}`);
  console.log(`Key: ${testData.key_hex.substring(0, 16)}...\n`);

  let passed = 0;
  let failed = 0;

  for (const vector of testData.vectors) {
    // Skip if no encryption happened
    if (vector.original_hex === vector.encrypted_hex) {
      console.log(`SKIP: ${vector.name} (no encrypted fields present)`);
      continue;
    }

    // Decrypt using our Deno implementation
    const encrypted = fromHex(vector.encrypted_hex);
    decryptBuffer(encrypted, vector.schema, ctx, vector.root_type);
    const decryptedHex = toHex(encrypted);

    if (decryptedHex === vector.original_hex) {
      console.log(`PASS: ${vector.name}`);
      passed++;
    } else {
      console.log(`FAIL: ${vector.name}`);
      console.log(`  Expected: ${vector.original_hex.substring(0, 80)}...`);
      console.log(`  Got:      ${decryptedHex.substring(0, 80)}...`);
      failed++;
    }
  }

  console.log(`\nResults: ${passed} passed, ${failed} failed`);
  if (failed > 0) {
    Deno.exit(1);
  }
}

main();
