// Package main implements the Go E2E test runner for FlatBuffers cross-language encryption.
//
// This test runner:
// 1. Loads test vectors and encryption keys
// 2. Reads binary files generated by Node.js
// 3. Decrypts using the WASM encryption module
// 4. Verifies decryption produces expected values
// 5. Generates its own encrypted binaries for other languages to verify
package main

import (
	"bytes"
	"context"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	flatbuffers "github.com/google/flatbuffers/go"
	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
	"github.com/tetratelabs/wazero/experimental/table"
	"github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1"

	Crypto "e2e-crypto-test/E2E/Crypto"
)

// WasmPath is the path to the encryption WASM module
const WasmPath = "../../../../../build/wasm/wasm/flatc-encryption.wasm"

// EncryptionKeys holds the derived encryption keys for each chain
type EncryptionKeys map[string]struct {
	KeyHex    string `json:"key_hex"`
	IVHex     string `json:"iv_hex"`
	KeyBase64 string `json:"key_base64"`
	IVBase64  string `json:"iv_base64"`
}

// CryptoKey holds the crypto key material for a chain
type CryptoKey struct {
	PrivateKeyHex string `json:"private_key_hex"`
	PublicKeyHex  string `json:"public_key_hex"`
	Address       string `json:"address"`
	Scheme        string `json:"scheme"`
}

// ECDHHeader stores ECDH header data for cross-language testing
type ECDHHeader struct {
	Version            int    `json:"version"`
	KeyExchange        int    `json:"key_exchange"`
	Symmetric          int    `json:"symmetric"`
	Kdf                int    `json:"kdf"`
	EphemeralPublicKey string `json:"ephemeral_public_key"`
	Context            string `json:"context"`
	Timestamp          int64  `json:"timestamp"`
	SessionKey         string `json:"session_key"`
	SessionIV          string `json:"session_iv"`
}

// TestResult tracks test outcomes
type TestResult struct {
	Name    string
	Passed  int
	Failed  int
	Errors  []string
}

func (r *TestResult) Pass(msg string) {
	r.Passed++
	fmt.Printf("  ✓ %s\n", msg)
}

func (r *TestResult) Fail(msg string, err error) {
	r.Failed++
	errMsg := msg
	if err != nil {
		errMsg = fmt.Sprintf("%s: %v", msg, err)
	}
	r.Errors = append(r.Errors, errMsg)
	fmt.Printf("  ✗ %s\n", errMsg)
}

func (r *TestResult) Summary() bool {
	total := r.Passed + r.Failed
	status := "✓"
	if r.Failed > 0 {
		status = "✗"
	}
	fmt.Printf("\n%s %s: %d/%d passed\n", status, r.Name, r.Passed, total)
	return r.Failed == 0
}

// EncryptionModule wraps the WASM encryption module
type EncryptionModule struct {
	runtime wazero.Runtime
	module  api.Module
	ctx     context.Context

	malloc       api.Function
	free         api.Function
	encryptBytes api.Function
	decryptBytes api.Function
	sha256       api.Function
	hkdf         api.Function
	getVersion   api.Function
	hasCryptopp  api.Function

	// X25519 functions
	x25519GenerateKeypair api.Function
	x25519SharedSecret    api.Function

	// secp256k1 functions
	secp256k1GenerateKeypair api.Function
	secp256k1SharedSecret    api.Function

	// P-256 functions
	p256GenerateKeypair api.Function
	p256SharedSecret    api.Function
	p256Sign            api.Function
	p256Verify          api.Function

	// Ed25519 functions
	ed25519GenerateKeypair api.Function
	ed25519Sign            api.Function
	ed25519Verify          api.Function

	// secp256k1 signing
	secp256k1Sign   api.Function
	secp256k1Verify api.Function
}

var wasmModule api.Module

func NewEncryptionModule(ctx context.Context, wasmBytes []byte) (*EncryptionModule, error) {
	r := wazero.NewRuntime(ctx)

	// Instantiate WASI
	wasi_snapshot_preview1.MustInstantiate(ctx, r)

	// Create env module with invoke_* trampolines
	i32 := api.ValueTypeI32

	setException := func(ctx context.Context) {
		if wasmModule != nil {
			if setThrew := wasmModule.ExportedFunction("setThrew"); setThrew != nil {
				setThrew.Call(ctx, 1, 0)
			}
		}
	}

	_, err := r.NewHostModuleBuilder("env").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, nil, nil)
			f.Call(ctx)
		}).Export("invoke_v").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32}, nil)
			f.Call(ctx, uint64(a))
		}).Export("invoke_vi").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b))
		}).Export("invoke_vii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c))
		}).Export("invoke_viii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d))
		}).Export("invoke_viiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e))
		}).Export("invoke_viiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff))
		}).Export("invoke_viiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g))
		}).Export("invoke_viiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g, h, ii uint32) {
			if wasmModule == nil {
				return
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32, i32, i32}, nil)
			f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g), uint64(h), uint64(ii))
		}).Export("invoke_viiiiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, nil, []api.ValueType{i32})
			res, _ := f.Call(ctx)
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_i").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_ii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, idx, a, b, c, d, e, ff, g, h, ii uint32) uint32 {
			if wasmModule == nil {
				return 0
			}
			defer func() {
				if r := recover(); r != nil {
					setException(ctx)
				}
			}()
			f := table.LookupFunction(wasmModule, 0, idx, []api.ValueType{i32, i32, i32, i32, i32, i32, i32, i32, i32}, []api.ValueType{i32})
			res, _ := f.Call(ctx, uint64(a), uint64(b), uint64(c), uint64(d), uint64(e), uint64(ff), uint64(g), uint64(h), uint64(ii))
			if len(res) > 0 {
				return uint32(res[0])
			}
			return 0
		}).Export("invoke_iiiiiiiiii").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module) uint32 { return 0 }).Export("__cxa_find_matching_catch_2").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) uint32 { return 0 }).Export("__cxa_find_matching_catch_3").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) {}).Export("__resumeException").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) uint32 { return 0 }).Export("__cxa_begin_catch").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module) {}).Export("__cxa_end_catch").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a uint32) uint32 { return 0 }).Export("llvm_eh_typeid_for").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module, a, b, c uint32) {}).Export("__cxa_throw").
		NewFunctionBuilder().WithFunc(func(ctx context.Context, m api.Module) uint32 { return 0 }).Export("__cxa_uncaught_exceptions").
		Instantiate(ctx)
	if err != nil {
		r.Close(ctx)
		return nil, fmt.Errorf("failed to instantiate env module: %w", err)
	}

	// Compile and instantiate the WASM module
	compiled, err := r.CompileModule(ctx, wasmBytes)
	if err != nil {
		r.Close(ctx)
		return nil, fmt.Errorf("failed to compile module: %w", err)
	}

	config := wazero.NewModuleConfig().WithName("flatc-encryption")
	mod, err := r.InstantiateModule(ctx, compiled, config)
	if err != nil {
		r.Close(ctx)
		return nil, fmt.Errorf("failed to instantiate module: %w", err)
	}

	wasmModule = mod

	// Call _initialize if present (required for Emscripten modules)
	if initFunc := mod.ExportedFunction("_initialize"); initFunc != nil {
		if _, err := initFunc.Call(ctx); err != nil {
			// Non-fatal - some modules don't need initialization
			fmt.Printf("Warning: _initialize failed: %v\n", err)
		}
	}

	return &EncryptionModule{
		runtime:                  r,
		module:                   mod,
		ctx:                      ctx,
		malloc:                   mod.ExportedFunction("malloc"),
		free:                     mod.ExportedFunction("free"),
		encryptBytes:             mod.ExportedFunction("wasi_encrypt_bytes"),
		decryptBytes:             mod.ExportedFunction("wasi_decrypt_bytes"),
		sha256:                   mod.ExportedFunction("wasi_sha256"),
		hkdf:                     mod.ExportedFunction("wasi_hkdf"),
		getVersion:               mod.ExportedFunction("wasi_get_version"),
		hasCryptopp:              mod.ExportedFunction("wasi_has_cryptopp"),
		x25519GenerateKeypair:    mod.ExportedFunction("wasi_x25519_generate_keypair"),
		x25519SharedSecret:       mod.ExportedFunction("wasi_x25519_shared_secret"),
		secp256k1GenerateKeypair: mod.ExportedFunction("wasi_secp256k1_generate_keypair"),
		secp256k1SharedSecret:    mod.ExportedFunction("wasi_secp256k1_shared_secret"),
		secp256k1Sign:            mod.ExportedFunction("wasi_secp256k1_sign"),
		secp256k1Verify:          mod.ExportedFunction("wasi_secp256k1_verify"),
		p256GenerateKeypair:      mod.ExportedFunction("wasi_p256_generate_keypair"),
		p256SharedSecret:         mod.ExportedFunction("wasi_p256_shared_secret"),
		p256Sign:                 mod.ExportedFunction("wasi_p256_sign"),
		p256Verify:               mod.ExportedFunction("wasi_p256_verify"),
		ed25519GenerateKeypair:   mod.ExportedFunction("wasi_ed25519_generate_keypair"),
		ed25519Sign:              mod.ExportedFunction("wasi_ed25519_sign"),
		ed25519Verify:            mod.ExportedFunction("wasi_ed25519_verify"),
	}, nil
}

func (em *EncryptionModule) Close() {
	em.runtime.Close(em.ctx)
}

func (em *EncryptionModule) memory() api.Memory {
	return em.module.Memory()
}

func (em *EncryptionModule) Version() string {
	res, _ := em.getVersion.Call(em.ctx)
	if len(res) == 0 || res[0] == 0 {
		return "unknown"
	}
	ptr := uint32(res[0])
	mem := em.memory()
	var result []byte
	for i := uint32(0); ; i++ {
		b, ok := mem.ReadByte(ptr + i)
		if !ok || b == 0 {
			break
		}
		result = append(result, b)
	}
	return string(result)
}

func (em *EncryptionModule) HasCryptopp() bool {
	res, _ := em.hasCryptopp.Call(em.ctx)
	return len(res) > 0 && res[0] != 0
}

func (em *EncryptionModule) EncryptBytes(key, iv, data []byte) error {
	keyPtr := em.alloc(32)
	ivPtr := em.alloc(16)
	dataPtr := em.alloc(uint32(len(data)))

	defer func() {
		em.dealloc(keyPtr)
		em.dealloc(ivPtr)
		em.dealloc(dataPtr)
	}()

	em.memory().Write(keyPtr, key)
	em.memory().Write(ivPtr, iv)
	em.memory().Write(dataPtr, data)

	_, err := em.encryptBytes.Call(em.ctx, uint64(keyPtr), uint64(ivPtr), uint64(dataPtr), uint64(len(data)))
	if err != nil {
		return err
	}

	// Read encrypted data back
	encrypted, ok := em.memory().Read(dataPtr, uint32(len(data)))
	if !ok {
		return fmt.Errorf("failed to read encrypted data")
	}
	copy(data, encrypted)
	return nil
}

func (em *EncryptionModule) DecryptBytes(key, iv, data []byte) error {
	return em.EncryptBytes(key, iv, data) // CTR mode is symmetric
}

func (em *EncryptionModule) SHA256(data []byte) ([]byte, error) {
	dataPtr := em.alloc(uint32(max(len(data), 1)))
	hashPtr := em.alloc(32)

	defer func() {
		em.dealloc(dataPtr)
		em.dealloc(hashPtr)
	}()

	if len(data) > 0 {
		em.memory().Write(dataPtr, data)
	}

	_, err := em.sha256.Call(em.ctx, uint64(dataPtr), uint64(len(data)), uint64(hashPtr))
	if err != nil {
		return nil, err
	}

	hash, ok := em.memory().Read(hashPtr, 32)
	if !ok {
		return nil, fmt.Errorf("failed to read hash")
	}
	return hash, nil
}

func (em *EncryptionModule) alloc(size uint32) uint32 {
	res, _ := em.malloc.Call(em.ctx, uint64(size))
	return uint32(res[0])
}

func (em *EncryptionModule) dealloc(ptr uint32) {
	em.free.Call(em.ctx, uint64(ptr))
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// HKDF derives key material from input keying material
func (em *EncryptionModule) HKDF(ikm, salt, info []byte, length int) ([]byte, error) {
	if em.hkdf == nil {
		return nil, fmt.Errorf("HKDF not available")
	}

	ikmPtr := em.alloc(uint32(max(len(ikm), 1)))
	saltLen := len(salt)
	if saltLen == 0 {
		saltLen = 1
	}
	saltPtr := em.alloc(uint32(saltLen))
	infoPtr := em.alloc(uint32(max(len(info), 1)))
	outPtr := em.alloc(uint32(length))

	defer func() {
		em.dealloc(ikmPtr)
		em.dealloc(saltPtr)
		em.dealloc(infoPtr)
		em.dealloc(outPtr)
	}()

	if len(ikm) > 0 {
		em.memory().Write(ikmPtr, ikm)
	}
	if len(salt) > 0 {
		em.memory().Write(saltPtr, salt)
	}
	if len(info) > 0 {
		em.memory().Write(infoPtr, info)
	}

	actualSaltLen := uint32(len(salt))
	_, err := em.hkdf.Call(em.ctx,
		uint64(ikmPtr), uint64(len(ikm)),
		uint64(saltPtr), uint64(actualSaltLen),
		uint64(infoPtr), uint64(len(info)),
		uint64(outPtr), uint64(length))
	if err != nil {
		return nil, err
	}

	out, ok := em.memory().Read(outPtr, uint32(length))
	if !ok {
		return nil, fmt.Errorf("failed to read HKDF output")
	}
	result := make([]byte, length)
	copy(result, out)
	return result, nil
}

// X25519GenerateKeypair generates an X25519 key pair
func (em *EncryptionModule) X25519GenerateKeypair() (privateKey, publicKey []byte, err error) {
	if em.x25519GenerateKeypair == nil {
		return nil, nil, fmt.Errorf("X25519 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(32)

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
	}()

	res, err := em.x25519GenerateKeypair.Call(em.ctx, uint64(privPtr), uint64(pubPtr))
	if err != nil {
		return nil, nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, nil, fmt.Errorf("X25519 keypair generation failed")
	}

	priv, _ := em.memory().Read(privPtr, 32)
	pub, _ := em.memory().Read(pubPtr, 32)

	privateKey = make([]byte, 32)
	publicKey = make([]byte, 32)
	copy(privateKey, priv)
	copy(publicKey, pub)
	return privateKey, publicKey, nil
}

// X25519SharedSecret computes ECDH shared secret
func (em *EncryptionModule) X25519SharedSecret(privateKey, publicKey []byte) ([]byte, error) {
	if em.x25519SharedSecret == nil {
		return nil, fmt.Errorf("X25519 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(32)
	secretPtr := em.alloc(32)

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
		em.dealloc(secretPtr)
	}()

	em.memory().Write(privPtr, privateKey)
	em.memory().Write(pubPtr, publicKey)

	res, err := em.x25519SharedSecret.Call(em.ctx, uint64(privPtr), uint64(pubPtr), uint64(secretPtr))
	if err != nil {
		return nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, fmt.Errorf("X25519 ECDH failed")
	}

	secret, _ := em.memory().Read(secretPtr, 32)
	result := make([]byte, 32)
	copy(result, secret)
	return result, nil
}

// Secp256k1GenerateKeypair generates a secp256k1 key pair
func (em *EncryptionModule) Secp256k1GenerateKeypair() (privateKey, publicKey []byte, err error) {
	if em.secp256k1GenerateKeypair == nil {
		return nil, nil, fmt.Errorf("secp256k1 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(33) // compressed public key

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
	}()

	res, err := em.secp256k1GenerateKeypair.Call(em.ctx, uint64(privPtr), uint64(pubPtr))
	if err != nil {
		return nil, nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, nil, fmt.Errorf("secp256k1 keypair generation failed")
	}

	priv, _ := em.memory().Read(privPtr, 32)
	pub, _ := em.memory().Read(pubPtr, 33)

	privateKey = make([]byte, 32)
	publicKey = make([]byte, 33)
	copy(privateKey, priv)
	copy(publicKey, pub)
	return privateKey, publicKey, nil
}

// Secp256k1SharedSecret computes ECDH shared secret
func (em *EncryptionModule) Secp256k1SharedSecret(privateKey, publicKey []byte) ([]byte, error) {
	if em.secp256k1SharedSecret == nil {
		return nil, fmt.Errorf("secp256k1 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(uint32(len(publicKey)))
	secretPtr := em.alloc(32)

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
		em.dealloc(secretPtr)
	}()

	em.memory().Write(privPtr, privateKey)
	em.memory().Write(pubPtr, publicKey)

	res, err := em.secp256k1SharedSecret.Call(em.ctx, uint64(privPtr), uint64(pubPtr), uint64(len(publicKey)), uint64(secretPtr))
	if err != nil {
		return nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, fmt.Errorf("secp256k1 ECDH failed")
	}

	secret, _ := em.memory().Read(secretPtr, 32)
	result := make([]byte, 32)
	copy(result, secret)
	return result, nil
}

// P256GenerateKeypair generates a P-256 key pair
func (em *EncryptionModule) P256GenerateKeypair() (privateKey, publicKey []byte, err error) {
	if em.p256GenerateKeypair == nil {
		return nil, nil, fmt.Errorf("P-256 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(33) // compressed public key

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
	}()

	res, err := em.p256GenerateKeypair.Call(em.ctx, uint64(privPtr), uint64(pubPtr))
	if err != nil {
		return nil, nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, nil, fmt.Errorf("P-256 keypair generation failed")
	}

	priv, _ := em.memory().Read(privPtr, 32)
	pub, _ := em.memory().Read(pubPtr, 33)

	privateKey = make([]byte, 32)
	publicKey = make([]byte, 33)
	copy(privateKey, priv)
	copy(publicKey, pub)
	return privateKey, publicKey, nil
}

// P256SharedSecret computes ECDH shared secret
func (em *EncryptionModule) P256SharedSecret(privateKey, publicKey []byte) ([]byte, error) {
	if em.p256SharedSecret == nil {
		return nil, fmt.Errorf("P-256 not available")
	}

	privPtr := em.alloc(32)
	pubPtr := em.alloc(uint32(len(publicKey)))
	secretPtr := em.alloc(32)

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
		em.dealloc(secretPtr)
	}()

	em.memory().Write(privPtr, privateKey)
	em.memory().Write(pubPtr, publicKey)

	res, err := em.p256SharedSecret.Call(em.ctx, uint64(privPtr), uint64(pubPtr), uint64(len(publicKey)), uint64(secretPtr))
	if err != nil {
		return nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, fmt.Errorf("P-256 ECDH failed")
	}

	secret, _ := em.memory().Read(secretPtr, 32)
	result := make([]byte, 32)
	copy(result, secret)
	return result, nil
}

// Ed25519GenerateKeypair generates an Ed25519 keypair
func (em *EncryptionModule) Ed25519GenerateKeypair() (privateKey, publicKey []byte, err error) {
	if em.ed25519GenerateKeypair == nil {
		return nil, nil, fmt.Errorf("Ed25519 not available")
	}

	privPtr := em.alloc(64) // Ed25519 private key is 64 bytes
	pubPtr := em.alloc(32)

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(pubPtr)
	}()

	res, err := em.ed25519GenerateKeypair.Call(em.ctx, uint64(privPtr), uint64(pubPtr))
	if err != nil {
		return nil, nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, nil, fmt.Errorf("Ed25519 keypair generation failed")
	}

	priv, _ := em.memory().Read(privPtr, 64)
	pub, _ := em.memory().Read(pubPtr, 32)

	privateKey = make([]byte, 64)
	publicKey = make([]byte, 32)
	copy(privateKey, priv)
	copy(publicKey, pub)
	return privateKey, publicKey, nil
}

// Ed25519Sign signs data using Ed25519
func (em *EncryptionModule) Ed25519Sign(privateKey, data []byte) ([]byte, error) {
	if em.ed25519Sign == nil {
		return nil, fmt.Errorf("Ed25519 not available")
	}

	privPtr := em.alloc(64)
	dataPtr := em.alloc(uint32(len(data)))
	sigPtr := em.alloc(64) // Ed25519 signature is 64 bytes

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(dataPtr)
		em.dealloc(sigPtr)
	}()

	em.memory().Write(privPtr, privateKey)
	em.memory().Write(dataPtr, data)

	res, err := em.ed25519Sign.Call(em.ctx, uint64(privPtr), uint64(dataPtr), uint64(len(data)), uint64(sigPtr))
	if err != nil {
		return nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, fmt.Errorf("Ed25519 signing failed")
	}

	sig, _ := em.memory().Read(sigPtr, 64)
	result := make([]byte, 64)
	copy(result, sig)
	return result, nil
}

// Ed25519Verify verifies an Ed25519 signature
func (em *EncryptionModule) Ed25519Verify(publicKey, data, signature []byte) (bool, error) {
	if em.ed25519Verify == nil {
		return false, fmt.Errorf("Ed25519 not available")
	}

	pubPtr := em.alloc(32)
	dataPtr := em.alloc(uint32(len(data)))
	sigPtr := em.alloc(64)

	defer func() {
		em.dealloc(pubPtr)
		em.dealloc(dataPtr)
		em.dealloc(sigPtr)
	}()

	em.memory().Write(pubPtr, publicKey)
	em.memory().Write(dataPtr, data)
	em.memory().Write(sigPtr, signature)

	res, err := em.ed25519Verify.Call(em.ctx, uint64(pubPtr), uint64(dataPtr), uint64(len(data)), uint64(sigPtr))
	if err != nil {
		return false, err
	}
	return len(res) > 0 && res[0] == 0, nil
}

// Secp256k1Sign signs data using secp256k1
func (em *EncryptionModule) Secp256k1Sign(privateKey, data []byte) ([]byte, error) {
	if em.secp256k1Sign == nil {
		return nil, fmt.Errorf("secp256k1 signing not available")
	}

	privPtr := em.alloc(32)
	dataPtr := em.alloc(uint32(len(data)))
	sigPtr := em.alloc(72) // DER signature can be up to 72 bytes
	sigSizePtr := em.alloc(4)

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(dataPtr)
		em.dealloc(sigPtr)
		em.dealloc(sigSizePtr)
	}()

	em.memory().Write(privPtr, privateKey)
	em.memory().Write(dataPtr, data)

	res, err := em.secp256k1Sign.Call(em.ctx, uint64(privPtr), uint64(dataPtr), uint64(len(data)), uint64(sigPtr), uint64(sigSizePtr))
	if err != nil {
		return nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, fmt.Errorf("secp256k1 signing failed")
	}

	sigSizeBytes, _ := em.memory().Read(sigSizePtr, 4)
	sigSize := uint32(sigSizeBytes[0]) | uint32(sigSizeBytes[1])<<8 | uint32(sigSizeBytes[2])<<16 | uint32(sigSizeBytes[3])<<24

	sig, _ := em.memory().Read(sigPtr, sigSize)
	result := make([]byte, sigSize)
	copy(result, sig)
	return result, nil
}

// Secp256k1Verify verifies a secp256k1 signature
func (em *EncryptionModule) Secp256k1Verify(publicKey, data, signature []byte) (bool, error) {
	if em.secp256k1Verify == nil {
		return false, fmt.Errorf("secp256k1 verification not available")
	}

	pubPtr := em.alloc(uint32(len(publicKey)))
	dataPtr := em.alloc(uint32(len(data)))
	sigPtr := em.alloc(uint32(len(signature)))

	defer func() {
		em.dealloc(pubPtr)
		em.dealloc(dataPtr)
		em.dealloc(sigPtr)
	}()

	em.memory().Write(pubPtr, publicKey)
	em.memory().Write(dataPtr, data)
	em.memory().Write(sigPtr, signature)

	res, err := em.secp256k1Verify.Call(em.ctx, uint64(pubPtr), uint64(len(publicKey)), uint64(dataPtr), uint64(len(data)), uint64(sigPtr), uint64(len(signature)))
	if err != nil {
		return false, err
	}
	return len(res) > 0 && res[0] == 0, nil
}

// P256Sign signs data using P-256
func (em *EncryptionModule) P256Sign(privateKey, data []byte) ([]byte, error) {
	if em.p256Sign == nil {
		return nil, fmt.Errorf("P-256 signing not available")
	}

	privPtr := em.alloc(32)
	dataPtr := em.alloc(uint32(len(data)))
	sigPtr := em.alloc(72) // DER signature can be up to 72 bytes
	sigSizePtr := em.alloc(4)

	defer func() {
		em.dealloc(privPtr)
		em.dealloc(dataPtr)
		em.dealloc(sigPtr)
		em.dealloc(sigSizePtr)
	}()

	em.memory().Write(privPtr, privateKey)
	em.memory().Write(dataPtr, data)

	res, err := em.p256Sign.Call(em.ctx, uint64(privPtr), uint64(dataPtr), uint64(len(data)), uint64(sigPtr), uint64(sigSizePtr))
	if err != nil {
		return nil, err
	}
	if len(res) > 0 && res[0] != 0 {
		return nil, fmt.Errorf("P-256 signing failed")
	}

	sigSizeBytes, _ := em.memory().Read(sigSizePtr, 4)
	sigSize := uint32(sigSizeBytes[0]) | uint32(sigSizeBytes[1])<<8 | uint32(sigSizeBytes[2])<<16 | uint32(sigSizeBytes[3])<<24

	sig, _ := em.memory().Read(sigPtr, sigSize)
	result := make([]byte, sigSize)
	copy(result, sig)
	return result, nil
}

// P256Verify verifies a P-256 signature
func (em *EncryptionModule) P256Verify(publicKey, data, signature []byte) (bool, error) {
	if em.p256Verify == nil {
		return false, fmt.Errorf("P-256 verification not available")
	}

	pubPtr := em.alloc(uint32(len(publicKey)))
	dataPtr := em.alloc(uint32(len(data)))
	sigPtr := em.alloc(uint32(len(signature)))

	defer func() {
		em.dealloc(pubPtr)
		em.dealloc(dataPtr)
		em.dealloc(sigPtr)
	}()

	em.memory().Write(pubPtr, publicKey)
	em.memory().Write(dataPtr, data)
	em.memory().Write(sigPtr, signature)

	res, err := em.p256Verify.Call(em.ctx, uint64(pubPtr), uint64(len(publicKey)), uint64(dataPtr), uint64(len(data)), uint64(sigPtr), uint64(len(signature)))
	if err != nil {
		return false, err
	}
	return len(res) > 0 && res[0] == 0, nil
}

func main() {
	fmt.Println(string(make([]byte, 60, 60)))
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()
	fmt.Println("FlatBuffers Cross-Language Encryption E2E Tests - Go")
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()
	fmt.Println()
	fmt.Println("Mode: TRANSPARENT ENCRYPTION")
	fmt.Println("Schema: tests/monster_test.fbs (upstream)")
	fmt.Println()

	ctx := context.Background()

	// Load WASM module
	wasmPath := WasmPath
	wasmBytes, err := os.ReadFile(wasmPath)
	if err != nil {
		fmt.Printf("Failed to load WASM module: %v\n", err)
		fmt.Println("Build the WASM module first:")
		fmt.Println("  cmake --build build/wasm --target flatc_wasm_wasi")
		os.Exit(1)
	}

	em, err := NewEncryptionModule(ctx, wasmBytes)
	if err != nil {
		fmt.Printf("Failed to initialize encryption module: %v\n", err)
		os.Exit(1)
	}
	defer em.Close()

	fmt.Printf("Encryption module version: %s\n", em.Version())
	fmt.Printf("Crypto++ available: %v\n", em.HasCryptopp())
	fmt.Println()

	// Load encryption keys
	keysPath := filepath.Join("..", "..", "vectors", "encryption_keys.json")
	keysData, err := os.ReadFile(keysPath)
	if err != nil {
		fmt.Printf("Failed to load encryption keys: %v\n", err)
		fmt.Println("Run the vector generator first: node generate_vectors.mjs")
		os.Exit(1)
	}

	var encryptionKeys EncryptionKeys
	if err := json.Unmarshal(keysData, &encryptionKeys); err != nil {
		fmt.Printf("Failed to parse encryption keys: %v\n", err)
		os.Exit(1)
	}

	results := []bool{}

	// Test 1: SHA-256
	fmt.Println("Test 1: SHA-256 Hash")
	fmt.Println("----------------------------------------")
	{
		result := &TestResult{Name: "SHA-256"}

		hash, err := em.SHA256([]byte("hello"))
		if err != nil {
			result.Fail("SHA-256 computation", err)
		} else {
			hashHex := hex.EncodeToString(hash)
			expected := "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
			if hashHex == expected {
				result.Pass("SHA-256('hello') matches expected")
			} else {
				result.Fail(fmt.Sprintf("SHA-256 mismatch: got %s", hashHex), nil)
			}
		}

		results = append(results, result.Summary())
	}

	// Test 2: Encryption/Decryption with each chain key
	fmt.Println("\nTest 2: Encryption/Decryption (per-chain keys)")
	fmt.Println("----------------------------------------")

	for chain, keys := range encryptionKeys {
		result := &TestResult{Name: fmt.Sprintf("Encryption with %s", chain)}

		key, err := hex.DecodeString(keys.KeyHex)
		if err != nil {
			result.Fail("Decode key", err)
			results = append(results, result.Summary())
			continue
		}

		iv, err := hex.DecodeString(keys.IVHex)
		if err != nil {
			result.Fail("Decode IV", err)
			results = append(results, result.Summary())
			continue
		}

		// Test data
		plaintext := []byte("Hello, FlatBuffers encryption test from Go!")
		originalHex := hex.EncodeToString(plaintext)

		// Encrypt
		data := make([]byte, len(plaintext))
		copy(data, plaintext)

		if err := em.EncryptBytes(key, iv, data); err != nil {
			result.Fail("Encryption", err)
			results = append(results, result.Summary())
			continue
		}

		encryptedHex := hex.EncodeToString(data)
		if encryptedHex != originalHex {
			result.Pass("Data encrypted (changed from original)")
		} else {
			result.Fail("Data unchanged after encryption", nil)
		}

		// Decrypt
		if err := em.DecryptBytes(key, iv, data); err != nil {
			result.Fail("Decryption", err)
			results = append(results, result.Summary())
			continue
		}

		decryptedHex := hex.EncodeToString(data)
		if decryptedHex == originalHex {
			result.Pass("Decryption restored original data")
		} else {
			result.Fail("Decryption mismatch", nil)
		}

		if string(data) == string(plaintext) {
			result.Pass("Plaintext matches after round-trip")
		} else {
			result.Fail("Plaintext mismatch after round-trip", nil)
		}

		results = append(results, result.Summary())
	}

	// Test 3: Read Node.js generated binaries and verify decryption
	fmt.Println("\nTest 3: Cross-Language Binary Verification")
	fmt.Println("----------------------------------------")
	{
		result := &TestResult{Name: "Cross-Language Verification"}

		binaryDir := filepath.Join("..", "..", "vectors", "binary")
		unencryptedPath := filepath.Join(binaryDir, "monster_unencrypted.bin")

		if _, err := os.Stat(unencryptedPath); os.IsNotExist(err) {
			result.Fail("Node.js binaries not found. Run Node.js test first.", nil)
		} else {
			unencryptedData, err := os.ReadFile(unencryptedPath)
			if err != nil {
				result.Fail("Read unencrypted binary", err)
			} else {
				result.Pass(fmt.Sprintf("Read unencrypted binary: %d bytes", len(unencryptedData)))

				// Verify FlatBuffer file identifier "MONS" at offset 4-7
				if len(unencryptedData) >= 8 {
					fileIdent := string(unencryptedData[4:8])
					if fileIdent == "MONS" {
						result.Pass("FlatBuffer file identifier: MONS")
					} else {
						result.Fail(fmt.Sprintf("Unexpected file identifier: %s", fileIdent), nil)
					}
				}

				// Decrypt each chain's encrypted binary and compare
				for chain, keys := range encryptionKeys {
					encryptedPath := filepath.Join(binaryDir, fmt.Sprintf("monster_encrypted_%s.bin", chain))
					encryptedData, err := os.ReadFile(encryptedPath)
					if err != nil {
						// Skip if file doesn't exist
						continue
					}

					key, _ := hex.DecodeString(keys.KeyHex)
					iv, _ := hex.DecodeString(keys.IVHex)

					// Decrypt
					decrypted := make([]byte, len(encryptedData))
					copy(decrypted, encryptedData)
					if err := em.DecryptBytes(key, iv, decrypted); err != nil {
						result.Fail(fmt.Sprintf("Decrypt %s binary", chain), err)
						continue
					}

					// Verify decrypted matches unencrypted
					if hex.EncodeToString(decrypted) == hex.EncodeToString(unencryptedData) {
						result.Pass(fmt.Sprintf("Decrypted %s matches original", chain))
					} else {
						result.Fail(fmt.Sprintf("Decrypted %s mismatch", chain), nil)
					}

					// Verify file identifier survived decryption
					if len(decrypted) >= 8 && string(decrypted[4:8]) == "MONS" {
						result.Pass(fmt.Sprintf("Decrypted %s: MONS identifier intact", chain))
					}
				}
			}
		}

		results = append(results, result.Summary())
	}

	// Test 4: ECDH Key Exchange Verification
	// Verify we can decrypt Node.js ECDH-encrypted binaries using the header data
	fmt.Println("\nTest 4: ECDH Key Exchange Verification")
	fmt.Println("----------------------------------------")

	ecdhCurves := []struct {
		name        string
		generate    func() ([]byte, []byte, error)
		sharedFunc  func([]byte, []byte) ([]byte, error)
		pubKeySize  int
	}{
		{"x25519", em.X25519GenerateKeypair, em.X25519SharedSecret, 32},
		{"secp256k1", em.Secp256k1GenerateKeypair, em.Secp256k1SharedSecret, 33},
		{"p256", em.P256GenerateKeypair, em.P256SharedSecret, 33},
	}

	for _, curve := range ecdhCurves {
		result := &TestResult{Name: fmt.Sprintf("ECDH %s", curve.name)}

		// Read the ECDH header from Node.js test
		headerPath := filepath.Join("..", "..", "vectors", "binary", fmt.Sprintf("monster_ecdh_%s_header.json", curve.name))
		headerData, err := os.ReadFile(headerPath)
		if err != nil {
			result.Fail(fmt.Sprintf("Read %s header", curve.name), err)
			results = append(results, result.Summary())
			continue
		}

		var header ECDHHeader
		if err := json.Unmarshal(headerData, &header); err != nil {
			result.Fail("Parse header", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass(fmt.Sprintf("Read %s header", curve.name))

		// Read encrypted binary
		encryptedPath := filepath.Join("..", "..", "vectors", "binary", fmt.Sprintf("monster_ecdh_%s.bin", curve.name))
		encryptedData, err := os.ReadFile(encryptedPath)
		if err != nil {
			result.Fail("Read encrypted binary", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass(fmt.Sprintf("Read encrypted binary: %d bytes", len(encryptedData)))

		// Use the session key from the header (for verification)
		sessionKey, err := hex.DecodeString(header.SessionKey)
		if err != nil {
			result.Fail("Decode session key", err)
			results = append(results, result.Summary())
			continue
		}

		sessionIV, err := hex.DecodeString(header.SessionIV)
		if err != nil {
			result.Fail("Decode session IV", err)
			results = append(results, result.Summary())
			continue
		}

		// Decrypt using the session key
		decrypted := make([]byte, len(encryptedData))
		copy(decrypted, encryptedData)
		if err := em.DecryptBytes(sessionKey, sessionIV, decrypted); err != nil {
			result.Fail("Decrypt with session key", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass("Decrypted with session key")

		// Verify FlatBuffer file identifier
		if len(decrypted) >= 8 && string(decrypted[4:8]) == "MONS" {
			result.Pass("FlatBuffer identifier MONS intact")
		} else {
			result.Fail("FlatBuffer identifier corrupted", nil)
		}

		// Test ECDH keypair generation
		privKey, pubKey, err := curve.generate()
		if err != nil {
			result.Fail("Generate keypair", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass(fmt.Sprintf("Generated %s keypair (priv: %d, pub: %d)", curve.name, len(privKey), len(pubKey)))

		// Test ECDH shared secret (with self)
		shared, err := curve.sharedFunc(privKey, pubKey)
		if err != nil {
			result.Fail("Compute shared secret", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass(fmt.Sprintf("Computed shared secret: %d bytes", len(shared)))

		// Test HKDF key derivation
		context := fmt.Sprintf("flatbuffers-%s-encryption", curve.name)
		keyMaterial, err := em.HKDF(shared, nil, []byte(context), 48)
		if err != nil {
			result.Fail("HKDF derivation", err)
			results = append(results, result.Summary())
			continue
		}
		result.Pass(fmt.Sprintf("HKDF derived %d bytes", len(keyMaterial)))

		results = append(results, result.Summary())
	}

	// Test 5: Runtime Code Generation via native flatc
	fmt.Println("\nTest 5: Runtime Code Generation")
	fmt.Println("----------------------------------------")
	{
		result := &TestResult{Name: "Code Generation"}

		// Try to find native flatc binary (prefer built version over system)
		// Get the directory containing this source file for relative paths
		runnerDir, _ := os.Getwd()
		flatcPaths := []string{
			filepath.Join(runnerDir, "../../../../../build/flatc"),
			filepath.Join(runnerDir, "../../../../../flatc"),
		}

		var flatcPath string
		for _, p := range flatcPaths {
			if _, err := os.Stat(p); err == nil {
				flatcPath = p
				break
			}
		}

		// Only fall back to PATH if built flatc not found
		if flatcPath == "" {
			if path, err := exec.LookPath("flatc"); err == nil {
				flatcPath = path
			}
		}

		if flatcPath != "" {
			result.Pass(fmt.Sprintf("Found flatc: %s", flatcPath))

			// Get flatc version
			cmd := exec.Command(flatcPath, "--version")
			versionOut, err := cmd.Output()
			if err == nil {
				result.Pass(fmt.Sprintf("flatc version: %s", strings.TrimSpace(string(versionOut))))
			}

			// Generate Go code from schema
			schemaPath := filepath.Join("..", "..", "schemas", "message.fbs")
			tempDir, err := os.MkdirTemp("", "flatc-gen-*")
			if err != nil {
				result.Fail("Create temp dir", err)
			} else {
				defer os.RemoveAll(tempDir)

				cmd = exec.Command(flatcPath, "--go", "-o", tempDir, schemaPath)
				if err := cmd.Run(); err != nil {
					result.Fail("Generate Go code", err)
				} else {
					result.Pass("Generated Go code from schema")

					// List generated files
					err := filepath.Walk(tempDir, func(path string, info os.FileInfo, err error) error {
						if err != nil {
							return err
						}
						if !info.IsDir() {
							relPath, _ := filepath.Rel(tempDir, path)
							result.Pass(fmt.Sprintf("Generated: %s (%d bytes)", relPath, info.Size()))
						}
						return nil
					})
					if err != nil {
						result.Fail("List generated files", err)
					}
				}
			}
		} else {
			result.Pass("flatc not found - using pre-generated code (this is OK)")
			// Verify pre-generated code exists
			pregenPath := filepath.Join("..", "..", "generated", "go", "E2E", "Crypto")
			if _, err := os.Stat(pregenPath); err == nil {
				files, _ := os.ReadDir(pregenPath)
				result.Pass(fmt.Sprintf("Pre-generated Go code: %d files in generated/go/E2E/Crypto/", len(files)))
			}
		}

		results = append(results, result.Summary())
	}

	// Test 6: SecureMessage Schema E2E
	fmt.Println("\nTest 6: SecureMessage Schema E2E")
	for i := 0; i < 40; i++ {
		fmt.Print("-")
	}
	fmt.Println()
	{
		result := &TestResult{Name: "SecureMessage E2E"}
		vectorsDir := filepath.Join("..", "..", "vectors")
		binaryDir := filepath.Join(vectorsDir, "binary")

		// Load ECDH message keys
		ecdhMsgKeysPath := filepath.Join(vectorsDir, "ecdh_message_keys.json")
		ecdhMsgKeysData, err := os.ReadFile(ecdhMsgKeysPath)
		if err != nil {
			result.Fail("Load ecdh_message_keys.json (run create_messages.mjs first)", err)
		} else {
			var ecdhMsgKeys map[string]struct {
				Alice struct {
					Private string `json:"private"`
					Public  string `json:"public"`
				} `json:"alice"`
				Bob struct {
					Private string `json:"private"`
					Public  string `json:"public"`
				} `json:"bob"`
			}
			if err := json.Unmarshal(ecdhMsgKeysData, &ecdhMsgKeys); err != nil {
				result.Fail("Parse ecdh_message_keys.json", err)
			} else {
				// Test each curve
				curves := []struct {
					name       string
					sharedFunc func(privKey, pubKey []byte) ([]byte, error)
				}{
					{"x25519", em.X25519SharedSecret},
					{"secp256k1", em.Secp256k1SharedSecret},
					{"p256", em.P256SharedSecret},
				}

				for _, curve := range curves {
					// Read encrypted SecureMessage
					encPath := filepath.Join(binaryDir, fmt.Sprintf("secure_message_simple_%s.bin", curve.name))
					encData, err := os.ReadFile(encPath)
					if err != nil {
						result.Fail(fmt.Sprintf("Read secure_message_%s.bin", curve.name), err)
						continue
					}

					keys := ecdhMsgKeys[curve.name]
					bobPriv, _ := hex.DecodeString(keys.Bob.Private)
					alicePub, _ := hex.DecodeString(keys.Alice.Public)

					// Compute shared secret
					sharedSecret, err := curve.sharedFunc(bobPriv, alicePub)
					if err != nil {
						result.Fail(fmt.Sprintf("ECDH shared secret %s", curve.name), err)
						continue
					}

					// Derive session key + IV
					keyMaterial, err := em.HKDF(sharedSecret, nil, []byte("E2E-Crypto-Test"), 48)
					if err != nil {
						result.Fail(fmt.Sprintf("HKDF %s", curve.name), err)
						continue
					}

					sessionKey := keyMaterial[:32]
					iv := keyMaterial[32:48]

					// Decrypt
					decrypted := make([]byte, len(encData))
					copy(decrypted, encData)
					if err := em.DecryptBytes(sessionKey, iv, decrypted); err != nil {
						result.Fail(fmt.Sprintf("Decrypt %s", curve.name), err)
						continue
					}

					// Verify FlatBuffer magic (SECM)
					if len(decrypted) >= 8 {
						// FlatBuffer identifier is at offset 4-7
						identifier := string(decrypted[4:8])
						if identifier == "SECM" {
							result.Pass(fmt.Sprintf("SecureMessage %s: decrypted, identifier=SECM", curve.name))
						} else {
							result.Fail(fmt.Sprintf("SecureMessage %s: wrong identifier '%s'", curve.name, identifier), nil)
						}
					} else {
						result.Fail(fmt.Sprintf("SecureMessage %s: too short (%d bytes)", curve.name, len(decrypted)), nil)
					}
				}
			}
		}

		results = append(results, result.Summary())
	}

	// Test 7: Digital Signatures (Ed25519, secp256k1, P-256)
	fmt.Println("\nTest 7: Digital Signatures")
	fmt.Println("----------------------------------------")
	{
		result := &TestResult{Name: "Digital Signatures"}
		testMessage := []byte("Hello, FlatBuffers! This is a test message for signing.")

		// Test Ed25519
		privKey, pubKey, err := em.Ed25519GenerateKeypair()
		if err != nil {
			result.Fail("Ed25519 keypair generation", err)
		} else {
			result.Pass(fmt.Sprintf("Ed25519 keypair generated (priv: %d, pub: %d bytes)", len(privKey), len(pubKey)))

			sig, err := em.Ed25519Sign(privKey, testMessage)
			if err != nil {
				result.Fail("Ed25519 sign", err)
			} else {
				result.Pass(fmt.Sprintf("Ed25519 signature: %d bytes", len(sig)))

				valid, err := em.Ed25519Verify(pubKey, testMessage, sig)
				if err != nil {
					result.Fail("Ed25519 verify", err)
				} else if valid {
					result.Pass("Ed25519 signature verified")
				} else {
					result.Fail("Ed25519 signature verification failed", nil)
				}

				// Verify wrong message fails
				wrongMessage := []byte("Wrong message")
				valid, _ = em.Ed25519Verify(pubKey, wrongMessage, sig)
				if !valid {
					result.Pass("Ed25519 rejects wrong message")
				} else {
					result.Fail("Ed25519 accepted wrong message", nil)
				}
			}
		}

		// Test secp256k1 signing
		secpPriv, secpPub, err := em.Secp256k1GenerateKeypair()
		if err != nil {
			result.Fail("secp256k1 keypair generation", err)
		} else {
			result.Pass(fmt.Sprintf("secp256k1 keypair generated (priv: %d, pub: %d bytes)", len(secpPriv), len(secpPub)))

			sig, err := em.Secp256k1Sign(secpPriv, testMessage)
			if err != nil {
				result.Fail("secp256k1 sign", err)
			} else {
				result.Pass(fmt.Sprintf("secp256k1 signature: %d bytes (DER)", len(sig)))

				valid, err := em.Secp256k1Verify(secpPub, testMessage, sig)
				if err != nil {
					result.Fail("secp256k1 verify", err)
				} else if valid {
					result.Pass("secp256k1 signature verified")
				} else {
					result.Fail("secp256k1 signature verification failed", nil)
				}

				// Verify wrong message fails
				wrongMessage := []byte("Wrong message")
				valid, _ = em.Secp256k1Verify(secpPub, wrongMessage, sig)
				if !valid {
					result.Pass("secp256k1 rejects wrong message")
				} else {
					result.Fail("secp256k1 accepted wrong message", nil)
				}
			}
		}

		// Test P-256 signing
		p256Priv, p256Pub, err := em.P256GenerateKeypair()
		if err != nil {
			result.Fail("P-256 keypair generation", err)
		} else {
			result.Pass(fmt.Sprintf("P-256 keypair generated (priv: %d, pub: %d bytes)", len(p256Priv), len(p256Pub)))

			sig, err := em.P256Sign(p256Priv, testMessage)
			if err != nil {
				result.Fail("P-256 sign", err)
			} else {
				result.Pass(fmt.Sprintf("P-256 signature: %d bytes (DER)", len(sig)))

				valid, err := em.P256Verify(p256Pub, testMessage, sig)
				if err != nil {
					result.Fail("P-256 verify", err)
				} else if valid {
					result.Pass("P-256 signature verified")
				} else {
					result.Fail("P-256 signature verification failed", nil)
				}

				// Verify wrong message fails
				wrongMessage := []byte("Wrong message")
				valid, _ = em.P256Verify(p256Pub, wrongMessage, sig)
				if !valid {
					result.Pass("P-256 rejects wrong message")
				} else {
					result.Fail("P-256 accepted wrong message", nil)
				}
			}
		}

		results = append(results, result.Summary())
	}

	// Test 8: FlatBuffer Creation
	fmt.Println("\nTest 8: FlatBuffer Creation")
	fmt.Println("----------------------------------------")
	{
		result := &TestResult{Name: "FlatBuffer Creation"}

		// Create a SecureMessage using the FlatBuffers builder
		builder := flatbuffers.NewBuilder(1024)

		// Build the Payload first (inner table)
		payloadMsg := builder.CreateString("Hello from Go!")
		payloadData := []byte{0x01, 0x02, 0x03, 0x04, 0x05}
		Crypto.PayloadStartDataVector(builder, len(payloadData))
		for i := len(payloadData) - 1; i >= 0; i-- {
			builder.PrependByte(payloadData[i])
		}
		payloadDataVec := builder.EndVector(len(payloadData))

		Crypto.PayloadStart(builder)
		Crypto.PayloadAddMessage(builder, payloadMsg)
		Crypto.PayloadAddValue(builder, 42)
		Crypto.PayloadAddData(builder, payloadDataVec)
		Crypto.PayloadAddIsEncrypted(builder, false)
		payload := Crypto.PayloadEnd(builder)

		// Build the SecureMessage
		msgId := builder.CreateString("go-msg-001")
		sender := builder.CreateString("go-alice")
		recipient := builder.CreateString("go-bob")

		Crypto.SecureMessageStart(builder)
		Crypto.SecureMessageAddId(builder, msgId)
		Crypto.SecureMessageAddSender(builder, sender)
		Crypto.SecureMessageAddRecipient(builder, recipient)
		Crypto.SecureMessageAddPayload(builder, payload)
		Crypto.SecureMessageAddTimestamp(builder, 1704067200)
		secureMsg := Crypto.SecureMessageEnd(builder)

		Crypto.FinishSecureMessageBuffer(builder, secureMsg)

		buf := builder.FinishedBytes()
		result.Pass(fmt.Sprintf("Created SecureMessage binary: %d bytes", len(buf)))

		// Verify the buffer has the correct file identifier
		if Crypto.SecureMessageBufferHasIdentifier(buf) {
			result.Pass("Buffer has correct SECM identifier")
		} else {
			result.Fail("Buffer missing SECM identifier", nil)
		}

		// Read it back and verify contents
		msg := Crypto.GetRootAsSecureMessage(buf, 0)
		if string(msg.Id()) == "go-msg-001" {
			result.Pass("Read back id: go-msg-001")
		} else {
			result.Fail(fmt.Sprintf("Wrong id: %s", string(msg.Id())), nil)
		}

		if string(msg.Sender()) == "go-alice" {
			result.Pass("Read back sender: go-alice")
		} else {
			result.Fail(fmt.Sprintf("Wrong sender: %s", string(msg.Sender())), nil)
		}

		if string(msg.Recipient()) == "go-bob" {
			result.Pass("Read back recipient: go-bob")
		} else {
			result.Fail(fmt.Sprintf("Wrong recipient: %s", string(msg.Recipient())), nil)
		}

		if msg.Timestamp() == 1704067200 {
			result.Pass("Read back timestamp: 1704067200")
		} else {
			result.Fail(fmt.Sprintf("Wrong timestamp: %d", msg.Timestamp()), nil)
		}

		payloadObj := new(Crypto.Payload)
		if msg.Payload(payloadObj) != nil {
			if string(payloadObj.Message()) == "Hello from Go!" {
				result.Pass("Read back payload message: Hello from Go!")
			} else {
				result.Fail(fmt.Sprintf("Wrong payload message: %s", string(payloadObj.Message())), nil)
			}

			if payloadObj.Value() == 42 {
				result.Pass("Read back payload value: 42")
			} else {
				result.Fail(fmt.Sprintf("Wrong payload value: %d", payloadObj.Value()), nil)
			}

			readData := payloadObj.DataBytes()
			if bytes.Equal(readData, payloadData) {
				result.Pass(fmt.Sprintf("Read back payload data: %d bytes", len(readData)))
			} else {
				result.Fail(fmt.Sprintf("Wrong payload data: %v", readData), nil)
			}
		} else {
			result.Fail("Failed to read payload", nil)
		}

		// Test encrypt-decrypt round trip with Go-created FlatBuffer
		if encryptionKeys != nil {
			suiKey := encryptionKeys["sui"]
			key, _ := hex.DecodeString(suiKey.KeyHex)
			iv, _ := hex.DecodeString(suiKey.IVHex)

			// Make a copy to encrypt
			encrypted := make([]byte, len(buf))
			copy(encrypted, buf)

			if err := em.EncryptBytes(encrypted, key, iv); err != nil {
				result.Fail("Encrypt Go FlatBuffer", err)
			} else {
				result.Pass("Encrypted Go-created FlatBuffer")

				// Decrypt
				if err := em.DecryptBytes(encrypted, key, iv); err != nil {
					result.Fail("Decrypt Go FlatBuffer", err)
				} else {
					result.Pass("Decrypted Go-created FlatBuffer")

					// Verify decrypted data matches original
					if bytes.Equal(encrypted, buf) {
						result.Pass("Decrypt round-trip verified")
					} else {
						result.Fail("Decrypted data doesn't match original", nil)
					}
				}
			}
		}

		results = append(results, result.Summary())
	}

	// Summary
	fmt.Println()
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()
	fmt.Println("Summary")
	for i := 0; i < 60; i++ {
		fmt.Print("=")
	}
	fmt.Println()

	passed := 0
	for _, r := range results {
		if r {
			passed++
		}
	}

	fmt.Printf("\nTotal: %d/%d test suites passed\n", passed, len(results))

	if passed == len(results) {
		fmt.Println("\n✓ All tests passed!")
		os.Exit(0)
	} else {
		fmt.Println("\n✗ Some tests failed")
		os.Exit(1)
	}
}
