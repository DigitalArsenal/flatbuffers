<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Python - DA FlatBuffers</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --black: #000000;
      --white: #F5F5F7;
      --white-90: rgba(255, 255, 255, 0.9);
      --white-80: rgba(255, 255, 255, 0.8);
      --white-60: rgba(255, 255, 255, 0.6);
      --white-40: rgba(255, 255, 255, 0.4);
      --white-20: rgba(255, 255, 255, 0.2);
      --white-10: rgba(255, 255, 255, 0.1);
      --white-05: rgba(255, 255, 255, 0.05);
      --muted: rgba(134, 134, 139, 1.0);
      --glass-bg: rgba(42, 42, 45, 0.72);
      --glass-hover: rgba(66, 66, 69, 0.72);
      --glass-border: rgba(255, 255, 255, 0.1);
      --glass-blur: blur(20px);
      --radius: 28px;
      --radius-sm: 14px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--black);
      color: var(--white);
      line-height: 1.6;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Video Background */
    .video-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      overflow: hidden;
    }

    .video-background video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.3;
    }

    .video-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        to bottom,
        rgba(0, 0, 0, 0.4) 0%,
        rgba(0, 0, 0, 0.6) 50%,
        rgba(0, 0, 0, 0.85) 100%
      );
    }

    .page-container {
      position: relative;
      z-index: 1;
      max-width: 900px;
      margin: 0 auto;
      padding: 60px 24px 80px;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      margin-bottom: 40px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      color: var(--white);
      text-decoration: none;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.3s ease;
    }

    .back-link:hover {
      background: var(--glass-hover);
      transform: translateY(-2px);
    }

    .markdown-body {
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      padding: 64px;
    }

    .markdown-body h1 {
      color: var(--white);
      font-size: 56px;
      font-weight: 600;
      line-height: 1.1;
      margin-bottom: 32px;
      letter-spacing: -0.02em;
    }

    .markdown-body h2 {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--white);
      font-size: 28px;
      font-weight: 600;
      line-height: 1.15;
      margin-top: 56px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--glass-border);
    }

    .markdown-body h2::before {
      content: '';
      display: inline-flex;
      width: 24px;
      height: 24px;
      background: var(--white);
      -webkit-mask-size: contain;
      mask-size: contain;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
      flex-shrink: 0;
    }

    /* Icon mappings for h2 headers based on content */
    .markdown-body h2[id*="why"]::before,
    .markdown-body h2:has(+ p:first-of-type)::before {
      -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
      mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
    }

    .markdown-body h3,
    .markdown-body h4 {
      color: var(--white);
      font-weight: 600;
      margin-top: 32px;
      margin-bottom: 16px;
    }

    .markdown-body h3 {
      font-size: 22px;
    }

    .markdown-body h4 {
      font-size: 18px;
      color: var(--white-90);
    }

    .markdown-body p {
      color: var(--white-80);
      font-size: 18px;
      line-height: 1.7;
      margin-bottom: 20px;
    }

    .markdown-body a {
      color: var(--white);
      text-decoration: underline;
      text-underline-offset: 3px;
      transition: opacity 0.2s;
    }

    .markdown-body a:hover {
      opacity: 0.7;
    }

    .markdown-body strong {
      color: var(--white);
      font-weight: 600;
    }

    .markdown-body code {
      background: var(--glass-hover);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      padding: 3px 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9em;
      color: var(--white);
    }

    .markdown-body pre {
      background: var(--black) !important;
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      padding: 24px;
      overflow-x: auto;
      margin: 24px 0;
    }

    .markdown-body pre code {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 14px;
      line-height: 1.7;
      color: var(--white-90);
    }

    .markdown-body ul, .markdown-body ol {
      padding-left: 24px;
      margin-bottom: 20px;
    }

    .markdown-body li {
      margin: 12px 0;
      color: var(--white-80);
      font-size: 18px;
    }

    .markdown-body li strong {
      color: var(--white);
    }

    .markdown-body table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      border-radius: var(--radius-sm);
      overflow: hidden;
    }

    .markdown-body table th,
    .markdown-body table td {
      border: 1px solid var(--glass-border);
      padding: 14px 18px;
      text-align: left;
    }

    .markdown-body table th {
      background: var(--glass-hover);
      font-weight: 600;
      color: var(--white);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .markdown-body table td {
      background: var(--white-05);
      color: var(--white-80);
    }

    .markdown-body table tr:nth-child(even) td {
      background: var(--white-10);
    }

    .markdown-body blockquote {
      border-left: 4px solid var(--white-40);
      background: var(--white-05);
      padding: 20px 24px;
      margin: 24px 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    }

    .markdown-body blockquote p {
      margin: 0;
      color: var(--white-80);
    }

    .markdown-body hr {
      border: none;
      height: 1px;
      background: var(--glass-border);
      margin: 48px 0;
    }

    /* Section header icons */
    .section-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: var(--white-10);
      border-radius: 8px;
      margin-right: 12px;
      flex-shrink: 0;
    }

    .section-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--white);
      fill: none;
      stroke-width: 2;
    }

    @media (max-width: 768px) {
      .page-container {
        padding: 40px 16px 60px;
      }
      .markdown-body {
        padding: 32px 24px;
        border-radius: 20px;
      }
      .markdown-body h1 {
        font-size: 36px;
      }
      .markdown-body h2 {
        font-size: 24px;
      }
      .markdown-body p,
      .markdown-body li {
        font-size: 16px;
      }
    }
  </style>
</head>
<body>
  <!-- Video Background -->
  <div class="video-background">
    <video autoplay loop muted playsinline id="bg-video">
      <source src="" type="application/x-mpegURL">
    </video>
    <div class="video-overlay"></div>
  </div>

  <div class="page-container">
    <a href="../index.html" class="back-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
      Back to DA FlatBuffers
    </a>
    <article class="markdown-body"><h1>Python Integration Guide</h1>
<p>Integrate the FlatBuffers encryption WASM module into Python applications using <a href="https://github.com/wasmerio/wasmer-python">wasmer-python</a>, Python bindings for the Wasmer WebAssembly runtime.</p>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg></span>Why wasmer-python?</h2>
<ul>
<li><strong>High performance</strong> - JIT compilation via Cranelift</li>
<li><strong>Easy installation</strong> - <code>pip install wasmer</code></li>
<li><strong>Type hints</strong> - Full typing support</li>
<li><strong>Cross-platform</strong> - Windows, macOS, Linux</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M9 11l3 3L22 4"/><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/></svg></span>Prerequisites</h2>
<ul>
<li>Python 3.7 or later</li>
<li><code>flatc-encryption.wasm</code> binary</li>
</ul>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg></span>Installation</h2>
<pre><code class="language-bash">pip install wasmer wasmer-compiler-cranelift
</code></pre>
<p>Or with wasmtime (alternative runtime):</p>
<pre><code class="language-bash">pip install wasmtime
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>Quick Start</h2>
<pre><code class="language-python">from wasmer import engine, Store, Module, Instance, ImportObject, Function, FunctionType, Type
from wasmer_compiler_cranelift import Compiler
import os
import struct

# Create store with Cranelift JIT
store = Store(engine.JIT(Compiler))

# Load WASM module
with open("flatc-encryption.wasm", "rb") as f:
    wasm_bytes = f.read()

module = Module(store, wasm_bytes)

# Create WASI imports (minimal stubs)
import_object = ImportObject()

def fd_close(fd: int) -&gt; int:
    return 0

def clock_time_get(clock_id: int, precision: int, time: int) -&gt; int:
    return 0

import_object.register("wasi_snapshot_preview1", {
    "fd_close": Function(store, fd_close, FunctionType([Type.I32], [Type.I32])),
    "clock_time_get": Function(store, clock_time_get, FunctionType([Type.I32, Type.I64, Type.I32], [Type.I32])),
    # ... add other WASI stubs as needed
})

# Instantiate
instance = Instance(module, import_object)

# Get exports
memory = instance.exports.memory
malloc = instance.exports.malloc
free = instance.exports.free
encrypt = instance.exports.wasi_encrypt_bytes
decrypt = instance.exports.wasi_decrypt_bytes

# Helper functions
def write_bytes(ptr: int, data: bytes):
    mem_view = memory.uint8_view(ptr)
    for i, b in enumerate(data):
        mem_view[i] = b

def read_bytes(ptr: int, length: int) -&gt; bytes:
    mem_view = memory.uint8_view(ptr)
    return bytes(mem_view[0:length])

# Encrypt data
key = os.urandom(32)
iv = os.urandom(16)
plaintext = b"Hello, FlatBuffers!"

key_ptr = malloc(32)
iv_ptr = malloc(16)
data_ptr = malloc(len(plaintext))

write_bytes(key_ptr, key)
write_bytes(iv_ptr, iv)
write_bytes(data_ptr, plaintext)

# Encrypt in-place
encrypt(key_ptr, iv_ptr, data_ptr, len(plaintext))

# Read encrypted data
ciphertext = read_bytes(data_ptr, len(plaintext))
print(f"Encrypted: {ciphertext.hex()}")

# Decrypt
decrypt(key_ptr, iv_ptr, data_ptr, len(plaintext))
decrypted = read_bytes(data_ptr, len(plaintext))
print(f"Decrypted: {decrypted.decode()}")

# Clean up
free(key_ptr)
free(iv_ptr)
free(data_ptr)
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></span>Complete Module Wrapper</h2>
<p>For production use, create a Python class wrapping the WASM module:</p>
<pre><code class="language-python">"""
FlatBuffers Encryption Module for Python.

Provides cryptographic operations via the Crypto++ WASM module:
- AES-256-CTR symmetric encryption
- X25519 ECDH key exchange
- secp256k1 ECDH and ECDSA signatures
- P-256 ECDH and ECDSA signatures
- Ed25519 signatures
"""

from wasmer import engine, Store, Module, Instance, ImportObject, Function, FunctionType, Type
from wasmer_compiler_cranelift import Compiler
from pathlib import Path
from typing import Optional, Tuple, NamedTuple
from dataclasses import dataclass
import os
import struct
import time as time_module

# Key and signature sizes
AES_KEY_SIZE = 32
AES_IV_SIZE = 16
SHA256_SIZE = 32

X25519_PRIVATE_KEY_SIZE = 32
X25519_PUBLIC_KEY_SIZE = 32

SECP256K1_PRIVATE_KEY_SIZE = 32
SECP256K1_PUBLIC_KEY_SIZE = 33
SECP256K1_SIGNATURE_MAX_SIZE = 72

ED25519_PRIVATE_KEY_SIZE = 64
ED25519_PUBLIC_KEY_SIZE = 32
ED25519_SIGNATURE_SIZE = 64


@dataclass
class X25519KeyPair:
    """X25519 key pair for ECDH."""
    private_key: bytes  # 32 bytes
    public_key: bytes   # 32 bytes


@dataclass
class Ed25519KeyPair:
    """Ed25519 key pair for signing."""
    private_key: bytes  # 64 bytes (seed + public key)
    public_key: bytes   # 32 bytes


@dataclass
class Secp256k1KeyPair:
    """secp256k1 key pair for ECDH and ECDSA."""
    private_key: bytes  # 32 bytes
    public_key: bytes   # 33 bytes (compressed)


class EncryptionModule:
    """Wrapper for the FlatBuffers WASI encryption module."""

    def __init__(self, wasm_path: Optional[str] = None):
        """
        Initialize the encryption module.

        Args:
            wasm_path: Path to the WASM module. If None, searches default locations.
        """
        if wasm_path is None:
            wasm_path = self._find_wasm_module()

        # Create the store with Cranelift compiler
        self._store = Store(engine.JIT(Compiler))

        # Load and compile the module
        with open(wasm_path, 'rb') as f:
            wasm_bytes = f.read()
        self._module = Module(self._store, wasm_bytes)

        # Create import object with WASI stubs
        import_object = self._create_imports()

        # Instantiate
        self._instance = Instance(self._module, import_object)

        # Cache exported functions
        self._memory = self._instance.exports.memory
        self._malloc = self._instance.exports.malloc
        self._free = self._instance.exports.free

        # Encryption
        self._encrypt = self._instance.exports.wasi_encrypt_bytes
        self._decrypt = self._instance.exports.wasi_decrypt_bytes

        # Hash
        self._sha256 = self._instance.exports.wasi_sha256
        self._hkdf = self._instance.exports.wasi_hkdf

        # X25519
        self._x25519_generate = self._instance.exports.wasi_x25519_generate_keypair
        self._x25519_shared = self._instance.exports.wasi_x25519_shared_secret

        # secp256k1
        self._secp256k1_generate = self._instance.exports.wasi_secp256k1_generate_keypair
        self._secp256k1_shared = self._instance.exports.wasi_secp256k1_shared_secret
        self._secp256k1_sign = self._instance.exports.wasi_secp256k1_sign
        self._secp256k1_verify = self._instance.exports.wasi_secp256k1_verify

        # Ed25519
        self._ed25519_generate = self._instance.exports.wasi_ed25519_generate_keypair
        self._ed25519_sign = self._instance.exports.wasi_ed25519_sign
        self._ed25519_verify = self._instance.exports.wasi_ed25519_verify

    def _find_wasm_module(self) -&gt; str:
        """Search for the WASM module in expected locations."""
        paths = [
            Path(__file__).parent / "flatc-encryption.wasm",
            Path("flatc-encryption.wasm"),
            Path("wasm/flatc-encryption.wasm"),
        ]
        for p in paths:
            if p.exists():
                return str(p.resolve())
        raise FileNotFoundError("Could not find flatc-encryption.wasm")

    def _create_imports(self) -&gt; ImportObject:
        """Create the import object with WASI and env module stubs."""
        import_object = ImportObject()

        # WASI stubs
        def fd_close(fd: int) -&gt; int:
            return 0

        def fd_seek(fd: int, offset: int, whence: int, newoffset: int) -&gt; int:
            return 0

        def fd_write(fd: int, iovs: int, iovs_len: int, nwritten: int) -&gt; int:
            return 0

        def fd_read(fd: int, iovs: int, iovs_len: int, nread: int) -&gt; int:
            return 0

        def environ_sizes_get(count: int, size: int) -&gt; int:
            return 0

        def environ_get(environ: int, environ_buf: int) -&gt; int:
            return 0

        def clock_time_get(clock_id: int, precision: int, time: int) -&gt; int:
            return 0

        def proc_exit(code: int):
            raise SystemExit(code)

        def random_get(buf: int, buf_len: int) -&gt; int:
            return 0

        import_object.register("wasi_snapshot_preview1", {
            "fd_close": Function(self._store, fd_close, FunctionType([Type.I32], [Type.I32])),
            "fd_seek": Function(self._store, fd_seek, FunctionType([Type.I32, Type.I64, Type.I32, Type.I32], [Type.I32])),
            "fd_write": Function(self._store, fd_write, FunctionType([Type.I32, Type.I32, Type.I32, Type.I32], [Type.I32])),
            "fd_read": Function(self._store, fd_read, FunctionType([Type.I32, Type.I32, Type.I32, Type.I32], [Type.I32])),
            "environ_sizes_get": Function(self._store, environ_sizes_get, FunctionType([Type.I32, Type.I32], [Type.I32])),
            "environ_get": Function(self._store, environ_get, FunctionType([Type.I32, Type.I32], [Type.I32])),
            "clock_time_get": Function(self._store, clock_time_get, FunctionType([Type.I32, Type.I64, Type.I32], [Type.I32])),
            "proc_exit": Function(self._store, proc_exit, FunctionType([Type.I32], [])),
            "random_get": Function(self._store, random_get, FunctionType([Type.I32, Type.I32], [Type.I32])),
        })

        # Emscripten env stubs (invoke_* trampolines)
        def invoke_stub(*args):
            pass

        import_object.register("env", {
            "invoke_v": Function(self._store, invoke_stub, FunctionType([Type.I32], [])),
            "invoke_vi": Function(self._store, invoke_stub, FunctionType([Type.I32, Type.I32], [])),
            "invoke_vii": Function(self._store, invoke_stub, FunctionType([Type.I32, Type.I32, Type.I32], [])),
            "invoke_viii": Function(self._store, invoke_stub, FunctionType([Type.I32, Type.I32, Type.I32, Type.I32], [])),
            "invoke_i": Function(self._store, lambda idx: 0, FunctionType([Type.I32], [Type.I32])),
            "invoke_ii": Function(self._store, lambda idx, a: 0, FunctionType([Type.I32, Type.I32], [Type.I32])),
            "invoke_iii": Function(self._store, lambda idx, a, b: 0, FunctionType([Type.I32, Type.I32, Type.I32], [Type.I32])),
        })

        return import_object

    def _write_bytes(self, ptr: int, data: bytes) -&gt; None:
        """Write bytes to WASM memory."""
        mem_view = self._memory.uint8_view(ptr)
        for i, b in enumerate(data):
            mem_view[i] = b

    def _read_bytes(self, ptr: int, length: int) -&gt; bytes:
        """Read bytes from WASM memory."""
        mem_view = self._memory.uint8_view(ptr)
        return bytes(mem_view[0:length])

    # Symmetric Encryption

    def encrypt(self, key: bytes, iv: bytes, data: bytes) -&gt; bytes:
        """
        Encrypt data using AES-256-CTR.

        Args:
            key: 32-byte encryption key
            iv: 16-byte initialization vector
            data: Data to encrypt

        Returns:
            Encrypted data (same length as input)
        """
        if len(key) != AES_KEY_SIZE:
            raise ValueError(f"Key must be {AES_KEY_SIZE} bytes")
        if len(iv) != AES_IV_SIZE:
            raise ValueError(f"IV must be {AES_IV_SIZE} bytes")

        key_ptr = self._malloc(len(key))
        iv_ptr = self._malloc(len(iv))
        data_ptr = self._malloc(len(data))

        try:
            self._write_bytes(key_ptr, key)
            self._write_bytes(iv_ptr, iv)
            self._write_bytes(data_ptr, data)

            result = self._encrypt(key_ptr, iv_ptr, data_ptr, len(data))
            if result != 0:
                raise RuntimeError("Encryption failed")

            return self._read_bytes(data_ptr, len(data))
        finally:
            self._free(key_ptr)
            self._free(iv_ptr)
            self._free(data_ptr)

    def decrypt(self, key: bytes, iv: bytes, data: bytes) -&gt; bytes:
        """
        Decrypt data using AES-256-CTR.

        Args:
            key: 32-byte encryption key
            iv: 16-byte initialization vector
            data: Data to decrypt

        Returns:
            Decrypted data
        """
        # CTR mode is symmetric
        return self.encrypt(key, iv, data)

    # Hash Functions

    def sha256(self, data: bytes) -&gt; bytes:
        """
        Compute SHA-256 hash.

        Args:
            data: Data to hash

        Returns:
            32-byte hash
        """
        data_ptr = self._malloc(len(data))
        out_ptr = self._malloc(SHA256_SIZE)

        try:
            self._write_bytes(data_ptr, data)
            self._sha256(data_ptr, len(data), out_ptr)
            return self._read_bytes(out_ptr, SHA256_SIZE)
        finally:
            self._free(data_ptr)
            self._free(out_ptr)

    def hkdf(self, ikm: bytes, salt: Optional[bytes], info: bytes, length: int) -&gt; bytes:
        """
        Derive key using HKDF-SHA256.

        Args:
            ikm: Input key material
            salt: Optional salt (can be None)
            info: Context/application-specific info
            length: Desired output length

        Returns:
            Derived key material
        """
        ikm_ptr = self._malloc(len(ikm))
        self._write_bytes(ikm_ptr, ikm)

        salt_ptr = 0
        salt_len = 0
        if salt:
            salt_ptr = self._malloc(len(salt))
            self._write_bytes(salt_ptr, salt)
            salt_len = len(salt)

        info_ptr = self._malloc(len(info))
        self._write_bytes(info_ptr, info)

        out_ptr = self._malloc(length)

        try:
            self._hkdf(
                ikm_ptr, len(ikm),
                salt_ptr, salt_len,
                info_ptr, len(info),
                out_ptr, length
            )
            return self._read_bytes(out_ptr, length)
        finally:
            self._free(ikm_ptr)
            if salt_ptr:
                self._free(salt_ptr)
            self._free(info_ptr)
            self._free(out_ptr)

    # X25519 Key Exchange

    def x25519_generate_keypair(self) -&gt; X25519KeyPair:
        """Generate an X25519 key pair."""
        priv_ptr = self._malloc(X25519_PRIVATE_KEY_SIZE)
        pub_ptr = self._malloc(X25519_PUBLIC_KEY_SIZE)

        try:
            result = self._x25519_generate(priv_ptr, pub_ptr)
            if result != 0:
                raise RuntimeError("Key generation failed")

            return X25519KeyPair(
                private_key=self._read_bytes(priv_ptr, X25519_PRIVATE_KEY_SIZE),
                public_key=self._read_bytes(pub_ptr, X25519_PUBLIC_KEY_SIZE)
            )
        finally:
            self._free(priv_ptr)
            self._free(pub_ptr)

    def x25519_shared_secret(self, private_key: bytes, public_key: bytes) -&gt; bytes:
        """
        Compute X25519 shared secret.

        Args:
            private_key: 32-byte private key
            public_key: 32-byte public key

        Returns:
            32-byte shared secret
        """
        priv_ptr = self._malloc(len(private_key))
        pub_ptr = self._malloc(len(public_key))
        out_ptr = self._malloc(32)

        try:
            self._write_bytes(priv_ptr, private_key)
            self._write_bytes(pub_ptr, public_key)

            result = self._x25519_shared(priv_ptr, pub_ptr, out_ptr)
            if result != 0:
                raise RuntimeError("Shared secret computation failed")

            return self._read_bytes(out_ptr, 32)
        finally:
            self._free(priv_ptr)
            self._free(pub_ptr)
            self._free(out_ptr)

    # Ed25519 Signatures

    def ed25519_generate_keypair(self) -&gt; Ed25519KeyPair:
        """Generate an Ed25519 key pair."""
        priv_ptr = self._malloc(ED25519_PRIVATE_KEY_SIZE)
        pub_ptr = self._malloc(ED25519_PUBLIC_KEY_SIZE)

        try:
            result = self._ed25519_generate(priv_ptr, pub_ptr)
            if result != 0:
                raise RuntimeError("Key generation failed")

            return Ed25519KeyPair(
                private_key=self._read_bytes(priv_ptr, ED25519_PRIVATE_KEY_SIZE),
                public_key=self._read_bytes(pub_ptr, ED25519_PUBLIC_KEY_SIZE)
            )
        finally:
            self._free(priv_ptr)
            self._free(pub_ptr)

    def ed25519_sign(self, private_key: bytes, message: bytes) -&gt; bytes:
        """
        Sign a message with Ed25519.

        Args:
            private_key: 64-byte private key
            message: Message to sign

        Returns:
            64-byte signature
        """
        priv_ptr = self._malloc(len(private_key))
        msg_ptr = self._malloc(len(message))
        sig_ptr = self._malloc(ED25519_SIGNATURE_SIZE)

        try:
            self._write_bytes(priv_ptr, private_key)
            self._write_bytes(msg_ptr, message)

            result = self._ed25519_sign(priv_ptr, msg_ptr, len(message), sig_ptr)
            if result != 0:
                raise RuntimeError("Signing failed")

            return self._read_bytes(sig_ptr, ED25519_SIGNATURE_SIZE)
        finally:
            self._free(priv_ptr)
            self._free(msg_ptr)
            self._free(sig_ptr)

    def ed25519_verify(self, public_key: bytes, message: bytes, signature: bytes) -&gt; bool:
        """
        Verify an Ed25519 signature.

        Args:
            public_key: 32-byte public key
            message: Original message
            signature: 64-byte signature

        Returns:
            True if valid, False otherwise
        """
        pub_ptr = self._malloc(len(public_key))
        msg_ptr = self._malloc(len(message))
        sig_ptr = self._malloc(len(signature))

        try:
            self._write_bytes(pub_ptr, public_key)
            self._write_bytes(msg_ptr, message)
            self._write_bytes(sig_ptr, signature)

            result = self._ed25519_verify(pub_ptr, msg_ptr, len(message), sig_ptr)
            return result == 0
        finally:
            self._free(pub_ptr)
            self._free(msg_ptr)
            self._free(sig_ptr)

    # secp256k1

    def secp256k1_generate_keypair(self) -&gt; Secp256k1KeyPair:
        """Generate a secp256k1 key pair."""
        priv_ptr = self._malloc(SECP256K1_PRIVATE_KEY_SIZE)
        pub_ptr = self._malloc(SECP256K1_PUBLIC_KEY_SIZE)

        try:
            result = self._secp256k1_generate(priv_ptr, pub_ptr)
            if result != 0:
                raise RuntimeError("Key generation failed")

            return Secp256k1KeyPair(
                private_key=self._read_bytes(priv_ptr, SECP256K1_PRIVATE_KEY_SIZE),
                public_key=self._read_bytes(pub_ptr, SECP256K1_PUBLIC_KEY_SIZE)
            )
        finally:
            self._free(priv_ptr)
            self._free(pub_ptr)

    def secp256k1_sign(self, private_key: bytes, message_hash: bytes) -&gt; bytes:
        """
        Sign with secp256k1 ECDSA.

        Args:
            private_key: 32-byte private key
            message_hash: 32-byte hash to sign

        Returns:
            DER-encoded signature (70-72 bytes)
        """
        priv_ptr = self._malloc(len(private_key))
        msg_ptr = self._malloc(len(message_hash))
        sig_ptr = self._malloc(SECP256K1_SIGNATURE_MAX_SIZE)
        sig_len_ptr = self._malloc(4)

        try:
            self._write_bytes(priv_ptr, private_key)
            self._write_bytes(msg_ptr, message_hash)

            result = self._secp256k1_sign(
                priv_ptr, msg_ptr, len(message_hash),
                sig_ptr, sig_len_ptr
            )
            if result != 0:
                raise RuntimeError("Signing failed")

            sig_len = struct.unpack('&lt;I', self._read_bytes(sig_len_ptr, 4))[0]
            return self._read_bytes(sig_ptr, sig_len)
        finally:
            self._free(priv_ptr)
            self._free(msg_ptr)
            self._free(sig_ptr)
            self._free(sig_len_ptr)

    def secp256k1_verify(self, public_key: bytes, message_hash: bytes, signature: bytes) -&gt; bool:
        """
        Verify secp256k1 ECDSA signature.

        Args:
            public_key: 33 or 65 byte public key
            message_hash: 32-byte hash that was signed
            signature: DER-encoded signature

        Returns:
            True if valid, False otherwise
        """
        pub_ptr = self._malloc(len(public_key))
        msg_ptr = self._malloc(len(message_hash))
        sig_ptr = self._malloc(len(signature))

        try:
            self._write_bytes(pub_ptr, public_key)
            self._write_bytes(msg_ptr, message_hash)
            self._write_bytes(sig_ptr, signature)

            result = self._secp256k1_verify(
                pub_ptr, len(public_key),
                msg_ptr, len(message_hash),
                sig_ptr, len(signature)
            )
            return result == 0
        finally:
            self._free(pub_ptr)
            self._free(msg_ptr)
            self._free(sig_ptr)
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>Template Project Structure</h2>
<pre><code>myproject/
├── requirements.txt
├── encryption.py       # WASM wrapper module
├── main.py
├── wasm/
│   └── flatc-encryption.wasm
└── tests/
    └── test_encryption.py
</code></pre>
<p><strong>requirements.txt:</strong></p>
<pre><code>wasmer&gt;=1.1.0
wasmer-compiler-cranelift&gt;=1.1.0
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Usage Examples</h2>
<h3>Basic Encryption</h3>
<pre><code class="language-python">from encryption import EncryptionModule
import os

module = EncryptionModule("flatc-encryption.wasm")

# Generate key and IV
key = os.urandom(32)
iv = os.urandom(16)

# Encrypt
plaintext = b"Secret message"
ciphertext = module.encrypt(key, iv, plaintext)

# Decrypt
decrypted = module.decrypt(key, iv, ciphertext)
assert decrypted == plaintext
</code></pre>
<h3>End-to-End Encryption</h3>
<pre><code class="language-python">from encryption import EncryptionModule
import os

module = EncryptionModule()

# Alice generates keypair
alice = module.x25519_generate_keypair()

# Bob generates keypair
bob = module.x25519_generate_keypair()

# Alice computes shared secret
alice_shared = module.x25519_shared_secret(alice.private_key, bob.public_key)

# Bob computes same shared secret
bob_shared = module.x25519_shared_secret(bob.private_key, alice.public_key)

assert alice_shared == bob_shared

# Derive encryption key
encryption_key = module.hkdf(
    alice_shared,
    None,  # no salt
    b"my-app-encryption-v1",
    32
)

# Encrypt message
iv = os.urandom(16)
message = b"Hello Bob!"
ciphertext = module.encrypt(encryption_key, iv, message)

# Bob decrypts
decrypted = module.decrypt(encryption_key, iv, ciphertext)
print(decrypted.decode())  # "Hello Bob!"
</code></pre>
<h3>Digital Signatures</h3>
<pre><code class="language-python">from encryption import EncryptionModule

module = EncryptionModule()

# Generate signing keypair
keypair = module.ed25519_generate_keypair()

# Sign message
message = b"Sign this document"
signature = module.ed25519_sign(keypair.private_key, message)

# Verify
is_valid = module.ed25519_verify(keypair.public_key, message, signature)
print(f"Signature valid: {is_valid}")  # True

# Tampered message fails verification
is_valid = module.ed25519_verify(keypair.public_key, b"tampered", signature)
print(f"Tampered valid: {is_valid}")  # False
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg></span>Alternative: Using wasmtime-py</h2>
<p>If you prefer wasmtime over wasmer:</p>
<pre><code class="language-python">import wasmtime

# Create engine and store
engine = wasmtime.Engine()
store = wasmtime.Store(engine)
linker = wasmtime.Linker(engine)

# Add WASI
wasi_config = wasmtime.WasiConfig()
store.set_wasi(wasi_config)
linker.define_wasi()

# Load and instantiate
module = wasmtime.Module.from_file(engine, "flatc-encryption.wasm")
instance = linker.instantiate(store, module)

# Get exports
memory = instance.exports(store)["memory"]
malloc = instance.exports(store)["malloc"]
# ...
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/></svg></span>Performance Tips</h2>
<ol>
<li><strong>Reuse the module instance</strong> - Instantiation is expensive</li>
<li><strong>Batch operations</strong> - Minimize Python-WASM boundary crossings</li>
<li><strong>Use memoryview</strong> - For large data, avoid copying</li>
</ol>
<pre><code class="language-python"># Good: Reuse instance
module = EncryptionModule()
for item in items:
    module.encrypt(key, iv, item)

# Bad: Create new instance each time
for item in items:
    module = EncryptionModule()  # Slow!
    module.encrypt(key, iv, item)
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg></span>Troubleshooting</h2>
<h3>"Import not found: wasi_snapshot_preview1"</h3>
<p>Add WASI stubs to your import object. See the complete wrapper above.</p>
<h3>"Import not found: env.invoke_*"</h3>
<p>Add Emscripten trampolines. For basic usage, empty stubs work:</p>
<pre><code class="language-python">import_object.register("env", {
    "invoke_v": Function(store, lambda idx: None, FunctionType([Type.I32], [])),
    # ... add more as needed
})
</code></pre>
<h3>"Memory access out of bounds"</h3>
<p>Check pointer validity and buffer sizes:</p>
<pre><code class="language-python">ptr = malloc(size)
if ptr == 0:
    raise MemoryError("malloc returned null")
</code></pre>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg></span>See Also</h2>
<ul>
<li><a href="https://wasmerio.github.io/wasmer-python/">wasmer-python Documentation</a></li>
<li><a href="https://bytecodealliance.github.io/wasmtime-py/">wasmtime-py Documentation</a></li>
<li><a href="README.html">API Reference</a></li>
<li><a href="README.html#security-considerations">Security Considerations</a></li>
</ul>
</article>
  </div>

  <script>
    // Initialize HLS video with random selection
    const videoUrls = [
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/90bb1b34646b81b3b63e5a854ea00da3/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/df176a2fb2ea2b64bd21ae1c10d3af6a/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/12a9780eeb1ea015801a5f55cf2e9d3d/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/964cb3eddff1a67e3772aac9a7aceea2/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/dd17599dfa77f41517133fa7a4967535/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/408ad52e3f15bc8f01ae69d194a8cf3a/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/e923e67d71fed3e0853ec57f0348451e/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/136a8a211c6c3b1cc1fd7b1c7d836c58/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/c9ddd33ac3d964e5d33b31ce849e8f95/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/257c7359efd4b4aaebcc03aa8fc78a36/manifest/video.m3u8",
      "https://customer-cbeadsgr09pnsezs.cloudflarestream.com/697945ca6b876878dba3b23fbd2f1561/manifest/video.m3u8"
    ];

    const video = document.getElementById('bg-video');
    const randomUrl = videoUrls[Math.floor(Math.random() * videoUrls.length)];

    if (Hls.isSupported()) {
      const hls = new Hls();
      hls.loadSource(randomUrl);
      hls.attachMedia(video);
    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
      video.src = randomUrl;
    }
  </script>
</body>
</html>
