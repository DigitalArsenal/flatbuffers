<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FlatBuffers Encryption Demo</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
    }
    .card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .card h2 {
      margin-top: 0;
      color: #2563eb;
    }
    textarea, input[type="text"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
      font-size: 14px;
    }
    textarea {
      height: 150px;
      resize: vertical;
    }
    button {
      background: #2563eb;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin: 5px 5px 5px 0;
    }
    button:hover {
      background: #1d4ed8;
    }
    button:disabled {
      background: #9ca3af;
      cursor: not-allowed;
    }
    .output {
      background: #1e293b;
      color: #e2e8f0;
      padding: 15px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 300px;
      overflow-y: auto;
    }
    .success {
      color: #22c55e;
    }
    .error {
      color: #ef4444;
    }
    .info {
      color: #3b82f6;
    }
    label {
      display: block;
      margin: 10px 0 5px;
      font-weight: 500;
    }
    .hex-display {
      font-family: monospace;
      font-size: 12px;
      word-break: break-all;
    }
    .row {
      display: flex;
      gap: 20px;
    }
    .col {
      flex: 1;
    }
    #status {
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 20px;
    }
    #status.loading {
      background: #fef3c7;
      color: #92400e;
    }
    #status.ready {
      background: #d1fae5;
      color: #065f46;
    }
    #status.error {
      background: #fee2e2;
      color: #991b1b;
    }
  </style>
</head>
<body>
  <h1>FlatBuffers Encryption Demo (WASM Binary)</h1>

  <div id="status" class="loading">Loading flatc-wasm...</div>

  <div class="card">
    <h2>1. Encryption Key</h2>
    <p>256-bit key (64 hex characters):</p>
    <input type="text" id="encryption-key" placeholder="Generate or enter a 64-character hex key">
    <button onclick="generateKey()">Generate Random Key</button>
  </div>

  <div class="card">
    <h2>2. Operations</h2>
    <button onclick="testEncryptDecrypt()" id="btn-test">Run AES-256-CTR Test</button>
    <button onclick="testX25519()" id="btn-x25519">Run X25519 ECDH Test</button>
    <button onclick="testSha256()" id="btn-sha256">Run SHA-256 Test</button>
    <button onclick="testHkdf()" id="btn-hkdf">Run HKDF Test</button>
  </div>

  <div class="card">
    <h2>3. Output</h2>
    <div id="log" class="output">Waiting for WASM module to load...</div>
  </div>

  <div class="card">
    <h2>How It Works</h2>
    <ul>
      <li><strong>All crypto runs in the WASM binary</strong> &mdash; no JS crypto code</li>
      <li>Uses <code>Module._wasm_crypto_*</code> Emscripten exports</li>
      <li>Data is copied to/from WASM linear memory via <code>_malloc</code>/<code>HEAPU8</code></li>
      <li>Supports AES-256-CTR, X25519, secp256k1, P-256, P-384, Ed25519, HKDF, SHA-256</li>
    </ul>
  </div>

  <script type="module">
    // Load the Emscripten module directly
    const createModule = (await import('../../dist/flatc-wasm.js')).default;

    let Module = null;
    const logEl = document.getElementById('log');
    const status = document.getElementById('status');

    function appendLog(msg, className = '') {
      const line = document.createElement('div');
      line.textContent = msg;
      if (className) line.className = className;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function clearLog() {
      logEl.innerHTML = '';
    }

    function toHex(arr) {
      return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function fromHex(hex) {
      const bytes = new Uint8Array(hex.length / 2);
      for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
      }
      return bytes;
    }

    // WASM memory helpers
    function allocBytes(data) {
      const ptr = Module._malloc(data.length);
      Module.HEAPU8.set(data, ptr);
      return ptr;
    }

    function readBytes(ptr, len) {
      return new Uint8Array(Module.HEAPU8.buffer, ptr, len).slice();
    }

    // Operations
    window.generateKey = function() {
      const key = crypto.getRandomValues(new Uint8Array(32));
      document.getElementById('encryption-key').value = toHex(key);
      appendLog('Generated new 256-bit key', 'success');
    };

    window.testEncryptDecrypt = function() {
      clearLog();
      appendLog('=== AES-256-CTR Encrypt/Decrypt ===', 'info');

      const keyHex = document.getElementById('encryption-key').value;
      if (keyHex.length !== 64) {
        appendLog('Error: Key must be 64 hex characters', 'error');
        return;
      }

      const key = fromHex(keyHex);
      const iv = crypto.getRandomValues(new Uint8Array(16));
      const plaintext = new TextEncoder().encode('Hello from the browser! This is encrypted with WASM.');
      const original = new Uint8Array(plaintext);

      const keyPtr = allocBytes(key);
      const ivPtr = allocBytes(iv);
      const dataPtr = allocBytes(plaintext);

      appendLog(`Plaintext: "${new TextDecoder().decode(plaintext)}"`);
      appendLog(`Key: ${toHex(key).substring(0, 32)}...`);
      appendLog(`IV:  ${toHex(iv)}`);

      // Encrypt
      Module._wasm_crypto_encrypt_bytes(keyPtr, ivPtr, dataPtr, plaintext.length);
      const encrypted = readBytes(dataPtr, plaintext.length);
      appendLog(`Encrypted: ${toHex(encrypted).substring(0, 64)}...`, 'info');

      // Decrypt (re-copy IV since encrypt consumed it)
      Module.HEAPU8.set(iv, ivPtr);
      Module._wasm_crypto_decrypt_bytes(keyPtr, ivPtr, dataPtr, plaintext.length);
      const decrypted = readBytes(dataPtr, plaintext.length);
      const decryptedText = new TextDecoder().decode(decrypted);

      appendLog(`Decrypted: "${decryptedText}"`);

      const match = decryptedText === new TextDecoder().decode(original);
      appendLog(match ? 'Round-trip PASSED' : 'Round-trip FAILED', match ? 'success' : 'error');

      Module._free(keyPtr);
      Module._free(ivPtr);
      Module._free(dataPtr);
    };

    window.testX25519 = function() {
      clearLog();
      appendLog('=== X25519 ECDH Key Exchange ===', 'info');

      const privPtr1 = Module._malloc(32), pubPtr1 = Module._malloc(32);
      const privPtr2 = Module._malloc(32), pubPtr2 = Module._malloc(32);
      const secretPtr1 = Module._malloc(32), secretPtr2 = Module._malloc(32);

      Module._wasm_crypto_x25519_generate_keypair(privPtr1, pubPtr1);
      Module._wasm_crypto_x25519_generate_keypair(privPtr2, pubPtr2);

      const pub1 = readBytes(pubPtr1, 32);
      const pub2 = readBytes(pubPtr2, 32);
      appendLog(`Alice pubkey: ${toHex(pub1).substring(0, 32)}...`);
      appendLog(`Bob pubkey:   ${toHex(pub2).substring(0, 32)}...`);

      Module._wasm_crypto_x25519_shared_secret(privPtr1, pubPtr1, pubPtr2, secretPtr1);
      Module._wasm_crypto_x25519_shared_secret(privPtr2, pubPtr2, pubPtr1, secretPtr2);

      const secret1 = readBytes(secretPtr1, 32);
      const secret2 = readBytes(secretPtr2, 32);
      appendLog(`Alice secret: ${toHex(secret1).substring(0, 32)}...`);
      appendLog(`Bob secret:   ${toHex(secret2).substring(0, 32)}...`);

      const match = toHex(secret1) === toHex(secret2);
      appendLog(match ? 'Shared secrets match - PASSED' : 'Shared secrets differ - FAILED', match ? 'success' : 'error');

      [privPtr1, pubPtr1, privPtr2, pubPtr2, secretPtr1, secretPtr2].forEach(p => Module._free(p));
    };

    window.testSha256 = function() {
      clearLog();
      appendLog('=== SHA-256 Hash ===', 'info');

      const data = new TextEncoder().encode('test');
      const dataPtr = allocBytes(data);
      const hashPtr = Module._malloc(32);

      Module._wasm_crypto_sha256(dataPtr, data.length, hashPtr);
      const hash = readBytes(hashPtr, 32);

      const expected = '9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08';
      const actual = toHex(hash);

      appendLog(`Input: "test"`);
      appendLog(`Expected: ${expected}`);
      appendLog(`Got:      ${actual}`);
      appendLog(actual === expected ? 'SHA-256 PASSED' : 'SHA-256 FAILED', actual === expected ? 'success' : 'error');

      Module._free(dataPtr);
      Module._free(hashPtr);
    };

    window.testHkdf = function() {
      clearLog();
      appendLog('=== HKDF-SHA256 Key Derivation ===', 'info');

      const ikm = crypto.getRandomValues(new Uint8Array(32));
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const info = new TextEncoder().encode('flatbuffers-test');

      const ikmPtr = allocBytes(ikm);
      const saltPtr = allocBytes(salt);
      const infoPtr = allocBytes(info);
      const outPtr = Module._malloc(32);

      Module._wasm_crypto_hkdf(ikmPtr, ikm.length, saltPtr, salt.length, infoPtr, info.length, outPtr, 32);
      const derived1 = readBytes(outPtr, 32);

      Module._wasm_crypto_hkdf(ikmPtr, ikm.length, saltPtr, salt.length, infoPtr, info.length, outPtr, 32);
      const derived2 = readBytes(outPtr, 32);

      appendLog(`IKM:     ${toHex(ikm).substring(0, 32)}...`);
      appendLog(`Derived: ${toHex(derived1).substring(0, 32)}...`);

      const match = toHex(derived1) === toHex(derived2);
      appendLog(match ? 'HKDF deterministic - PASSED' : 'HKDF non-deterministic - FAILED', match ? 'success' : 'error');

      Module._free(ikmPtr); Module._free(saltPtr);
      Module._free(infoPtr); Module._free(outPtr);
    };

    // Initialize
    async function init() {
      try {
        Module = await createModule({ noExitRuntime: true, noInitialRun: true });
        const versionPtr = Module._wasm_crypto_get_version();
        const version = Module.UTF8ToString(versionPtr);
        status.textContent = `Ready! WASM crypto v${version}`;
        status.className = 'ready';
        logEl.innerHTML = '';
        appendLog(`WASM module loaded - crypto v${version}`, 'success');
      } catch (e) {
        status.textContent = `Failed to load: ${e.message}`;
        status.className = 'error';
        appendLog(`Failed to load: ${e.message}`, 'error');
      }
    }

    init();
  </script>
</body>
</html>
