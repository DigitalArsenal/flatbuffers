<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>README - DA FlatBuffers</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --black: #000000;
      --white: #F5F5F7;
      --white-90: rgba(255, 255, 255, 0.9);
      --white-80: rgba(255, 255, 255, 0.8);
      --white-60: rgba(255, 255, 255, 0.6);
      --white-40: rgba(255, 255, 255, 0.4);
      --white-20: rgba(255, 255, 255, 0.2);
      --white-10: rgba(255, 255, 255, 0.1);
      --white-05: rgba(255, 255, 255, 0.05);
      --muted: rgba(134, 134, 139, 1.0);
      --glass-bg: rgba(42, 42, 45, 0.72);
      --glass-hover: rgba(66, 66, 69, 0.72);
      --glass-border: rgba(255, 255, 255, 0.1);
      --glass-blur: blur(20px);
      --radius: 28px;
      --radius-sm: 14px;

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;

    html {
      scroll-behavior: smooth;

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--black);
      color: var(--white);
      line-height: 1.6;
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;

    /* Video Background */
    .video-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      overflow: hidden;

    .video-background video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0.3;

    .video-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        to bottom,
        rgba(0, 0, 0, 0.4) 0%,
        rgba(0, 0, 0, 0.6) 50%,
        rgba(0, 0, 0, 0.85) 100%
      );

    .page-container {
      position: relative;
      z-index: 1;
      max-width: 900px;
      margin: 0 auto;
      padding: 60px 24px 80px;

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      margin-bottom: 40px;
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      color: var(--white);
      text-decoration: none;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.3s ease;

    .back-link:hover {
      background: var(--glass-hover);
      transform: translateY(-2px);

    .markdown-body {
      background: var(--glass-bg);
      backdrop-filter: var(--glass-blur);
      -webkit-backdrop-filter: var(--glass-blur);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius);
      padding: 64px;

    .markdown-body h1 {
      color: var(--white);
      font-size: 56px;
      font-weight: 600;
      line-height: 1.1;
      margin-bottom: 32px;
      letter-spacing: -0.02em;

    .markdown-body h2 {
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--white);
      font-size: 28px;
      font-weight: 600;
      line-height: 1.15;
      margin-top: 56px;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--glass-border);

    .markdown-body h2::before {
      content: '';
      display: inline-flex;
      width: 24px;
      height: 24px;
      background: var(--white);
      -webkit-mask-size: contain;
      mask-size: contain;
      -webkit-mask-repeat: no-repeat;
      mask-repeat: no-repeat;
      -webkit-mask-position: center;
      mask-position: center;
      flex-shrink: 0;

    /* Icon mappings for h2 headers based on content */
    .markdown-body h2[id*="why"]::before,
    .markdown-body h2:has(+ p:first-of-type)::before {
      -webkit-mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");
      mask-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpath d='M12 16v-4M12 8h.01'/%3E%3C/svg%3E");

    .markdown-body h3,
    .markdown-body h4 {
      color: var(--white);
      font-weight: 600;
      margin-top: 32px;
      margin-bottom: 16px;

    .markdown-body h3 {
      font-size: 22px;

    .markdown-body h4 {
      font-size: 18px;
      color: var(--white-90);

    .markdown-body p {
      color: var(--white-80);
      font-size: 18px;
      line-height: 1.7;
      margin-bottom: 20px;

    .markdown-body a {
      color: var(--white);
      text-decoration: underline;
      text-underline-offset: 3px;
      transition: opacity 0.2s;

    .markdown-body a:hover {
      opacity: 0.7;

    .markdown-body strong {
      color: var(--white);
      font-weight: 600;

    .markdown-body code {
      background: var(--glass-hover);
      border: 1px solid var(--glass-border);
      border-radius: 6px;
      padding: 3px 8px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9em;
      color: var(--white);

    .markdown-body pre {
      background: var(--black) !important;
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-sm);
      padding: 24px;
      overflow-x: auto;
      margin: 24px 0;

    .markdown-body pre code {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 14px;
      line-height: 1.7;
      color: var(--white-90);

    .markdown-body ul, .markdown-body ol {
      padding-left: 24px;
      margin-bottom: 20px;

    .markdown-body li {
      margin: 12px 0;
      color: var(--white-80);
      font-size: 18px;

    .markdown-body li strong {
      color: var(--white);

    .markdown-body table {
      width: 100%;
      border-collapse: collapse;
      margin: 24px 0;
      border-radius: var(--radius-sm);
      overflow: hidden;

    .markdown-body table th,
    .markdown-body table td {
      border: 1px solid var(--glass-border);
      padding: 14px 18px;
      text-align: left;

    .markdown-body table th {
      background: var(--glass-hover);
      font-weight: 600;
      color: var(--white);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 0.05em;

    .markdown-body table td {
      background: var(--white-05);
      color: var(--white-80);

    .markdown-body table tr:nth-child(even) td {
      background: var(--white-10);

    .markdown-body blockquote {
      border-left: 4px solid var(--white-40);
      background: var(--white-05);
      padding: 20px 24px;
      margin: 24px 0;
      border-radius: 0 var(--radius-sm) var(--radius-sm) 0;

    .markdown-body blockquote p {
      margin: 0;
      color: var(--white-80);

    .markdown-body hr {
      border: none;
      height: 1px;
      background: var(--glass-border);
      margin: 48px 0;

    /* Section header icons */
    .section-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 32px;
      height: 32px;
      background: var(--white-10);
      border-radius: 8px;
      margin-right: 12px;
      flex-shrink: 0;

    .section-icon svg {
      width: 18px;
      height: 18px;
      stroke: var(--white);
      fill: none;
      stroke-width: 2;

    @media (max-width: 768px) {
      .page-container {
        padding: 40px 16px 60px;
      .markdown-body {
        padding: 32px 24px;
        border-radius: 20px;
      .markdown-body h1 {
        font-size: 36px;
      .markdown-body h2 {
        font-size: 24px;
      .markdown-body p,
      .markdown-body li {
        font-size: 16px;
  </style>
</head>
<body>
  <!-- Video Background -->
  <div class="video-background">
    <video autoplay loop muted playsinline id="bg-video">
      <source src="" type="application/x-mpegURL">
    </video>
    <div class="video-overlay"></div>
  </div>

  <div class="page-container">
    <a href="../index.html" class="back-link">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M19 12H5M12 19l-7-7 7-7"/>
      </svg>
      Back to DA FlatBuffers
    </a>
    <article class="markdown-body"><h1>FlatBuffers WASM Runtime Integration</h1>
<p>Run the FlatBuffers encryption module in any language with WebAssembly support. The same cryptographic implementation works across all platforms, ensuring consistent behavior and cross-language interoperability.</p>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg></span>Why WASM Runtimes?</h2>
<h3>Single Auditable Implementation</h3>
<p>The encryption module is compiled from a single C++ codebase to WebAssembly. This means:</p>
<ul>
<li><strong>One codebase to audit</strong> - Security teams can focus on a single implementation</li>
<li><strong>Consistent behavior</strong> - Identical cryptographic operations across all languages</li>
<li><strong>No native dependencies</strong> - Pure WASM runs in any compliant runtime</li>
</ul>
<h3>Battle-Tested Cryptography</h3>
<p>Two cryptographic backends are available. <strong>The pre-built WASM module uses Crypto++ by default</strong> (configured via <code>FLATBUFFERS_USE_CRYPTOPP=1</code> in the CMake build).</p>
<h4>Default: Crypto++ (Pre-built)</h4>
<p>The default WASM build (<code>flatc-encryption.wasm</code>) uses <a href="https://cryptopp.com/">Crypto++</a>, a cryptographic library with:</p>
<ul>
<li>30+ years of production use</li>
<li>FIPS 140-2 validation</li>
<li>Extensive peer review and security audits</li>
<li>Active maintenance and security updates</li>
<li>Full algorithm support including X25519, Ed25519, secp256k1</li>
</ul>
<h4>FIPS Support via hd-wallet-wasm</h4>
<p>FIPS 140-3 compatible algorithms are available through <code>hd-wallet-wasm</code>, which includes
built-in OpenSSL FIPS support. Enable it with <code>wallet.initFips()</code>:</p>
<ul>
<li>NIST-approved curves (P-256, P-384)</li>
<li>AES-256-GCM authenticated encryption</li>
<li>HKDF, PBKDF2, scrypt key derivation</li>
<li>Full multi-curve support (secp256k1, Ed25519, X25519) also available in non-FIPS mode</li>
</ul>
<h3>Cross-Language Interoperability</h3>
<p>Data encrypted in one language can be decrypted in any other:</p>
<pre><code>Go &#8596; Python &#8596; Rust &#8596; Java &#8596; C# &#8596; Swift &#8596; Node.js &#8596; Browser
</code></pre>
<p>All implementations use the same:</p>
<ul>
<li>Key formats (raw bytes)</li>
<li>IV/nonce handling</li>
<li>Encryption algorithms (AES-256-CTR)</li>
<li>Key derivation (HKDF-SHA256)</li>
<li>Signature formats (DER-encoded ECDSA, raw Ed25519)</li>
</ul>
<hr>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></span>Supported Runtimes</h2>
<table>
<thead>
<tr>
<th>Language</th>
<th>Runtime</th>
<th>Package</th>
<th>Key Features</th>
</tr>
</thead>
<tbody><tr>
<td><a href="go.html">Go</a></td>
<td>wazero</td>
<td><code>github.com/tetratelabs/wazero</code></td>
<td>Pure Go, no CGo, zero dependencies</td>
</tr>
<tr>
<td><a href="python.html">Python</a></td>
<td>wasmer</td>
<td><code>pip install wasmer</code></td>
<td>PyPI ready, type hints</td>
</tr>
<tr>
<td><a href="rust.html">Rust</a></td>
<td>wasmer</td>
<td><code>wasmer</code> crate</td>
<td>no_std support, memory safe</td>
</tr>
<tr>
<td><a href="java.html">Java</a></td>
<td>Chicory</td>
<td>Maven Central</td>
<td>Pure Java, no JNI</td>
</tr>
<tr>
<td><a href="csharp.html">C#</a></td>
<td>Wasmtime</td>
<td>NuGet</td>
<td>.NET 6+, async support</td>
</tr>
<tr>
<td><a href="swift.html">Swift</a></td>
<td>WasmKit</td>
<td>Swift Package Manager</td>
<td>iOS/macOS, pure Swift</td>
</tr>
<tr>
<td><a href="nodejs.html">Node.js</a></td>
<td>V8 (native)</td>
<td><code>npm install flatc-wasm</code></td>
<td>ESM/CJS, TypeScript</td>
</tr>
<tr>
<td><a href="browser.html">Browser</a></td>
<td>V8/SpiderMonkey/JSC</td>
<td>CDN or bundler</td>
<td>All modern browsers</td>
</tr>
</tbody></table>
<hr>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg></span>Cryptographic Operations</h2>
<h3>Symmetric Encryption</h3>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Algorithm</th>
<th>Key Size</th>
<th>IV Size</th>
</tr>
</thead>
<tbody><tr>
<td>Encryption/Decryption</td>
<td>AES-256-CTR</td>
<td>32 bytes</td>
<td>16 bytes</td>
</tr>
</tbody></table>
<h3>Key Exchange (ECDH)</h3>
<table>
<thead>
<tr>
<th>Curve</th>
<th>Private Key</th>
<th>Public Key</th>
<th>Shared Secret</th>
<th>Use Case</th>
</tr>
</thead>
<tbody><tr>
<td>X25519</td>
<td>32 bytes</td>
<td>32 bytes</td>
<td>32 bytes</td>
<td>General purpose, Signal, WireGuard</td>
</tr>
<tr>
<td>secp256k1</td>
<td>32 bytes</td>
<td>33 bytes*</td>
<td>32 bytes</td>
<td>Bitcoin, Ethereum, cryptocurrencies</td>
</tr>
<tr>
<td>P-256</td>
<td>32 bytes</td>
<td>33 bytes*</td>
<td>32 bytes</td>
<td>TLS, enterprise, NIST compliance</td>
</tr>
</tbody></table>
<p>*Compressed format. Uncompressed (65 bytes) also supported for input.</p>
<h3>Digital Signatures</h3>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Private Key</th>
<th>Public Key</th>
<th>Signature</th>
<th>Use Case</th>
</tr>
</thead>
<tbody><tr>
<td>Ed25519</td>
<td>64 bytes</td>
<td>32 bytes</td>
<td>64 bytes</td>
<td>Fast, deterministic, Solana/Cardano</td>
</tr>
<tr>
<td>secp256k1 ECDSA</td>
<td>32 bytes</td>
<td>33 bytes</td>
<td>70-72 bytes*</td>
<td>Bitcoin, Ethereum transactions</td>
</tr>
<tr>
<td>P-256 ECDSA</td>
<td>32 bytes</td>
<td>33 bytes</td>
<td>70-72 bytes*</td>
<td>TLS, enterprise PKI</td>
</tr>
</tbody></table>
<p>*DER-encoded, variable length.</p>
<h3>Key Derivation</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Input</th>
<th>Output</th>
<th>Use Case</th>
</tr>
</thead>
<tbody><tr>
<td>HKDF-SHA256</td>
<td>IKM + salt + info</td>
<td>Variable length</td>
<td>Derive keys from ECDH shared secrets</td>
</tr>
<tr>
<td>SHA-256</td>
<td>Any data</td>
<td>32 bytes</td>
<td>Hashing, message digests</td>
</tr>
</tbody></table>
<hr>
<h2 id="api-reference"><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg></span>API Reference</h2>
<p>All runtimes expose the same WASM functions. Memory management follows the pattern:</p>
<ol>
<li>Allocate memory with <code>malloc</code></li>
<li>Write input data to allocated memory</li>
<li>Call the cryptographic function</li>
<li>Read output from memory</li>
<li>Free allocated memory with <code>free</code></li>
</ol>
<h3>Core Functions</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>malloc</code></td>
<td><code>(size: i32) -&gt; i32</code></td>
<td>Allocate <code>size</code> bytes, returns pointer</td>
</tr>
<tr>
<td><code>free</code></td>
<td><code>(ptr: i32)</code></td>
<td>Free memory at pointer</td>
</tr>
</tbody></table>
<h3>Hash Functions</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>wasi_sha256</code></td>
<td><code>(data: i32, len: i32, out: i32)</code></td>
<td>SHA-256 hash. <code>out</code> must be 32 bytes</td>
</tr>
<tr>
<td><code>wasi_hkdf</code></td>
<td><code>(ikm: i32, ikm_len: i32, salt: i32, salt_len: i32, info: i32, info_len: i32, out: i32, out_len: i32)</code></td>
<td>HKDF-SHA256. <code>salt</code> can be NULL (0)</td>
</tr>
</tbody></table>
<h3>Symmetric Encryption</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>wasi_encrypt_bytes</code></td>
<td><code>(key: i32, iv: i32, data: i32, len: i32) -&gt; i32</code></td>
<td>AES-256-CTR encrypt in-place. Returns 0 on success</td>
</tr>
<tr>
<td><code>wasi_decrypt_bytes</code></td>
<td><code>(key: i32, iv: i32, data: i32, len: i32) -&gt; i32</code></td>
<td>AES-256-CTR decrypt in-place. Returns 0 on success</td>
</tr>
</tbody></table>
<h3>X25519 Key Exchange</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>wasi_x25519_generate_keypair</code></td>
<td><code>(priv_out: i32, pub_out: i32) -&gt; i32</code></td>
<td>Generate keypair. <code>priv_out</code>: 32 bytes, <code>pub_out</code>: 32 bytes</td>
</tr>
<tr>
<td><code>wasi_x25519_shared_secret</code></td>
<td><code>(priv: i32, pub: i32, out: i32) -&gt; i32</code></td>
<td>Compute shared secret. <code>out</code>: 32 bytes</td>
</tr>
</tbody></table>
<h3>secp256k1 (Bitcoin/Ethereum)</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>wasi_secp256k1_generate_keypair</code></td>
<td><code>(priv_out: i32, pub_out: i32) -&gt; i32</code></td>
<td>Generate keypair. <code>priv_out</code>: 32 bytes, <code>pub_out</code>: 33 bytes</td>
</tr>
<tr>
<td><code>wasi_secp256k1_shared_secret</code></td>
<td><code>(priv: i32, pub: i32, pub_len: i32, out: i32) -&gt; i32</code></td>
<td>ECDH. <code>pub_len</code>: 33 or 65</td>
</tr>
<tr>
<td><code>wasi_secp256k1_sign</code></td>
<td><code>(priv: i32, data: i32, len: i32, sig_out: i32, sig_len_out: i32) -&gt; i32</code></td>
<td>Sign (usually a hash). <code>sig_out</code>: max 72 bytes</td>
</tr>
<tr>
<td><code>wasi_secp256k1_verify</code></td>
<td><code>(pub: i32, pub_len: i32, data: i32, len: i32, sig: i32, sig_len: i32) -&gt; i32</code></td>
<td>Verify. Returns 0 if valid</td>
</tr>
</tbody></table>
<h3>P-256 (NIST)</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>wasi_p256_generate_keypair</code></td>
<td><code>(priv_out: i32, pub_out: i32) -&gt; i32</code></td>
<td>Generate keypair. <code>priv_out</code>: 32 bytes, <code>pub_out</code>: 33 bytes</td>
</tr>
<tr>
<td><code>wasi_p256_shared_secret</code></td>
<td><code>(priv: i32, pub: i32, pub_len: i32, out: i32) -&gt; i32</code></td>
<td>ECDH. <code>pub_len</code>: 33 or 65</td>
</tr>
<tr>
<td><code>wasi_p256_sign</code></td>
<td><code>(priv: i32, data: i32, len: i32, sig_out: i32, sig_len_out: i32) -&gt; i32</code></td>
<td>Sign (usually a hash). <code>sig_out</code>: max 72 bytes</td>
</tr>
<tr>
<td><code>wasi_p256_verify</code></td>
<td><code>(pub: i32, pub_len: i32, data: i32, len: i32, sig: i32, sig_len: i32) -&gt; i32</code></td>
<td>Verify. Returns 0 if valid</td>
</tr>
</tbody></table>
<h3>Ed25519 Signatures</h3>
<table>
<thead>
<tr>
<th>Function</th>
<th>Signature</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>wasi_ed25519_generate_keypair</code></td>
<td><code>(priv_out: i32, pub_out: i32) -&gt; i32</code></td>
<td>Generate keypair. <code>priv_out</code>: 64 bytes, <code>pub_out</code>: 32 bytes</td>
</tr>
<tr>
<td><code>wasi_ed25519_sign</code></td>
<td><code>(priv: i32, data: i32, len: i32, sig_out: i32) -&gt; i32</code></td>
<td>Sign message. <code>sig_out</code>: 64 bytes</td>
</tr>
<tr>
<td><code>wasi_ed25519_verify</code></td>
<td><code>(pub: i32, data: i32, len: i32, sig: i32) -&gt; i32</code></td>
<td>Verify. Returns 0 if valid</td>
</tr>
</tbody></table>
<hr>
<h2 id="security"><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg></span>Security Considerations</h2>
<h3>Key Management</h3>
<ol>
<li><strong>Generate keys securely</strong> - Use the WASM module&#39;s key generation functions, which use the platform&#39;s cryptographic RNG</li>
<li><strong>Never reuse IVs</strong> - Generate a new random 16-byte IV for each encryption operation</li>
<li><strong>Derive keys with HKDF</strong> - Never use raw ECDH output directly as an encryption key</li>
</ol>
<pre><code>Shared Secret &#8594; HKDF(secret, salt, info) &#8594; Encryption Key
</code></pre>
<ol start="4">
<li><strong>Use unique info strings</strong> - Different purposes should use different HKDF info parameters:</li>
</ol>
<pre><code>HKDF(secret, null, &quot;encryption-key-v1&quot;) &#8594; Key for encrypting
HKDF(secret, null, &quot;authentication-key-v1&quot;) &#8594; Key for MAC (if needed)
</code></pre>
<h3>Memory Handling</h3>
<ol>
<li><strong>Zero sensitive data</strong> - After use, overwrite key material in memory</li>
<li><strong>Minimize key lifetime</strong> - Keep keys in WASM memory only as long as needed</li>
<li><strong>Free allocated memory</strong> - Always call <code>free()</code> to prevent memory leaks</li>
</ol>
<h3>What This Module Does NOT Protect</h3>
<ul>
<li><strong>Key storage</strong> - You must implement secure key storage for your platform</li>
<li><strong>Side-channel attacks</strong> - WASM runtimes may not be constant-time</li>
<li><strong>Authentication</strong> - Use signatures or HMAC to verify message integrity</li>
<li><strong>Forward secrecy</strong> - Implement ephemeral keys if needed</li>
</ul>
<hr>
<h2 id="performance"><span class="section-icon"><svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></span>Performance Optimization</h2>
<h3>1. Cache the WASM Module</h3>
<p>Loading and compiling WASM is expensive. Initialize once and reuse:</p>
<pre><code class="language-javascript">// Good: Initialize once
const module = await initEncryption();
// Reuse for all operations

// Bad: Initialize per operation
async function encrypt(data) {
  const module = await initEncryption(); // Slow!
  // ...
</code></pre>
<h3>2. Batch Operations</h3>
<p>Minimize WASM boundary crossings by processing multiple items:</p>
<pre><code class="language-javascript">// Good: Batch processing
const allData = items.map(i =&gt; i.data);
const results = encryptBatch(allData, key, ivs);

// Less efficient: One at a time
for (const item of items) {
  encrypt(item.data, key, iv);
</code></pre>
<h3>3. Reuse Memory Allocations</h3>
<p>For repeated operations of the same size, reuse allocated buffers:</p>
<pre><code class="language-go">// Good: Reuse buffers
keyPtr, _ := malloc(32)
defer free(keyPtr)

for _, data := range items {
    writeBytes(keyPtr, key)
    encrypt(keyPtr, ivPtr, dataPtr, len)

// Less efficient: Allocate each time
for _, data := range items {
    keyPtr, _ := malloc(32)
    // ...
    free(keyPtr)
</code></pre>
<h3>4. Use Streaming for Large Data</h3>
<p>For large files, process in chunks rather than loading everything into memory:</p>
<pre><code class="language-python">CHUNK_SIZE = 64 * 1024  # 64KB chunks

def encrypt_file(input_path, output_path, key):
    iv = os.urandom(16)
    with open(input_path, &#39;rb&#39;) as f_in, open(output_path, &#39;wb&#39;) as f_out:
        f_out.write(iv)  # Prepend IV
        while chunk := f_in.read(CHUNK_SIZE):
            encrypted = encrypt_bytes(key, iv, chunk)
            f_out.write(encrypted)
            # CTR mode: increment IV for next chunk
            iv = increment_iv(iv)
</code></pre>
<hr>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg></span>Troubleshooting</h2>
<h3>Common Issues</h3>
<h4>&quot;Cannot find module&quot; / &quot;WASM module not found&quot;</h4>
<p>The WASM binary must be accessible at runtime. Solutions:</p>
<ol>
<li><strong>Bundle with your application</strong> - Copy <code>flatc-encryption.wasm</code> to your build output</li>
<li><strong>Use absolute paths</strong> - Specify the full path to the WASM file</li>
<li><strong>Check file permissions</strong> - Ensure the WASM file is readable</li>
</ol>
<h4>&quot;Import not found: wasi_snapshot_preview1&quot;</h4>
<p>The WASM module requires WASI imports. Most runtimes provide these automatically:</p>
<ul>
<li><strong>wazero (Go)</strong>: Use <code>wasi_snapshot_preview1.MustInstantiate()</code></li>
<li><strong>wasmer (Python)</strong>: Configure WASI before instantiation</li>
<li><strong>Wasmtime (C#)</strong>: Call <code>linker.DefineWasi()</code></li>
</ul>
<h4>&quot;Import not found: env.invoke_*&quot;</h4>
<p>The module uses Emscripten&#39;s exception handling. You need to provide stub implementations:</p>
<pre><code class="language-javascript">// Minimal invoke_* stubs
const imports = {
  env: {
    invoke_v: (idx) =&gt; { /* call table[idx]() */ },
    invoke_vi: (idx, a) =&gt; { /* call table[idx](a) */ },
    invoke_vii: (idx, a, b) =&gt; { /* call table[idx](a, b) */ },
    // ... etc
};
</code></pre>
<p>See language-specific guides for complete implementations.</p>
<h4>&quot;Memory access out of bounds&quot;</h4>
<p>You&#39;re reading or writing outside allocated memory. Check:</p>
<ol>
<li><strong>Pointer validity</strong> - Ensure <code>malloc</code> returned non-zero</li>
<li><strong>Buffer sizes</strong> - Don&#39;t write more bytes than allocated</li>
<li><strong>Double-free</strong> - Don&#39;t free the same pointer twice</li>
</ol>
<h4>&quot;Invalid signature&quot; / &quot;Verification failed&quot;</h4>
<ol>
<li><strong>Check key types</strong> - Ed25519 uses 64-byte private keys, ECDSA uses 32-byte</li>
<li><strong>Hash before signing</strong> - secp256k1 and P-256 expect a 32-byte hash, not raw message</li>
<li><strong>Public key format</strong> - Ensure compressed (33 bytes) vs uncompressed (65 bytes) matches</li>
</ol>
<hr>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></span>Examples</h2>
<h3>End-to-End Encryption</h3>
<p>Complete example of encrypting a FlatBuffer for a recipient:</p>
<pre><code class="language-javascript">// 1. Generate sender&#39;s ephemeral keypair
const senderKeys = x25519GenerateKeyPair();

// 2. Compute shared secret with recipient&#39;s public key
const sharedSecret = x25519SharedSecret(
  senderKeys.privateKey,
  recipientPublicKey
);

// 3. Derive encryption key using HKDF
const encryptionKey = hkdf(
  sharedSecret,
  null, // no salt
  new TextEncoder().encode(&#39;flatbuffer-encryption-v1&#39;),
  32    // 256 bits
);

// 4. Generate random IV
const iv = crypto.getRandomValues(new Uint8Array(16));

// 5. Encrypt the FlatBuffer
const ciphertext = new Uint8Array(flatbuffer);
encryptBytes(ciphertext, encryptionKey, iv);

// 6. Package for transmission
const message = {
  senderPublicKey: senderKeys.publicKey, // 32 bytes
  iv: iv,                                 // 16 bytes
  ciphertext: ciphertext                  // encrypted data
};
</code></pre>
<h3>Cross-Language Verification</h3>
<p>Verify a signature created in another language:</p>
<pre><code class="language-go">// Go: Verify Ed25519 signature from Python
func verifyPythonSignature(publicKey, message, signature []byte) bool {
    module := loadEncryptionModule()

    pubPtr := writeBytes(module, publicKey)
    msgPtr := writeBytes(module, message)
    sigPtr := writeBytes(module, signature)
    defer freeAll(module, pubPtr, msgPtr, sigPtr)

    result := module.ed25519Verify(pubPtr, msgPtr, len(message), sigPtr)
    return result == 0 // 0 = valid
</code></pre>
<hr>
<h2><span class="section-icon"><svg viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg></span>Language Guides</h2>
<p>For detailed integration instructions, see:</p>
<ul>
<li><a href="go.html">Go Integration</a> - wazero runtime, pure Go</li>
<li><a href="python.html">Python Integration</a> - wasmer with Cranelift</li>
<li><a href="rust.html">Rust Integration</a> - wasmer crate</li>
<li><a href="java.html">Java Integration</a> - Chicory pure Java runtime</li>
<li><a href="csharp.html">C# Integration</a> - Wasmtime .NET bindings</li>
<li><a href="swift.html">Swift Integration</a> - WasmKit for iOS/macOS</li>
<li><a href="nodejs.html">Node.js Integration</a> - Native V8 WASM support</li>
<li><a href="browser.html">Browser Integration</a> - All modern browsers</li>
</ul>
</article>
  </div>

  <script>
    // Initialize video with random selection
    const videoUrls = [
      "../videos/bg-1.mp4",
      "../videos/bg-2.mp4",
      "../videos/bg-3.mp4",
      "../videos/bg-4.mp4",
      "../videos/bg-5.mp4",
      "../videos/bg-6.mp4",
      "../videos/bg-7.mp4",
      "../videos/bg-8.mp4",
      "../videos/bg-9.mp4",
      "../videos/bg-10.mp4",
      "../videos/bg-11.mp4"
    ];

    const video = document.getElementById('bg-video');
    video.src = videoUrls[Math.floor(Math.random() * videoUrls.length)];
  </script>
</body>
</html>